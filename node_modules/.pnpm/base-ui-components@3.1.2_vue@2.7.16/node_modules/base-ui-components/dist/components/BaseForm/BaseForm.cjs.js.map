{"version":3,"file":"BaseForm.cjs.js","sources":["../../../src/components/BaseForm/BaseForm.vue"],"sourcesContent":["<template>\n  <div\n    class=\"base-form\"\n    :style=\"formStyle\">\n    <!-- OPTIONAL HEADER -->\n    <component\n      :is=\"renderHeaderAs\"\n      v-if=\"formHeader\"\n      class=\"base-form__header\">\n      {{ formHeader }}\n    </component>\n    <!-- FORM -->\n    <div\n      class=\"base-form__body\">\n      <template\n        v-for=\"(element, index) in formFieldListInt\">\n        <!-- SINGLE FORM FIELD -->\n        <BaseFormFieldCreator\n          v-if=\"!allowMultiply(element)\"\n          :key=\"`${element.name}_${index}_${formId}`\"\n          :class=\"['base-form-field',\n                   formFieldsHalf.indexOf(element) >= 0\n                     ? 'base-form-field-half' : 'base-form-field-full',\n                   { 'base-form-field-top-margin': element.type === 'boolean'\n                     && formFieldsHalf.indexOf(element) >= 0 },\n                   { 'base-form-field-left-margin': isHalfFieldSecond(element)}]\"\n          v-bind=\"formFieldComponentProps(element, index)\"\n          @field-value-changed=\"setFieldValue($event, element.name)\"\n          @fetch-autocomplete=\"fetchAutocomplete\">\n          <template #label-addition=\"{ fieldName, groupNames }\">\n            <!-- @slot Slot to allow for additional elements on the right side of the label row <div> (e.g. language tabs))\n            @binding {string} fieldName - the name of the displayed field\n            @binding {string[]} groupNames - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              name=\"label-addition\"\n              :field-name=\"fieldName\"\n              :group-names=\"groupNames\" />\n          </template>\n          <template #pre-input-field=\"{ fieldName, groupNames }\">\n            <!-- @slot slot to add elements within the form field but in a row before the actual input field. for an example see [BaseInput](BaseInput)\n            @binding {string} fieldName - the name of the displayed field\n            @binding {string[]} groupNames - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              name=\"pre-input-field\"\n              :field-name=\"fieldName\"\n              :group-names=\"groupNames\" />\n          </template>\n          <template\n            #input-field-addition-before=\"{ fieldName, groupNames }\">\n            <!-- @slot Slot to allow for additional elements in the input field <div> (before <input>)\n            @binding {string} fieldName - the name of the displayed field\n            @binding {string[]} groupNames - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              name=\"input-field-addition-before\"\n              :field-name=\"fieldName\"\n              :group-names=\"groupNames\" />\n          </template>\n          <template #input-field-inline-before=\"{ fieldName, groupNames }\">\n            <!-- @slot to add elements directly inline before the input (contrary to `input-field-addition-before` this does not wrap. for an example see [BaseInput](BaseInput)\n            @binding {string} fieldName - the name of the displayed field\n            @binding {string[]} groupNames - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              name=\"input-field-inline-before\"\n              :field-name=\"fieldName\"\n              :group-names=\"groupNames\" />\n            <span\n              v-if=\"element['x-attrs'] && element['x-attrs'].text_before\"\n              class=\"base-form-field__text-before\">\n              {{ element['x-attrs'].text_before }}\n            </span>\n          </template>\n          <template #input-field-addition-after=\"{ fieldName, groupNames }\">\n            <span\n              v-if=\"element['x-attrs'] && element['x-attrs'].text_after\"\n              class=\"base-form-field__text-after\">\n              {{ element['x-attrs'].text_after }}\n            </span>\n            <!-- @slot for adding elements after input\n            @binding {string} fieldName - the name of the displayed field\n            @binding {string[]} groupNames - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              name=\"input-field-addition-after\"\n              :field-name=\"fieldName\"\n              :group-names=\"groupNames\" />\n          </template>\n          <template #post-input-field=\"{ fieldName, groupNames }\">\n            <!-- @slot for adding elements at the end covering the whole height\n            @binding {string} fieldName - the name of the displayed field\n            @binding {string[]} groupNames - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              name=\"post-input-field\"\n              :field-name=\"fieldName\"\n              :group-names=\"groupNames\" />\n          </template>\n          <template #error-icon>\n            <!-- @slot use a custom icon instead of standard error/warning icon -->\n            <slot name=\"error-icon\" />\n          </template>\n          <template #remove-icon>\n            <!-- @slot use a custom icon instead of standard remove icon -->\n            <slot name=\"remove-icon\" />\n          </template>\n          <template #below-input=\"{ fieldName, groupNames }\">\n            <!-- @slot below-input slot added to e.g. add drop down\n            @binding {string} fieldName - the name of the displayed field -->\n            <slot\n              name=\"below-input\"\n              :field-name=\"fieldName\"\n              :group-names=\"groupNames\" />\n          </template>\n        </BaseFormFieldCreator>\n\n        <!-- REPEATABLE FIELDS - ALLOW FOR MULTIPLE VALUES PER FIELD -->\n        <template v-else>\n          <!-- wrapper around form field group and remove button -->\n          <div\n            v-for=\"(value, valueIndex) in valueListInt[element.name]\"\n            :ref=\"element.name\"\n            :key=\"`${element.name}_${index}_${valueIndex}_${formId}_wrapper`\"\n            :class=\"['base-form-field',\n                     { 'base-form-field__multiple__inline': multiplyButtonsInline(element) },\n                     { 'base-form-field__multiple__inline--has-title': valueIndex === 0 },\n                     formFieldsHalf.indexOf(element) >= 0\n                       ? 'base-form-field-half' : 'base-form-field-full',\n                     { 'base-form-field-left-margin': isHalfFieldSecond(element) }]\">\n            <BaseFormFieldCreator\n              :key=\"`${element.name}_${index}_${valueIndex}_${formId}`\"\n              v-bind=\"formFieldComponentProps(element, index, valueIndex)\"\n              class=\"base-form-field__multiple__inline-element\"\n              @field-value-changed=\"setFieldValue(\n                $event,\n                element.name,\n                valueIndex,\n                (element['x-attrs'] ? element['x-attrs'].equivalent : ''))\"\n              @fetch-autocomplete=\"fetchAutocomplete\"\n              @subform-input=\"setFieldValue($event, element.name, valueIndex)\">\n              <template #label-addition=\"{ fieldName, groupNames }\">\n                <!-- @slot Slot to allow for additional elements on the right side of the label row <div> (e.g. language tabs))\n                @binding {string} fieldName - the name of the displayed field\n                @binding {number} index - the array index of field values -->\n                <slot\n                  name=\"label-addition\"\n                  :field-name=\"fieldName\"\n                  :group-names=\"groupNames\"\n                  :index=\"valueIndex\" />\n              </template>\n              <template #pre-input-field=\"{ fieldName, groupNames }\">\n                <!-- @slot slot to add elements within the form field but in a row before the actual input field. for an example see [BaseInput](BaseInput)\n                @binding {string} fieldName - the name of the displayed field\n                @binding {number} index - the array index of field values -->\n                <slot\n                  name=\"pre-input-field\"\n                  :field-name=\"fieldName\"\n                  :group-names=\"groupNames\"\n                  :index=\"valueIndex\" />\n              </template>\n              <template\n                #input-field-addition-before=\"{ fieldName, groupNames }\">\n                <!-- @slot Slot to allow for additional elements in the input field \\<div\\>\n                  (before \\<input\\>)\n                @binding {string} fieldName - the name of the displayed field\n                @binding {number} index - the array index of field values -->\n                <slot\n                  name=\"input-field-addition-before\"\n                  :field-name=\"fieldName\"\n                  :group-names=\"groupNames\"\n                  :index=\"valueIndex\" />\n              </template>\n              <template #input-field-inline-before=\"{ fieldName, groupNames }\">\n                <span\n                  v-if=\"element['x-attrs'] && element['x-attrs'].text_before\"\n                  class=\"base-form-field__text-before\">\n                  {{ element['x-attrs'].text_before }}\n                </span>\n                <!-- @slot to add elements directly inline before the input (contrary to input-field-addition-before this does not wrap. for an example see [BaseInput](BaseInput)\n                @binding {string} fieldName - the name of the displayed field\n                @binding {number} index - the array index of field values -->\n                <slot\n                  name=\"input-field-inline-before\"\n                  :field-name=\"fieldName\"\n                  :group-names=\"groupNames\"\n                  :index=\"valueIndex\" />\n              </template>\n              <template #input-field-addition-after=\"{ fieldName, groupNames }\">\n                <span\n                  v-if=\"element['x-attrs'] && element['x-attrs'].text_after\"\n                  class=\"base-form-field__text-after\">\n                  {{ element['x-attrs'].text_after }}\n                </span>\n                <!-- @slot for adding elements after input\n                @binding {string} fieldName - the name of the displayed field\n                @binding {number} index - the array index of field values -->\n                <slot\n                  name=\"input-field-addition-after\"\n                  :field-name=\"fieldName\"\n                  :group-names=\"groupNames\"\n                  :index=\"valueIndex\" />\n              </template>\n              <template #post-input-field=\"{ fieldName, groupNames }\">\n                <!-- @slot for adding elements at the end covering the whole height\n                @binding {string} fieldName - the name of the displayed field\n                @binding {number} index - the array index of field values -->\n                <slot\n                  name=\"post-input-field\"\n                  :field-name=\"fieldName\"\n                  :group-names=\"groupNames\"\n                  :index=\"valueIndex\" />\n              </template>\n              <template #error-icon>\n                <!-- @slot use a custom icon instead of standard error/warning icon -->\n                <slot name=\"error-icon\" />\n              </template>\n              <template #remove-icon>\n                <!-- @slot use a custom icon instead of standard remove icon -->\n                <slot name=\"remove-icon\" />\n              </template>\n              <template #below-input=\"{ fieldName, groupNames }\">\n                <!-- @slot below-input slot added to e.g. add drop down\n                @binding {string} fieldName - the name of the displayed field\n                @binding {number} index - the array index of field values -->\n                <slot\n                  name=\"below-input\"\n                  :field-name=\"fieldName\"\n                  :group-names=\"groupNames\"\n                  :index=\"valueIndex\" />\n              </template>\n            </BaseFormFieldCreator>\n\n            <!-- if there is field content show a 'remove all content' button -->\n            <div\n              v-if=\"!multiplyButtonsInline(element) && (checkFieldContent(valueList[element.name])\n                || valueListInt[element.name].length > 1)\"\n              :key=\"`${index}_button_${valueIndex}_${formId}`\"\n              class=\"group-add\">\n              <button\n                class=\"field-group-button\"\n                type=\"button\"\n                @click.prevent=\"removeField(element, valueIndex)\">\n                <span>\n                  {{ valueListInt[element.name].length === 1\n                    ? getI18nTerm('form.clearField') || 'Clear'\n                    : getI18nTerm('form.removeField', -1, { fieldType: getFieldName(element) }) }}\n                </span>\n                <span>\n                  <base-icon\n                    class=\"field-group-icon\"\n                    name=\"remove\" />\n                </span>\n              </button>\n            </div>\n            <template\n              v-if=\"multiplyButtonsInline(element)\">\n              <div\n                class=\"base-form__inline-icons\">\n                <base-icon\n                  v-if=\"checkFieldContent(valueList[element.name])\n                    || valueListInt[element.name].length > 1\"\n                  :title=\"valueListInt[element.name].length === 1\n                    ? getI18nTerm('form.clearField') || 'Clear'\n                    : getI18nTerm('form.removeField', -1, { fieldType: getFieldName(element) })\"\n                  role=\"button\"\n                  tabindex=\"0\"\n                  class=\"base-form__inline-icon\"\n                  name=\"remove\"\n                  @click.native=\"removeField(element, valueIndex)\"\n                  @keydown.enter.native=\"removeField(element, valueIndex)\" />\n                <base-icon\n                  :title=\"valueIndex !== (valueListInt[element.name].length - 1)\n                    ? getI18nTerm('form.addGroupBelow', -1, {\n                      fieldType: getFieldName(element),\n                    }) : getI18nTerm('form.addGroup', -1, {\n                      fieldType: getFieldName(element),\n                    })\"\n                  role=\"button\"\n                  tabindex=\"0\"\n                  class=\"base-form__inline-icon\"\n                  name=\"plus\"\n                  @click.native=\"multiplyField(element, valueIndex)\"\n                  @keydown.enter.native=\"multiplyField(element, valueIndex)\" />\n              </div>\n            </template>\n          </div>\n          <!-- multiply button -->\n          <div\n            v-if=\"!multiplyButtonsInline(element)\"\n            :key=\"'multiplyButton' + index\"\n            class=\"group-multiply\">\n            <button\n              class=\"field-group-button\"\n              type=\"button\"\n              @click.prevent=\"multiplyField(element)\">\n              <span>\n                {{ getI18nTerm('form.addGroup', -1, {\n                  fieldType: getFieldName(element),\n                }) }}\n              </span>\n              <span>\n                <base-icon\n                  class=\"field-group-icon\"\n                  name=\"plus\" />\n              </span>\n            </button>\n          </div>\n        </template>\n      </template>\n    </div>\n  </div>\n</template>\n\n<script>\nimport BaseIcon from '../BaseIcon/BaseIcon';\nimport i18n from '../../mixins/i18n';\nimport BaseFormFieldCreator from '../BaseFormFieldCreator/BaseFormFieldCreator';\n\n/**\n * Component creating a form according to a provided [openAPI](https://www.openapis.org/) standard\n */\n\n// list all the fieldProps here that can be set individually for each repeatable field\nconst INDIVIDUAL_REPEATABLE_FIELDPROPS = [\n  'errorMessage',\n  'invalid',\n  'isActive',\n  'isLoading',\n  'linkedListOption',\n  'activeTab',\n  'validationTexts',\n];\n\nexport default {\n  name: 'BaseForm',\n  components: {\n    BaseFormFieldCreator,\n    BaseIcon,\n  },\n  mixins: [i18n],\n  props: {\n    /**\n     * the json object containing all the field information incl. `x-attrs` custom field\n     * for placeholder, field type, etc. (for further documentation and configuration options see\n     * further down below [slots](BaseForm.html#slots))\n     */\n    formFieldJson: {\n      type: Object,\n      required: true,\n    },\n    /**\n     * the values for each field if any already present\n     */\n    valueList: {\n      type: Object,\n      default: () => ({}),\n    },\n    /**\n     * set current language\n     */\n    language: {\n      type: String,\n      default: 'en',\n    },\n    /**\n     * provide information about all available languages\n     */\n    availableLocales: {\n      type: Array,\n      default: () => [],\n    },\n    /**\n     * an id for field groups to still have unique field ids\n     */\n    formId: {\n      type: String,\n      default: '',\n    },\n    /**\n     * define additional style for the form\n     * should be an object e.g. `{ 'padding-top': 0 }`\n     */\n    formStyle: {\n      type: Object,\n      default: () => ({}),\n    },\n    /**\n     * define fields (specify field name!) for which tabs should be shown\n     */\n    fieldsWithTabs: {\n      type: Array,\n      default: () => [],\n    },\n    /**\n     * enter the field name of a field that is currently fetching autocomplete\n     * results\n     */\n    fieldIsLoading: {\n      type: String,\n      default: '',\n    },\n    /**\n     * provide an object that contains the options list for all\n     * fields with autocomplete / chips input\n     * for field type `group` provide a nested object with field names\n     * as properties and an array for each field to ensure the correct options are assigned\n     * even if field names within different groups are identical\n     */\n    dropDownLists: {\n      type: Object,\n      default: () => ({}),\n    },\n    /**\n     * define if error icon should be shown.\n     * for an example on how it looks on an individual form field see [BaseInput](BaseInput)\n     */\n    showErrorIcon: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * if `true` a remove icon will be shown allowing to remove\n     * all input at once.\n     * for an example on how it looks on an individual form field see [BaseInput](BaseInput)\n     */\n    clearable: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * provide an object with settings and properties for each field. This takes an object\n     * with the field name as properties with the props nested.\n     * `{ [fieldName1]: { required: false, ... }, [fieldName2]: { ... } }`\n     *\n     * find the possible variables at the respective input components:\n     * [BaseInput](BaseInput)\n     * [BaseAutocompleteInput](BaseAutocompleteInput)\n     * [BaseMultilineTextInput](BaseMultilineTextInput)\n     * [BaseChipsInput](BaseChipsInput)\n     * [BaseChipsBelow](BaseChipsBelow)\n     * [BaseDateInput](BaseDateInput)\n     * [BaseToggle](BaseToggle)\n     *\n     * **special case repeatable fields**: the following field props can be set individually\n     * per repeated field:\n     *  `errorMessage`, `invalid`, `isActive`, `isLoading`,\n     *  `linkedListOption`, `activeTab`\n     *  the field property value should be set as object specifying the field index as key:\n     *  `{ [fieldIndex]: [value to be set] }` (e.g. `{ required: { 0: false }}`)\n     */\n    fieldProps: {\n      type: Object,\n      default: () => ({}),\n      validator: val => Object.keys(val).length === 0 || Object.values(val)\n        .every(fieldProps => Object.keys(fieldProps)),\n    },\n    /**\n     * in case the field `form_group_title` was added to the `x-attrs` field, this is\n     * is rendered as a header above the form and here the HTML tag may be defined.\n     */\n    renderHeaderAs: {\n      type: String,\n      default: 'div',\n    },\n    /**\n     * define validation texts to be displayed below form field if input is invalid.\n     * for an example see [BaseInput](BaseInput)\n     */\n    validationTexts: {\n      type: Object,\n      default: () => ({\n        text: {\n          min: 'Value must be greater than or equal to {value}.',\n          max: 'Value must be less than or equal to {value}.',\n          minLength: 'Text must be at least {value} character(s) long.',\n          maxLength: 'Text cannot be longer than {value} characters.',\n        },\n      }),\n      // checking if all necessary properties are part of the provided object\n      validator: val => ['text'].every(prop => Object.keys(val).includes(prop))\n        && ['min', 'max', 'minLength', 'maxLength']\n          .every(prop => Object.keys(val.text).includes(prop)),\n    },\n  },\n  data() {\n    return {\n      /**\n       * variable to be able to focus to the field after multiply\n       * @type {?Object}\n       * @property {number} index - the index of the new field in the array\n       * @property {string} name - the name of the field\n       */\n      multiplyParams: null,\n      /**\n       * remember the field for which autocomplete is fetching\n       * @type {string}\n       */\n      fetchingAutocompleteFor: '',\n      /**\n       * variable saving the current field input string during\n       * autocomplete functionality\n       * @type {string}\n       */\n      currentInputString: '',\n      /**\n       * internal representation of valueList (containing values for all input fields)\n       * @type {Object}\n       * @property {?string|?Array|?Object} [the name of the input field]\n       */\n      valueListInt: {},\n    };\n  },\n  computed: {\n    /**\n     * get a list of all form fields that are taking half of the\n     * width of a form\n     * @returns {Object[]}\n     */\n    formFieldsHalf() {\n      return this.formFieldListInt.filter(field => field['x-attrs'] && field['x-attrs'].field_format === 'half');\n    },\n    /**\n     * internal form field list, sorted and with additional name property to save\n     * the name of the input field in a variable, also filtered from fields that\n     * should not be shown\n     *\n     * @returns {Object[]}\n     * @property {string} name - the name of the input field\n     * @property {*} [*] all other properties contained in the swagger\n     */\n    formFieldListInt() {\n      return Object.keys(this.formFieldJson)\n        // filter out hidden properties and $ref property from JSON\n        .filter(key => !this.formFieldJson[key].$ref\n          && !(this.formFieldJson[key]['x-attrs'] && this.formFieldJson[key]['x-attrs'].hidden))\n        .map(key => ({ ...{ name: key }, ...this.formFieldJson[key] }))\n        // sort the fields according to their x-attribute (order)\n        .sort((a, b) => {\n          if (a['x-attrs'] && b['x-attrs']) {\n            if (a['x-attrs'].order > b['x-attrs'].order) {\n              return 1;\n            }\n            return -1;\n          }\n          return -1;\n        });\n    },\n    /**\n     * get the title string for the form header if one was set in the OpenAPI definition\n     * @returns {string}\n     */\n    formHeader() {\n      // find a field with the x-attr form_group_title (formFieldListInt is already sorted\n      // by order x-attr so the the title of the field with the lowest order will automatically\n      // be chosen\n      const groupTitleField = this.formFieldListInt\n        .find(field => field['x-attrs'] && field['x-attrs'].form_group_title);\n      // return the title string for the header to set if one was found\n      return groupTitleField ? groupTitleField['x-attrs'].form_group_title : '';\n    },\n  },\n  watch: {\n    valueList: {\n      handler(val) {\n        const changedValues = Object.keys(this.valueListInt)\n          .some(key => JSON.stringify(this.valueListInt[key]) !== JSON.stringify(val[key]));\n        if (changedValues) {\n          this.initializeValueObject();\n        }\n      },\n      deep: true,\n    },\n    formFieldJson: {\n      handler() {\n        // if new field specifications were set - also reset the properties of the value object\n        this.valueListInt = {};\n        // initialize value object with new properties\n        this.initializeValueObject();\n      },\n      immediate: true,\n    },\n  },\n  updated() {\n    if (this.multiplyParams && this.multiplyParams.name) {\n      const elements = this.$refs[this.multiplyParams.name];\n      if (elements.length) {\n        // this seems like a stupid hack however had to do this because if 'getElementsByTagName'\n        // was evaluated immediately it came back empty for 'textarea' since for some reason\n        // this was not in the DOM tree yet... (no problems for input fields / subforms tho)\n        setTimeout((params) => {\n          const inputs = elements[params.index].getElementsByTagName('textarea').length\n            ? elements[params.index].getElementsByTagName('textarea')\n            : elements[params.index].getElementsByTagName('input');\n          if (inputs.length) {\n            inputs[0].focus();\n          }\n        }, 50, this.multiplyParams);\n      }\n      this.multiplyParams = null;\n    }\n  },\n  methods: {\n    fetchAutocomplete(params) {\n      this.currentInputString = params.value;\n      this.fetchingAutocompleteFor = params.name;\n      /**\n       * triggered if field has an autocomplete functionality\n       * (chips-input, autocomplete-input, chips-below-input)\n       *\n       * @event fetch-autocomplete\n       *\n       * @property {string} value - the string to autocomplete\n       * @property {string} name - the name of the field\n       * @property {string} source - the url to request the data from\n       * @property {?string} equivalent - string specified for related fields. e.g. for contributor roles equivalent is `contributor`\n       * @property {?string[]} parentFields - in case the autocomplete event originates from a subform the subform id's (field property names) are specififed in this array (most nested property last)\n       */\n      this.$emit('fetch-autocomplete', params);\n    },\n    // check if field can be multiplied\n    allowMultiply(el) {\n      // field can be multiplied if it is an array and not a chips or chips-below\n      // field\n      return el.type === 'array' && (!el['x-attrs'] || !el['x-attrs'].field_type || (el['x-attrs']\n        && !['chips', 'chips-below'].includes(el['x-attrs'].field_type)));\n    },\n    multiplyButtonsInline(el) {\n      return !['group', 'multiline'].includes(el['x-attrs'].field_type);\n    },\n    // triggered on user clicking multiply button\n    multiplyField(field, index) {\n      // get the initialized new field values\n      const newFieldValues = this.getInitialFieldValue(field.items);\n      // check if function call is coming from an input field where field can only be\n      // inserted at last position\n      if (!index && index !== 0) {\n        // add field at the end of array\n        this.valueListInt[field.name].push(newFieldValues);\n        // else its coming from an inline repeatable field\n      } else {\n        // insert at the correct level\n        this.valueListInt[field.name].splice(index + 1, 0, newFieldValues);\n      }\n      this.multiplyParams = {\n        index: !index && index !== 0\n          ? this.valueListInt[field.name].length - 1 : index + 1,\n        name: field.name,\n      };\n      // inform parent of changes\n      this.propagateValueListChanges();\n    },\n    // remove multiplied field again\n    removeField(field, index) {\n      const fieldGroupValues = this.valueListInt[field.name];\n      // only splice off group if more than one field visible\n      if (fieldGroupValues && fieldGroupValues.length > 1) {\n        fieldGroupValues.splice(index, 1);\n        // else just clear the fields\n      } else {\n        this.$set(fieldGroupValues, index, this.getInitialFieldValue(field.items));\n      }\n      // inform parent of changes\n      this.propagateValueListChanges();\n    },\n    propagateValueListChanges() {\n      /**\n       * event triggered when the values of a field were altered or a form\n       * field was added or removed\n       *\n       * @event values-changed\n       * @param {Object[]} - the changed value list\n       */\n      this.$emit('values-changed', this.valueListInt);\n    },\n    // check if field is half field and the second of two halves\n    isHalfFieldSecond(field) {\n      const index = this.formFieldsHalf.indexOf(field);\n      return index > 0 && !!(index % 2);\n    },\n    getFieldName(val) {\n      return val.title || this.getI18nTerm(`form.${val.name}` || val.name);\n    },\n    formFieldComponentProps(element, index, valueIndex) {\n      // get the element.name for easier access\n      const { name } = element;\n      // get all fieldProps of that field if set, otherwise set empty array\n      // important to create an independent copy because properties eventually get deleted\n      // later on\n      let singleFieldProps = this.fieldProps[name]\n        ? JSON.parse(JSON.stringify(this.fieldProps[name])) : {};\n      // store in variable if field is repeatable\n      const fieldRepeatable = valueIndex >= 0;\n      // check if field is repeatable\n      if (fieldRepeatable) {\n        // if yes get the field Props that are actually settable for each field individually\n        // and present in the fieldProps object\n        const existingIndividualFieldProps = Object.entries(singleFieldProps)\n          .filter(([key]) => INDIVIDUAL_REPEATABLE_FIELDPROPS.includes(key));\n        // now check if any individually settable field props were found for the field\n        if (existingIndividualFieldProps.length) {\n          // now get an object that only contains the fieldProps of repeatable fields where the\n          // index is present in the value object\n          // otherwise delete the value object from the fieldProps completely (since usually not\n          // compatible with actual fieldProp type and values not usable\n          const repeatableFieldProps = existingIndividualFieldProps.reduce((prev, [key, value]) => {\n            // check if the input field index exists as a key in the value object\n            if (Object.keys(value).includes(valueIndex.toString())) {\n              // if yes - add it to the object with the appropriate value\n              return {\n                ...prev,\n                [key]: value[valueIndex.toString()],\n              };\n            }\n            // else delete the fieldProp from the fieldProps object completely\n            delete singleFieldProps[key];\n            // and just return the unmodified object\n            return prev;\n          }, {});\n          // finally actually combine the original fieldProps object with the properties settable\n          // per repeated field\n          singleFieldProps = {\n            ...singleFieldProps,\n            ...repeatableFieldProps,\n\n          };\n        }\n      }\n      // create a unique string for identifier(key) purposes out of field index\n      // and (if field is repeatable) value index\n      const comboIndex = fieldRepeatable ? `${index}_${valueIndex}` : index;\n\n      return {\n        field: element,\n        label: singleFieldProps && singleFieldProps.label\n          ? singleFieldProps.label : this.getFieldName(element),\n        fieldProps: singleFieldProps,\n        showLabel: !this.allowMultiply(element)\n          || !this.multiplyButtonsInline(element) || valueIndex === 0,\n        dropDownList: this.dropDownLists[name],\n        secondaryDropdown: this.dropDownLists[`${name}_secondary`],\n        language: this.language,\n        availableLocales: this.availableLocales,\n        sortText: this.getI18nTerm('form.sort') || 'Sort',\n        fieldKey: `${name}_${comboIndex}_${this.formId}`,\n        fieldValue: fieldRepeatable ? this.valueListInt[name][valueIndex]\n          : this.valueListInt[name],\n        autocompleteLoading: this.fieldIsLoading === name,\n        // add component props to form fields creator props if list contains a field_type 'group'\n        fieldGroupParams: this.formFieldListInt\n          .some(field => field['x-attrs'] && field['x-attrs'].field_type === 'group')\n          ? this.$props : null,\n        clearable: this.clearable,\n        showErrorIcon: this.showErrorIcon,\n        validationTexts: singleFieldProps.validationTexts || this.validationTexts,\n      };\n    },\n    setFieldValue(value, fieldName, index) {\n      this.currentInputString = '';\n      if (index >= 0) {\n        this.$set(this.valueListInt[fieldName], index, JSON.parse(JSON.stringify(value)));\n      } else {\n        this.$set(this.valueListInt, fieldName, value ? JSON.parse(JSON.stringify(value)) : value);\n      }\n      this.$emit('values-changed', this.valueListInt);\n    },\n    initializeValueObject() {\n      this.formFieldListInt.forEach((field) => {\n        this.$set(\n          this.valueListInt,\n          field.name,\n          this.getInitialFieldValue(field),\n        );\n      });\n    },\n    getInitialFieldValue(field) {\n      // get the current field value\n      const value = this.valueList[field.name];\n      // get the OpenAPI definition field type\n      const { type } = field;\n      // get the OpenAPI x-attrs (that we use for form config) field type\n      const xAttrsFieldType = field['x-attrs'] && field['x-attrs'].field_type\n        ? field['x-attrs'].field_type : undefined;\n      // valid types in OpenAPI definition are 'number' and 'integer'\n      if (['number', 'integer'].includes(type)) {\n        return value || '';\n      }\n      // check special case single-choice chips (is chips but is saved as\n      // (multilang) object on backend)\n      if (xAttrsFieldType && xAttrsFieldType.includes('chips')\n        && type === 'object') {\n        if (value && Object.keys(value).length) {\n          return [].concat(value);\n        }\n        return [];\n      }\n      // check if field is array\n      if (type === 'array') {\n        // check if values are already present and set those if yes\n        if (typeof value === 'object' && value && value.length) {\n          return [].concat(value);\n        }\n        if (!field['x-attrs'] || !field['x-attrs'].field_type\n          || (xAttrsFieldType && !xAttrsFieldType.includes('chips'))) {\n          return [].concat(this.getInitialFieldValue(field.items));\n        }\n        // else return empty array\n        return [];\n        // check if field is object\n      } if (type === 'object') {\n        const initObj = {};\n        // for each property in the object also get initial values\n        Object.keys(field.properties).forEach((key) => {\n          this.$set(initObj, key, this.getInitialFieldValue(field.properties[key]));\n        });\n        return ({ ...initObj, ...value });\n      }\n\n      // check if field is boolean\n      if (type === 'boolean') {\n        return value || false;\n      }\n      // if it is not an array or object simply return value from list or empty string\n      return (typeof value === 'string' ? value : '');\n    },\n    checkFieldContent(fieldValues) {\n      let hasContent = false;\n      if (fieldValues && typeof fieldValues === 'object') {\n        if (fieldValues.length >= 0) {\n          fieldValues.forEach((values) => {\n            hasContent = this.checkFieldContent(values) || hasContent;\n          });\n        } else {\n          const objectKeys = Object.keys(fieldValues);\n          objectKeys\n            .forEach((key) => {\n              hasContent = this.checkFieldContent(fieldValues[key]) || hasContent;\n            });\n        }\n      } else {\n        hasContent = fieldValues === 0 || !!fieldValues || hasContent;\n      }\n      return hasContent;\n    },\n  },\n};\n</script>\n\n<style lang=\"scss\" scoped>\n  @import \"../../styles/variables\";\n\n  .base-form {\n    .base-form__header {\n      margin: $spacing-small $spacing;\n      color: $font-color-second;\n    }\n\n    .base-form__body {\n      background-color: white;\n      display: flex;\n      align-items: flex-start;\n      flex-wrap: wrap;\n      padding: $spacing $spacing 0;\n\n      .base-form-field {\n        margin-bottom: $spacing;\n      }\n\n      .base-form-field-full, .group-multiply {\n        flex: 0 0 100%;\n      }\n\n      .base-form-field-half {\n        // needed to add the 0.01rem for edge...\n        flex: 0 1 calc(50% - #{$spacing-small} - 0.01rem);\n        max-width: calc(50% - #{$spacing-small} - 0.01rem);\n      }\n\n      .base-form-field-left-margin {\n        margin-left: $spacing;\n      }\n\n      .base-form-field-top-margin {\n        margin-top: $line-height + $spacing-small;\n      }\n\n      .group-multiply {\n        margin-bottom: $spacing + $spacing-small;\n      }\n\n      .group-add {\n        margin-top: $spacing;\n      }\n\n      .field-group-button {\n        color: $font-color-second;\n        cursor: pointer;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        padding: 0;\n        background-color: inherit;\n        border: none;\n\n        &:hover {\n          color: $app-color;\n          fill: $app-color;\n        }\n\n        .field-group-icon {\n          flex: 0 0 auto;\n          margin: 0 $spacing;\n          height: $icon-small;\n          width: $icon-small;\n        }\n\n        &:focus .field-group-icon {\n          fill: $app-color;\n        }\n      }\n    }\n  }\n\n  .base-form-field__text-before {\n    margin-right: $spacing-small;\n  }\n\n  .base-form-field__text-after {\n    margin-left: $spacing-small;\n  }\n\n  .base-form-field__multiple__inline {\n    display: flex;\n    align-items: flex-start;\n\n    &.base-form-field__multiple__inline--has-title {\n      .base-form__inline-icons {\n        margin-top: $line-height + $spacing-small;\n      }\n    }\n\n    .base-form-field__multiple__inline-element {\n      flex: 1 1 auto;\n    }\n\n    .base-form__inline-icons {\n      margin-left: $spacing-small;\n      flex: 0 0 auto;\n      min-height: $row-height-small;\n      display: flex;\n      align-items: center;\n\n      .base-form__inline-icon {\n        height: $icon-medium;\n        width: $icon-medium;\n        flex: 0 0 auto;\n        color: $font-color-second;\n        margin: $spacing-small;\n        cursor: pointer;\n\n        &:hover, &:focus, &:active {\n          color: $app-color;\n        }\n      }\n    }\n  }\n\n  @media screen and (max-width: 870px) {\n    .base-form {\n      .base-form__body {\n        .base-form-field-half {\n          flex: 0 0 100%;\n          max-width: 100%;\n        }\n\n        .base-form-field-left-margin {\n          margin-left: 0;\n        }\n\n        .base-form-field-top-margin {\n          margin-top: 0;\n        }\n      }\n    }\n\n  }\n\n  @media screen and (max-width: $mobile) {\n    .base-form {\n      .base-form__body {\n        padding: $spacing $spacing-small $spacing-small;\n\n        .base-form-field {\n          margin-bottom: $spacing-small;\n        }\n\n        .base-form-field-half {\n          flex: 0 0 100%;\n        }\n\n        .base-form-field-left-margin {\n          margin-left: 0;\n        }\n\n        .group-multiply {\n          margin-bottom: $spacing-small + $spacing-small-half;\n          margin-top: $spacing-small;\n        }\n      }\n    }\n  }\n</style>\n\n<style lang=\"scss\">\n  @import \"../../styles/variables.scss\";\n\n  @media screen and (min-width: $mobile) {\n    .base-form-field {\n      .base-drop-down-list__container {\n        max-width: calc(100% - #{$spacing} * 2);\n      }\n\n      .base-form-subform-wrapper {\n        .base-drop-down-list__container {\n          max-width: calc(100% - #{$spacing} * 4.5 - 3px);\n        }\n\n        .base-form-field-left-margin {\n          .base-drop-down-list__container {\n            right: calc(#{$spacing} * 2.5 - 3px);\n          }\n        }\n      }\n    }\n  }\n</style>\n"],"names":["INDIVIDUAL_REPEATABLE_FIELDPROPS","_sfc_main","BaseFormFieldCreator","BaseIcon","i18n","val","fieldProps","prop","field","key","a","b","groupTitleField","elements","params","inputs","el","index","newFieldValues","fieldGroupValues","element","valueIndex","name","singleFieldProps","fieldRepeatable","existingIndividualFieldProps","repeatableFieldProps","prev","value","comboIndex","fieldName","type","xAttrsFieldType","initObj","fieldValues","hasContent","values"],"mappings":"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"}