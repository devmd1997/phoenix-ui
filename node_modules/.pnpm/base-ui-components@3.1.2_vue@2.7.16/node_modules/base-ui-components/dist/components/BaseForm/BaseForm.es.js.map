{"version":3,"file":"BaseForm.es.js","sources":["../../../src/components/BaseForm/BaseForm.vue"],"sourcesContent":["<template>\n  <div\n    class=\"base-form\"\n    :style=\"formStyle\">\n    <!-- OPTIONAL HEADER -->\n    <component\n      :is=\"renderHeaderAs\"\n      v-if=\"formHeader\"\n      class=\"base-form__header\">\n      {{ formHeader }}\n    </component>\n    <!-- FORM -->\n    <div\n      class=\"base-form__body\">\n      <template\n        v-for=\"(element, index) in formFieldListInt\">\n        <!-- SINGLE FORM FIELD -->\n        <BaseFormFieldCreator\n          v-if=\"!allowMultiply(element)\"\n          :key=\"`${element.name}_${index}_${formId}`\"\n          :class=\"['base-form-field',\n                   formFieldsHalf.indexOf(element) >= 0\n                     ? 'base-form-field-half' : 'base-form-field-full',\n                   { 'base-form-field-top-margin': element.type === 'boolean'\n                     && formFieldsHalf.indexOf(element) >= 0 },\n                   { 'base-form-field-left-margin': isHalfFieldSecond(element)}]\"\n          v-bind=\"formFieldComponentProps(element, index)\"\n          @field-value-changed=\"setFieldValue($event, element.name)\"\n          @fetch-autocomplete=\"fetchAutocomplete\">\n          <template #label-addition=\"{ fieldName, groupNames }\">\n            <!-- @slot Slot to allow for additional elements on the right side of the label row <div> (e.g. language tabs))\n            @binding {string} fieldName - the name of the displayed field\n            @binding {string[]} groupNames - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              name=\"label-addition\"\n              :field-name=\"fieldName\"\n              :group-names=\"groupNames\" />\n          </template>\n          <template #pre-input-field=\"{ fieldName, groupNames }\">\n            <!-- @slot slot to add elements within the form field but in a row before the actual input field. for an example see [BaseInput](BaseInput)\n            @binding {string} fieldName - the name of the displayed field\n            @binding {string[]} groupNames - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              name=\"pre-input-field\"\n              :field-name=\"fieldName\"\n              :group-names=\"groupNames\" />\n          </template>\n          <template\n            #input-field-addition-before=\"{ fieldName, groupNames }\">\n            <!-- @slot Slot to allow for additional elements in the input field <div> (before <input>)\n            @binding {string} fieldName - the name of the displayed field\n            @binding {string[]} groupNames - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              name=\"input-field-addition-before\"\n              :field-name=\"fieldName\"\n              :group-names=\"groupNames\" />\n          </template>\n          <template #input-field-inline-before=\"{ fieldName, groupNames }\">\n            <!-- @slot to add elements directly inline before the input (contrary to `input-field-addition-before` this does not wrap. for an example see [BaseInput](BaseInput)\n            @binding {string} fieldName - the name of the displayed field\n            @binding {string[]} groupNames - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              name=\"input-field-inline-before\"\n              :field-name=\"fieldName\"\n              :group-names=\"groupNames\" />\n            <span\n              v-if=\"element['x-attrs'] && element['x-attrs'].text_before\"\n              class=\"base-form-field__text-before\">\n              {{ element['x-attrs'].text_before }}\n            </span>\n          </template>\n          <template #input-field-addition-after=\"{ fieldName, groupNames }\">\n            <span\n              v-if=\"element['x-attrs'] && element['x-attrs'].text_after\"\n              class=\"base-form-field__text-after\">\n              {{ element['x-attrs'].text_after }}\n            </span>\n            <!-- @slot for adding elements after input\n            @binding {string} fieldName - the name of the displayed field\n            @binding {string[]} groupNames - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              name=\"input-field-addition-after\"\n              :field-name=\"fieldName\"\n              :group-names=\"groupNames\" />\n          </template>\n          <template #post-input-field=\"{ fieldName, groupNames }\">\n            <!-- @slot for adding elements at the end covering the whole height\n            @binding {string} fieldName - the name of the displayed field\n            @binding {string[]} groupNames - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              name=\"post-input-field\"\n              :field-name=\"fieldName\"\n              :group-names=\"groupNames\" />\n          </template>\n          <template #error-icon>\n            <!-- @slot use a custom icon instead of standard error/warning icon -->\n            <slot name=\"error-icon\" />\n          </template>\n          <template #remove-icon>\n            <!-- @slot use a custom icon instead of standard remove icon -->\n            <slot name=\"remove-icon\" />\n          </template>\n          <template #below-input=\"{ fieldName, groupNames }\">\n            <!-- @slot below-input slot added to e.g. add drop down\n            @binding {string} fieldName - the name of the displayed field -->\n            <slot\n              name=\"below-input\"\n              :field-name=\"fieldName\"\n              :group-names=\"groupNames\" />\n          </template>\n        </BaseFormFieldCreator>\n\n        <!-- REPEATABLE FIELDS - ALLOW FOR MULTIPLE VALUES PER FIELD -->\n        <template v-else>\n          <!-- wrapper around form field group and remove button -->\n          <div\n            v-for=\"(value, valueIndex) in valueListInt[element.name]\"\n            :ref=\"element.name\"\n            :key=\"`${element.name}_${index}_${valueIndex}_${formId}_wrapper`\"\n            :class=\"['base-form-field',\n                     { 'base-form-field__multiple__inline': multiplyButtonsInline(element) },\n                     { 'base-form-field__multiple__inline--has-title': valueIndex === 0 },\n                     formFieldsHalf.indexOf(element) >= 0\n                       ? 'base-form-field-half' : 'base-form-field-full',\n                     { 'base-form-field-left-margin': isHalfFieldSecond(element) }]\">\n            <BaseFormFieldCreator\n              :key=\"`${element.name}_${index}_${valueIndex}_${formId}`\"\n              v-bind=\"formFieldComponentProps(element, index, valueIndex)\"\n              class=\"base-form-field__multiple__inline-element\"\n              @field-value-changed=\"setFieldValue(\n                $event,\n                element.name,\n                valueIndex,\n                (element['x-attrs'] ? element['x-attrs'].equivalent : ''))\"\n              @fetch-autocomplete=\"fetchAutocomplete\"\n              @subform-input=\"setFieldValue($event, element.name, valueIndex)\">\n              <template #label-addition=\"{ fieldName, groupNames }\">\n                <!-- @slot Slot to allow for additional elements on the right side of the label row <div> (e.g. language tabs))\n                @binding {string} fieldName - the name of the displayed field\n                @binding {number} index - the array index of field values -->\n                <slot\n                  name=\"label-addition\"\n                  :field-name=\"fieldName\"\n                  :group-names=\"groupNames\"\n                  :index=\"valueIndex\" />\n              </template>\n              <template #pre-input-field=\"{ fieldName, groupNames }\">\n                <!-- @slot slot to add elements within the form field but in a row before the actual input field. for an example see [BaseInput](BaseInput)\n                @binding {string} fieldName - the name of the displayed field\n                @binding {number} index - the array index of field values -->\n                <slot\n                  name=\"pre-input-field\"\n                  :field-name=\"fieldName\"\n                  :group-names=\"groupNames\"\n                  :index=\"valueIndex\" />\n              </template>\n              <template\n                #input-field-addition-before=\"{ fieldName, groupNames }\">\n                <!-- @slot Slot to allow for additional elements in the input field \\<div\\>\n                  (before \\<input\\>)\n                @binding {string} fieldName - the name of the displayed field\n                @binding {number} index - the array index of field values -->\n                <slot\n                  name=\"input-field-addition-before\"\n                  :field-name=\"fieldName\"\n                  :group-names=\"groupNames\"\n                  :index=\"valueIndex\" />\n              </template>\n              <template #input-field-inline-before=\"{ fieldName, groupNames }\">\n                <span\n                  v-if=\"element['x-attrs'] && element['x-attrs'].text_before\"\n                  class=\"base-form-field__text-before\">\n                  {{ element['x-attrs'].text_before }}\n                </span>\n                <!-- @slot to add elements directly inline before the input (contrary to input-field-addition-before this does not wrap. for an example see [BaseInput](BaseInput)\n                @binding {string} fieldName - the name of the displayed field\n                @binding {number} index - the array index of field values -->\n                <slot\n                  name=\"input-field-inline-before\"\n                  :field-name=\"fieldName\"\n                  :group-names=\"groupNames\"\n                  :index=\"valueIndex\" />\n              </template>\n              <template #input-field-addition-after=\"{ fieldName, groupNames }\">\n                <span\n                  v-if=\"element['x-attrs'] && element['x-attrs'].text_after\"\n                  class=\"base-form-field__text-after\">\n                  {{ element['x-attrs'].text_after }}\n                </span>\n                <!-- @slot for adding elements after input\n                @binding {string} fieldName - the name of the displayed field\n                @binding {number} index - the array index of field values -->\n                <slot\n                  name=\"input-field-addition-after\"\n                  :field-name=\"fieldName\"\n                  :group-names=\"groupNames\"\n                  :index=\"valueIndex\" />\n              </template>\n              <template #post-input-field=\"{ fieldName, groupNames }\">\n                <!-- @slot for adding elements at the end covering the whole height\n                @binding {string} fieldName - the name of the displayed field\n                @binding {number} index - the array index of field values -->\n                <slot\n                  name=\"post-input-field\"\n                  :field-name=\"fieldName\"\n                  :group-names=\"groupNames\"\n                  :index=\"valueIndex\" />\n              </template>\n              <template #error-icon>\n                <!-- @slot use a custom icon instead of standard error/warning icon -->\n                <slot name=\"error-icon\" />\n              </template>\n              <template #remove-icon>\n                <!-- @slot use a custom icon instead of standard remove icon -->\n                <slot name=\"remove-icon\" />\n              </template>\n              <template #below-input=\"{ fieldName, groupNames }\">\n                <!-- @slot below-input slot added to e.g. add drop down\n                @binding {string} fieldName - the name of the displayed field\n                @binding {number} index - the array index of field values -->\n                <slot\n                  name=\"below-input\"\n                  :field-name=\"fieldName\"\n                  :group-names=\"groupNames\"\n                  :index=\"valueIndex\" />\n              </template>\n            </BaseFormFieldCreator>\n\n            <!-- if there is field content show a 'remove all content' button -->\n            <div\n              v-if=\"!multiplyButtonsInline(element) && (checkFieldContent(valueList[element.name])\n                || valueListInt[element.name].length > 1)\"\n              :key=\"`${index}_button_${valueIndex}_${formId}`\"\n              class=\"group-add\">\n              <button\n                class=\"field-group-button\"\n                type=\"button\"\n                @click.prevent=\"removeField(element, valueIndex)\">\n                <span>\n                  {{ valueListInt[element.name].length === 1\n                    ? getI18nTerm('form.clearField') || 'Clear'\n                    : getI18nTerm('form.removeField', -1, { fieldType: getFieldName(element) }) }}\n                </span>\n                <span>\n                  <base-icon\n                    class=\"field-group-icon\"\n                    name=\"remove\" />\n                </span>\n              </button>\n            </div>\n            <template\n              v-if=\"multiplyButtonsInline(element)\">\n              <div\n                class=\"base-form__inline-icons\">\n                <base-icon\n                  v-if=\"checkFieldContent(valueList[element.name])\n                    || valueListInt[element.name].length > 1\"\n                  :title=\"valueListInt[element.name].length === 1\n                    ? getI18nTerm('form.clearField') || 'Clear'\n                    : getI18nTerm('form.removeField', -1, { fieldType: getFieldName(element) })\"\n                  role=\"button\"\n                  tabindex=\"0\"\n                  class=\"base-form__inline-icon\"\n                  name=\"remove\"\n                  @click.native=\"removeField(element, valueIndex)\"\n                  @keydown.enter.native=\"removeField(element, valueIndex)\" />\n                <base-icon\n                  :title=\"valueIndex !== (valueListInt[element.name].length - 1)\n                    ? getI18nTerm('form.addGroupBelow', -1, {\n                      fieldType: getFieldName(element),\n                    }) : getI18nTerm('form.addGroup', -1, {\n                      fieldType: getFieldName(element),\n                    })\"\n                  role=\"button\"\n                  tabindex=\"0\"\n                  class=\"base-form__inline-icon\"\n                  name=\"plus\"\n                  @click.native=\"multiplyField(element, valueIndex)\"\n                  @keydown.enter.native=\"multiplyField(element, valueIndex)\" />\n              </div>\n            </template>\n          </div>\n          <!-- multiply button -->\n          <div\n            v-if=\"!multiplyButtonsInline(element)\"\n            :key=\"'multiplyButton' + index\"\n            class=\"group-multiply\">\n            <button\n              class=\"field-group-button\"\n              type=\"button\"\n              @click.prevent=\"multiplyField(element)\">\n              <span>\n                {{ getI18nTerm('form.addGroup', -1, {\n                  fieldType: getFieldName(element),\n                }) }}\n              </span>\n              <span>\n                <base-icon\n                  class=\"field-group-icon\"\n                  name=\"plus\" />\n              </span>\n            </button>\n          </div>\n        </template>\n      </template>\n    </div>\n  </div>\n</template>\n\n<script>\nimport BaseIcon from '../BaseIcon/BaseIcon';\nimport i18n from '../../mixins/i18n';\nimport BaseFormFieldCreator from '../BaseFormFieldCreator/BaseFormFieldCreator';\n\n/**\n * Component creating a form according to a provided [openAPI](https://www.openapis.org/) standard\n */\n\n// list all the fieldProps here that can be set individually for each repeatable field\nconst INDIVIDUAL_REPEATABLE_FIELDPROPS = [\n  'errorMessage',\n  'invalid',\n  'isActive',\n  'isLoading',\n  'linkedListOption',\n  'activeTab',\n  'validationTexts',\n];\n\nexport default {\n  name: 'BaseForm',\n  components: {\n    BaseFormFieldCreator,\n    BaseIcon,\n  },\n  mixins: [i18n],\n  props: {\n    /**\n     * the json object containing all the field information incl. `x-attrs` custom field\n     * for placeholder, field type, etc. (for further documentation and configuration options see\n     * further down below [slots](BaseForm.html#slots))\n     */\n    formFieldJson: {\n      type: Object,\n      required: true,\n    },\n    /**\n     * the values for each field if any already present\n     */\n    valueList: {\n      type: Object,\n      default: () => ({}),\n    },\n    /**\n     * set current language\n     */\n    language: {\n      type: String,\n      default: 'en',\n    },\n    /**\n     * provide information about all available languages\n     */\n    availableLocales: {\n      type: Array,\n      default: () => [],\n    },\n    /**\n     * an id for field groups to still have unique field ids\n     */\n    formId: {\n      type: String,\n      default: '',\n    },\n    /**\n     * define additional style for the form\n     * should be an object e.g. `{ 'padding-top': 0 }`\n     */\n    formStyle: {\n      type: Object,\n      default: () => ({}),\n    },\n    /**\n     * define fields (specify field name!) for which tabs should be shown\n     */\n    fieldsWithTabs: {\n      type: Array,\n      default: () => [],\n    },\n    /**\n     * enter the field name of a field that is currently fetching autocomplete\n     * results\n     */\n    fieldIsLoading: {\n      type: String,\n      default: '',\n    },\n    /**\n     * provide an object that contains the options list for all\n     * fields with autocomplete / chips input\n     * for field type `group` provide a nested object with field names\n     * as properties and an array for each field to ensure the correct options are assigned\n     * even if field names within different groups are identical\n     */\n    dropDownLists: {\n      type: Object,\n      default: () => ({}),\n    },\n    /**\n     * define if error icon should be shown.\n     * for an example on how it looks on an individual form field see [BaseInput](BaseInput)\n     */\n    showErrorIcon: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * if `true` a remove icon will be shown allowing to remove\n     * all input at once.\n     * for an example on how it looks on an individual form field see [BaseInput](BaseInput)\n     */\n    clearable: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * provide an object with settings and properties for each field. This takes an object\n     * with the field name as properties with the props nested.\n     * `{ [fieldName1]: { required: false, ... }, [fieldName2]: { ... } }`\n     *\n     * find the possible variables at the respective input components:\n     * [BaseInput](BaseInput)\n     * [BaseAutocompleteInput](BaseAutocompleteInput)\n     * [BaseMultilineTextInput](BaseMultilineTextInput)\n     * [BaseChipsInput](BaseChipsInput)\n     * [BaseChipsBelow](BaseChipsBelow)\n     * [BaseDateInput](BaseDateInput)\n     * [BaseToggle](BaseToggle)\n     *\n     * **special case repeatable fields**: the following field props can be set individually\n     * per repeated field:\n     *  `errorMessage`, `invalid`, `isActive`, `isLoading`,\n     *  `linkedListOption`, `activeTab`\n     *  the field property value should be set as object specifying the field index as key:\n     *  `{ [fieldIndex]: [value to be set] }` (e.g. `{ required: { 0: false }}`)\n     */\n    fieldProps: {\n      type: Object,\n      default: () => ({}),\n      validator: val => Object.keys(val).length === 0 || Object.values(val)\n        .every(fieldProps => Object.keys(fieldProps)),\n    },\n    /**\n     * in case the field `form_group_title` was added to the `x-attrs` field, this is\n     * is rendered as a header above the form and here the HTML tag may be defined.\n     */\n    renderHeaderAs: {\n      type: String,\n      default: 'div',\n    },\n    /**\n     * define validation texts to be displayed below form field if input is invalid.\n     * for an example see [BaseInput](BaseInput)\n     */\n    validationTexts: {\n      type: Object,\n      default: () => ({\n        text: {\n          min: 'Value must be greater than or equal to {value}.',\n          max: 'Value must be less than or equal to {value}.',\n          minLength: 'Text must be at least {value} character(s) long.',\n          maxLength: 'Text cannot be longer than {value} characters.',\n        },\n      }),\n      // checking if all necessary properties are part of the provided object\n      validator: val => ['text'].every(prop => Object.keys(val).includes(prop))\n        && ['min', 'max', 'minLength', 'maxLength']\n          .every(prop => Object.keys(val.text).includes(prop)),\n    },\n  },\n  data() {\n    return {\n      /**\n       * variable to be able to focus to the field after multiply\n       * @type {?Object}\n       * @property {number} index - the index of the new field in the array\n       * @property {string} name - the name of the field\n       */\n      multiplyParams: null,\n      /**\n       * remember the field for which autocomplete is fetching\n       * @type {string}\n       */\n      fetchingAutocompleteFor: '',\n      /**\n       * variable saving the current field input string during\n       * autocomplete functionality\n       * @type {string}\n       */\n      currentInputString: '',\n      /**\n       * internal representation of valueList (containing values for all input fields)\n       * @type {Object}\n       * @property {?string|?Array|?Object} [the name of the input field]\n       */\n      valueListInt: {},\n    };\n  },\n  computed: {\n    /**\n     * get a list of all form fields that are taking half of the\n     * width of a form\n     * @returns {Object[]}\n     */\n    formFieldsHalf() {\n      return this.formFieldListInt.filter(field => field['x-attrs'] && field['x-attrs'].field_format === 'half');\n    },\n    /**\n     * internal form field list, sorted and with additional name property to save\n     * the name of the input field in a variable, also filtered from fields that\n     * should not be shown\n     *\n     * @returns {Object[]}\n     * @property {string} name - the name of the input field\n     * @property {*} [*] all other properties contained in the swagger\n     */\n    formFieldListInt() {\n      return Object.keys(this.formFieldJson)\n        // filter out hidden properties and $ref property from JSON\n        .filter(key => !this.formFieldJson[key].$ref\n          && !(this.formFieldJson[key]['x-attrs'] && this.formFieldJson[key]['x-attrs'].hidden))\n        .map(key => ({ ...{ name: key }, ...this.formFieldJson[key] }))\n        // sort the fields according to their x-attribute (order)\n        .sort((a, b) => {\n          if (a['x-attrs'] && b['x-attrs']) {\n            if (a['x-attrs'].order > b['x-attrs'].order) {\n              return 1;\n            }\n            return -1;\n          }\n          return -1;\n        });\n    },\n    /**\n     * get the title string for the form header if one was set in the OpenAPI definition\n     * @returns {string}\n     */\n    formHeader() {\n      // find a field with the x-attr form_group_title (formFieldListInt is already sorted\n      // by order x-attr so the the title of the field with the lowest order will automatically\n      // be chosen\n      const groupTitleField = this.formFieldListInt\n        .find(field => field['x-attrs'] && field['x-attrs'].form_group_title);\n      // return the title string for the header to set if one was found\n      return groupTitleField ? groupTitleField['x-attrs'].form_group_title : '';\n    },\n  },\n  watch: {\n    valueList: {\n      handler(val) {\n        const changedValues = Object.keys(this.valueListInt)\n          .some(key => JSON.stringify(this.valueListInt[key]) !== JSON.stringify(val[key]));\n        if (changedValues) {\n          this.initializeValueObject();\n        }\n      },\n      deep: true,\n    },\n    formFieldJson: {\n      handler() {\n        // if new field specifications were set - also reset the properties of the value object\n        this.valueListInt = {};\n        // initialize value object with new properties\n        this.initializeValueObject();\n      },\n      immediate: true,\n    },\n  },\n  updated() {\n    if (this.multiplyParams && this.multiplyParams.name) {\n      const elements = this.$refs[this.multiplyParams.name];\n      if (elements.length) {\n        // this seems like a stupid hack however had to do this because if 'getElementsByTagName'\n        // was evaluated immediately it came back empty for 'textarea' since for some reason\n        // this was not in the DOM tree yet... (no problems for input fields / subforms tho)\n        setTimeout((params) => {\n          const inputs = elements[params.index].getElementsByTagName('textarea').length\n            ? elements[params.index].getElementsByTagName('textarea')\n            : elements[params.index].getElementsByTagName('input');\n          if (inputs.length) {\n            inputs[0].focus();\n          }\n        }, 50, this.multiplyParams);\n      }\n      this.multiplyParams = null;\n    }\n  },\n  methods: {\n    fetchAutocomplete(params) {\n      this.currentInputString = params.value;\n      this.fetchingAutocompleteFor = params.name;\n      /**\n       * triggered if field has an autocomplete functionality\n       * (chips-input, autocomplete-input, chips-below-input)\n       *\n       * @event fetch-autocomplete\n       *\n       * @property {string} value - the string to autocomplete\n       * @property {string} name - the name of the field\n       * @property {string} source - the url to request the data from\n       * @property {?string} equivalent - string specified for related fields. e.g. for contributor roles equivalent is `contributor`\n       * @property {?string[]} parentFields - in case the autocomplete event originates from a subform the subform id's (field property names) are specififed in this array (most nested property last)\n       */\n      this.$emit('fetch-autocomplete', params);\n    },\n    // check if field can be multiplied\n    allowMultiply(el) {\n      // field can be multiplied if it is an array and not a chips or chips-below\n      // field\n      return el.type === 'array' && (!el['x-attrs'] || !el['x-attrs'].field_type || (el['x-attrs']\n        && !['chips', 'chips-below'].includes(el['x-attrs'].field_type)));\n    },\n    multiplyButtonsInline(el) {\n      return !['group', 'multiline'].includes(el['x-attrs'].field_type);\n    },\n    // triggered on user clicking multiply button\n    multiplyField(field, index) {\n      // get the initialized new field values\n      const newFieldValues = this.getInitialFieldValue(field.items);\n      // check if function call is coming from an input field where field can only be\n      // inserted at last position\n      if (!index && index !== 0) {\n        // add field at the end of array\n        this.valueListInt[field.name].push(newFieldValues);\n        // else its coming from an inline repeatable field\n      } else {\n        // insert at the correct level\n        this.valueListInt[field.name].splice(index + 1, 0, newFieldValues);\n      }\n      this.multiplyParams = {\n        index: !index && index !== 0\n          ? this.valueListInt[field.name].length - 1 : index + 1,\n        name: field.name,\n      };\n      // inform parent of changes\n      this.propagateValueListChanges();\n    },\n    // remove multiplied field again\n    removeField(field, index) {\n      const fieldGroupValues = this.valueListInt[field.name];\n      // only splice off group if more than one field visible\n      if (fieldGroupValues && fieldGroupValues.length > 1) {\n        fieldGroupValues.splice(index, 1);\n        // else just clear the fields\n      } else {\n        this.$set(fieldGroupValues, index, this.getInitialFieldValue(field.items));\n      }\n      // inform parent of changes\n      this.propagateValueListChanges();\n    },\n    propagateValueListChanges() {\n      /**\n       * event triggered when the values of a field were altered or a form\n       * field was added or removed\n       *\n       * @event values-changed\n       * @param {Object[]} - the changed value list\n       */\n      this.$emit('values-changed', this.valueListInt);\n    },\n    // check if field is half field and the second of two halves\n    isHalfFieldSecond(field) {\n      const index = this.formFieldsHalf.indexOf(field);\n      return index > 0 && !!(index % 2);\n    },\n    getFieldName(val) {\n      return val.title || this.getI18nTerm(`form.${val.name}` || val.name);\n    },\n    formFieldComponentProps(element, index, valueIndex) {\n      // get the element.name for easier access\n      const { name } = element;\n      // get all fieldProps of that field if set, otherwise set empty array\n      // important to create an independent copy because properties eventually get deleted\n      // later on\n      let singleFieldProps = this.fieldProps[name]\n        ? JSON.parse(JSON.stringify(this.fieldProps[name])) : {};\n      // store in variable if field is repeatable\n      const fieldRepeatable = valueIndex >= 0;\n      // check if field is repeatable\n      if (fieldRepeatable) {\n        // if yes get the field Props that are actually settable for each field individually\n        // and present in the fieldProps object\n        const existingIndividualFieldProps = Object.entries(singleFieldProps)\n          .filter(([key]) => INDIVIDUAL_REPEATABLE_FIELDPROPS.includes(key));\n        // now check if any individually settable field props were found for the field\n        if (existingIndividualFieldProps.length) {\n          // now get an object that only contains the fieldProps of repeatable fields where the\n          // index is present in the value object\n          // otherwise delete the value object from the fieldProps completely (since usually not\n          // compatible with actual fieldProp type and values not usable\n          const repeatableFieldProps = existingIndividualFieldProps.reduce((prev, [key, value]) => {\n            // check if the input field index exists as a key in the value object\n            if (Object.keys(value).includes(valueIndex.toString())) {\n              // if yes - add it to the object with the appropriate value\n              return {\n                ...prev,\n                [key]: value[valueIndex.toString()],\n              };\n            }\n            // else delete the fieldProp from the fieldProps object completely\n            delete singleFieldProps[key];\n            // and just return the unmodified object\n            return prev;\n          }, {});\n          // finally actually combine the original fieldProps object with the properties settable\n          // per repeated field\n          singleFieldProps = {\n            ...singleFieldProps,\n            ...repeatableFieldProps,\n\n          };\n        }\n      }\n      // create a unique string for identifier(key) purposes out of field index\n      // and (if field is repeatable) value index\n      const comboIndex = fieldRepeatable ? `${index}_${valueIndex}` : index;\n\n      return {\n        field: element,\n        label: singleFieldProps && singleFieldProps.label\n          ? singleFieldProps.label : this.getFieldName(element),\n        fieldProps: singleFieldProps,\n        showLabel: !this.allowMultiply(element)\n          || !this.multiplyButtonsInline(element) || valueIndex === 0,\n        dropDownList: this.dropDownLists[name],\n        secondaryDropdown: this.dropDownLists[`${name}_secondary`],\n        language: this.language,\n        availableLocales: this.availableLocales,\n        sortText: this.getI18nTerm('form.sort') || 'Sort',\n        fieldKey: `${name}_${comboIndex}_${this.formId}`,\n        fieldValue: fieldRepeatable ? this.valueListInt[name][valueIndex]\n          : this.valueListInt[name],\n        autocompleteLoading: this.fieldIsLoading === name,\n        // add component props to form fields creator props if list contains a field_type 'group'\n        fieldGroupParams: this.formFieldListInt\n          .some(field => field['x-attrs'] && field['x-attrs'].field_type === 'group')\n          ? this.$props : null,\n        clearable: this.clearable,\n        showErrorIcon: this.showErrorIcon,\n        validationTexts: singleFieldProps.validationTexts || this.validationTexts,\n      };\n    },\n    setFieldValue(value, fieldName, index) {\n      this.currentInputString = '';\n      if (index >= 0) {\n        this.$set(this.valueListInt[fieldName], index, JSON.parse(JSON.stringify(value)));\n      } else {\n        this.$set(this.valueListInt, fieldName, value ? JSON.parse(JSON.stringify(value)) : value);\n      }\n      this.$emit('values-changed', this.valueListInt);\n    },\n    initializeValueObject() {\n      this.formFieldListInt.forEach((field) => {\n        this.$set(\n          this.valueListInt,\n          field.name,\n          this.getInitialFieldValue(field),\n        );\n      });\n    },\n    getInitialFieldValue(field) {\n      // get the current field value\n      const value = this.valueList[field.name];\n      // get the OpenAPI definition field type\n      const { type } = field;\n      // get the OpenAPI x-attrs (that we use for form config) field type\n      const xAttrsFieldType = field['x-attrs'] && field['x-attrs'].field_type\n        ? field['x-attrs'].field_type : undefined;\n      // valid types in OpenAPI definition are 'number' and 'integer'\n      if (['number', 'integer'].includes(type)) {\n        return value || '';\n      }\n      // check special case single-choice chips (is chips but is saved as\n      // (multilang) object on backend)\n      if (xAttrsFieldType && xAttrsFieldType.includes('chips')\n        && type === 'object') {\n        if (value && Object.keys(value).length) {\n          return [].concat(value);\n        }\n        return [];\n      }\n      // check if field is array\n      if (type === 'array') {\n        // check if values are already present and set those if yes\n        if (typeof value === 'object' && value && value.length) {\n          return [].concat(value);\n        }\n        if (!field['x-attrs'] || !field['x-attrs'].field_type\n          || (xAttrsFieldType && !xAttrsFieldType.includes('chips'))) {\n          return [].concat(this.getInitialFieldValue(field.items));\n        }\n        // else return empty array\n        return [];\n        // check if field is object\n      } if (type === 'object') {\n        const initObj = {};\n        // for each property in the object also get initial values\n        Object.keys(field.properties).forEach((key) => {\n          this.$set(initObj, key, this.getInitialFieldValue(field.properties[key]));\n        });\n        return ({ ...initObj, ...value });\n      }\n\n      // check if field is boolean\n      if (type === 'boolean') {\n        return value || false;\n      }\n      // if it is not an array or object simply return value from list or empty string\n      return (typeof value === 'string' ? value : '');\n    },\n    checkFieldContent(fieldValues) {\n      let hasContent = false;\n      if (fieldValues && typeof fieldValues === 'object') {\n        if (fieldValues.length >= 0) {\n          fieldValues.forEach((values) => {\n            hasContent = this.checkFieldContent(values) || hasContent;\n          });\n        } else {\n          const objectKeys = Object.keys(fieldValues);\n          objectKeys\n            .forEach((key) => {\n              hasContent = this.checkFieldContent(fieldValues[key]) || hasContent;\n            });\n        }\n      } else {\n        hasContent = fieldValues === 0 || !!fieldValues || hasContent;\n      }\n      return hasContent;\n    },\n  },\n};\n</script>\n\n<style lang=\"scss\" scoped>\n  @import \"../../styles/variables\";\n\n  .base-form {\n    .base-form__header {\n      margin: $spacing-small $spacing;\n      color: $font-color-second;\n    }\n\n    .base-form__body {\n      background-color: white;\n      display: flex;\n      align-items: flex-start;\n      flex-wrap: wrap;\n      padding: $spacing $spacing 0;\n\n      .base-form-field {\n        margin-bottom: $spacing;\n      }\n\n      .base-form-field-full, .group-multiply {\n        flex: 0 0 100%;\n      }\n\n      .base-form-field-half {\n        // needed to add the 0.01rem for edge...\n        flex: 0 1 calc(50% - #{$spacing-small} - 0.01rem);\n        max-width: calc(50% - #{$spacing-small} - 0.01rem);\n      }\n\n      .base-form-field-left-margin {\n        margin-left: $spacing;\n      }\n\n      .base-form-field-top-margin {\n        margin-top: $line-height + $spacing-small;\n      }\n\n      .group-multiply {\n        margin-bottom: $spacing + $spacing-small;\n      }\n\n      .group-add {\n        margin-top: $spacing;\n      }\n\n      .field-group-button {\n        color: $font-color-second;\n        cursor: pointer;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        padding: 0;\n        background-color: inherit;\n        border: none;\n\n        &:hover {\n          color: $app-color;\n          fill: $app-color;\n        }\n\n        .field-group-icon {\n          flex: 0 0 auto;\n          margin: 0 $spacing;\n          height: $icon-small;\n          width: $icon-small;\n        }\n\n        &:focus .field-group-icon {\n          fill: $app-color;\n        }\n      }\n    }\n  }\n\n  .base-form-field__text-before {\n    margin-right: $spacing-small;\n  }\n\n  .base-form-field__text-after {\n    margin-left: $spacing-small;\n  }\n\n  .base-form-field__multiple__inline {\n    display: flex;\n    align-items: flex-start;\n\n    &.base-form-field__multiple__inline--has-title {\n      .base-form__inline-icons {\n        margin-top: $line-height + $spacing-small;\n      }\n    }\n\n    .base-form-field__multiple__inline-element {\n      flex: 1 1 auto;\n    }\n\n    .base-form__inline-icons {\n      margin-left: $spacing-small;\n      flex: 0 0 auto;\n      min-height: $row-height-small;\n      display: flex;\n      align-items: center;\n\n      .base-form__inline-icon {\n        height: $icon-medium;\n        width: $icon-medium;\n        flex: 0 0 auto;\n        color: $font-color-second;\n        margin: $spacing-small;\n        cursor: pointer;\n\n        &:hover, &:focus, &:active {\n          color: $app-color;\n        }\n      }\n    }\n  }\n\n  @media screen and (max-width: 870px) {\n    .base-form {\n      .base-form__body {\n        .base-form-field-half {\n          flex: 0 0 100%;\n          max-width: 100%;\n        }\n\n        .base-form-field-left-margin {\n          margin-left: 0;\n        }\n\n        .base-form-field-top-margin {\n          margin-top: 0;\n        }\n      }\n    }\n\n  }\n\n  @media screen and (max-width: $mobile) {\n    .base-form {\n      .base-form__body {\n        padding: $spacing $spacing-small $spacing-small;\n\n        .base-form-field {\n          margin-bottom: $spacing-small;\n        }\n\n        .base-form-field-half {\n          flex: 0 0 100%;\n        }\n\n        .base-form-field-left-margin {\n          margin-left: 0;\n        }\n\n        .group-multiply {\n          margin-bottom: $spacing-small + $spacing-small-half;\n          margin-top: $spacing-small;\n        }\n      }\n    }\n  }\n</style>\n\n<style lang=\"scss\">\n  @import \"../../styles/variables.scss\";\n\n  @media screen and (min-width: $mobile) {\n    .base-form-field {\n      .base-drop-down-list__container {\n        max-width: calc(100% - #{$spacing} * 2);\n      }\n\n      .base-form-subform-wrapper {\n        .base-drop-down-list__container {\n          max-width: calc(100% - #{$spacing} * 4.5 - 3px);\n        }\n\n        .base-form-field-left-margin {\n          .base-drop-down-list__container {\n            right: calc(#{$spacing} * 2.5 - 3px);\n          }\n        }\n      }\n    }\n  }\n</style>\n"],"names":["INDIVIDUAL_REPEATABLE_FIELDPROPS","_sfc_main","BaseFormFieldCreator","BaseIcon","i18n","val","fieldProps","prop","field","key","a","b","groupTitleField","elements","params","inputs","el","index","newFieldValues","fieldGroupValues","element","valueIndex","name","singleFieldProps","fieldRepeatable","existingIndividualFieldProps","repeatableFieldProps","prev","value","comboIndex","fieldName","type","xAttrsFieldType","initObj","fieldValues","hasContent","values"],"mappings":"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"}