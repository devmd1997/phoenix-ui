{"version":3,"file":"BaseDateInput.cjs.js","sources":["../../../src/components/BaseDateInput/BaseDateInput.vue"],"sourcesContent":["<template>\n  <div\n    ref=\"baseDateInput\"\n    class=\"base-date-input\">\n    <div\n      v-if=\"showLabelRow\"\n      :class=\"['base-date-input__label-row',\n               { 'base-date-input__label-row--visible': showLabel }]\">\n      <legend\n        v-if=\"showLabel\"\n        ref=\"label\"\n        class=\"base-date-input__label\"\n        @click.prevent=\"\">\n        {{ label }}\n      </legend>\n      <div\n        :class=\"['base-date-input__label-additions',\n                 {'base-date-input__label-additions--switch-height': isSwitchableFormat },\n                 {'base-date-input__label-additions--wrap': wrapLabelRow }]\">\n        <div\n          ref=\"labelAdditions\"\n          :class=\"['base-date-input__label-additions-inner',\n                   {'base-date-input__label-additions-inner--switch': isSwitchableFormat },\n                   {'base-date-input__label-additions-inner--no-label-switch': isSwitchableFormat\n                     && !showLabel }]\">\n          <!-- @slot to add additional elements to the label row -->\n          <slot name=\"label-addition\" />\n          <BaseSwitchButton\n            v-if=\"isSwitchableFormat\"\n            v-model=\"dateFormatInt\"\n            :options=\"tabSwitchOptions\"\n            :label=\"formatTabsLegend\"\n            :active-tab=\"dateFormatInt\"\n            class=\"base-date-input__switch-buttons\" />\n        </div>\n      </div>\n    </div>\n\n    <!-- FORM FIELDS -->\n    <!-- keydown event is counter productive to workflow here -->\n    <!-- eslint-disable-next-line vuejs-accessibility/click-events-have-key-events -->\n    <div\n      v-click-outside=\"clickedOutside\"\n      class=\"base-date-input__field-wrapper\"\n      @click=\"clickedInside\">\n      <!-- @slot to add elements within form field but before the input element line for an example see [BaseInput](BaseInput)-->\n      <slot name=\"pre-input-field\" />\n      <div class=\"base-date-input__input-fields\">\n        <!-- @slot add elements within input form field but before all other elements - this field wraps if necessary for an example see [BaseInput](BaseInput) -->\n        <slot name=\"input-field-addition-before\" />\n        <div class=\"base-date-input__input-line\">\n          <!-- @slot add elements directly in the input line (no wrapping) for an example see [BaseInput](BaseInput)-->\n          <slot name=\"input-field-inline-before\" />\n          <!-- INPUT FROM -->\n          <BaseInput\n            :id=\"label + '-' + id\"\n            v-model=\"inputFrom\"\n            :label=\"label\"\n            :show-label=\"false\"\n            :is-active=\"fromOpen\"\n            :use-form-field-styling=\"useFormFieldStyling\"\n            :show-input-border=\"showInputBorder\"\n            :clearable=\"clearable\"\n            :required=\"required\"\n            :invalid=\"invalid\"\n            :disabled=\"disabled\"\n            :show-error-icon=\"showErrorIcon\"\n            :error-message=\"errorMessage\"\n            :input-class=\"inputClass\"\n            :set-focus-on-active=\"setFocusOnActive\"\n            :use-fade-out=\"useFadeOutFrom\"\n            class=\"base-date-input__input-wrapper\"\n            @update:is-active=\"isActiveHandler('fromOpen', $event)\"\n            v-on=\"inputListeners\">\n            <template #input>\n              <div\n                class=\"base-date-input__datepicker\">\n                <DatePicker\n                  v-model=\"inputFrom\"\n                  :input-attr=\"{ id: label + '-' + id }\"\n                  :placeholder=\"isFromTimeField ? placeholder.time : placeholder.date\"\n                  :clearable=\"false\"\n                  :append-to-body=\"false\"\n                  :lang=\"lang[language]\"\n                  :open=\"fromOpen\"\n                  :type=\"isFromTimeField ? 'time' : minDateView\"\n                  :format=\"isFromTimeField ? 'HH:mm' : dateFormatDisplay\"\n                  :value-type=\"isFromTimeField ? 'format' : dateFormatInt\"\n                  input-class=\"base-date-input__datepicker-input\"\n                  @pick=\"datePicked('from')\"\n                  @click.native.prevent.stop=\"\"\n                  @change=\"isFromTimeField ? closeTimePicker('from', ...arguments, $event) : ''\">\n                  <template #input>\n                    <!-- need to disable because label is there - it is just in BaseInput\n                    component -->\n                    <!-- eslint-disable-next-line  vuejs-accessibility/form-control-has-label -->\n                    <input\n                      :id=\"label + '-' + id\"\n                      ref=\"inputFrom\"\n                      v-model=\"inputFrom\"\n                      :placeholder=\"placeholder.date || placeholder\"\n                      :type=\"'text'\"\n                      :aria-describedby=\"label + '-' + id\"\n                      :aria-required=\"required.toString()\"\n                      :aria-invalid=\"invalid.toString()\"\n                      :required=\"required\"\n                      :disabled=\"disabled\"\n                      :aria-disabled=\"disabled\"\n                      :class=\"['base-date-input__input', inputClass]\"\n                      autocomplete=\"off\"\n                      @blur=\"checkDateValidity('From')\"\n                      @input=\"checkDate($event, 'From')\"\n                      @keydown=\"handleInputKeydown($event, 'From')\"\n                      v-on=\"dateInputListeners\">\n                  </template>\n                  <!-- this empty element is here so that the default icon of datepicker\n                  is not used -->\n                  <template #icon-calendar>\n                    <div class=\"base-date-input__icon-wrapper\" />\n                  </template>\n                </DatePicker>\n              </div>\n            </template>\n            <template #post-input-field>\n              <BaseIcon\n                v-if=\"showIcons\"\n                ref=\"baseIcon\"\n                :name=\"isFromTimeField ? 'clock' : 'calendar-many'\"\n                class=\"base-date-input__date-icon\"\n                @click.stop=\"fromOpen = !fromOpen\" />\n            </template>\n          </BaseInput>\n\n          <span\n            v-if=\"type === 'daterange' || type === 'timerange'\"\n            class=\"base-date-input__separator\">{{ rangeSeparator }}</span>\n\n          <!-- INPUT TO -->\n          <BaseInput\n            v-if=\"type !== 'single'\"\n            :id=\"label + '-to-' + id\"\n            v-model=\"inputTo\"\n            :label=\"label\"\n            :show-label=\"false\"\n            :is-active=\"toOpen\"\n            :use-form-field-styling=\"useFormFieldStyling\"\n            :show-input-border=\"showInputBorder\"\n            :clearable=\"clearable\"\n            :required=\"required\"\n            :invalid=\"invalid\"\n            :disabled=\"disabled\"\n            :show-error-icon=\"showErrorIcon\"\n            :error-message=\"errorMessage\"\n            :set-focus-on-active=\"setFocusOnActive\"\n            :use-fade-out=\"useFadeOutTo\"\n            class=\"base-date-input__input-wrapper\"\n            @update:is-active=\"isActiveHandler('toOpen', $event)\"\n            v-on=\"inputListeners\">\n            <template #input>\n              <div\n                class=\"base-date-input__datepicker\">\n                <DatePicker\n                  v-model=\"inputTo\"\n                  :input-attr=\"{ id: label + '-' + id }\"\n                  :placeholder=\"isToTimeField ? placeholder.time : placeholder.date\"\n                  :clearable=\"false\"\n                  :append-to-body=\"false\"\n                  :lang=\"lang[language]\"\n                  :open=\"toOpen\"\n                  :type=\"isToTimeField ? 'time' : minDateView\"\n                  :format=\"isToTimeField ? 'HH:mm' : dateFormatDisplay\"\n                  :value-type=\"isToTimeField ? 'format' : datePickerValueFormat\"\n                  input-class=\"base-date-input__datepicker-input\"\n                  @pick=\"datePicked('to')\"\n                  @click.native.prevent.stop=\"\"\n                  @change=\"isToTimeField ? closeTimePicker('to', ...arguments, $event) : ''\">\n                  <template #input>\n                    <!-- need to disable because label is there - it is just in BaseInput\n                      component -->\n                    <!-- eslint-disable-next-line  vuejs-accessibility/form-control-has-label -->\n                    <input\n                      :id=\"label + '-to-' + id\"\n                      ref=\"inputTo\"\n                      v-model=\"inputTo\"\n                      :placeholder=\"placeholder.date || placeholder\"\n                      :type=\"'text'\"\n                      :aria-describedby=\"label + '-to-' + id\"\n                      :aria-required=\"required.toString()\"\n                      :aria-invalid=\"invalid.toString()\"\n                      :required=\"required\"\n                      :disabled=\"disabled\"\n                      :aria-disabled=\"disabled\"\n                      autocomplete=\"off\"\n                      :class=\"['base-date-input__input', inputClass]\"\n                      @blur=\"checkDateValidity('To')\"\n                      @input=\"checkDate($event, 'To')\"\n                      @keydown=\"handleInputKeydown($event, 'To')\"\n                      v-on=\"dateInputListeners\">\n                  </template>\n                  <!-- this empty element is here so that the default icon of\n                  datepicker is not used -->\n                  <template #icon-calendar>\n                    <div class=\"base-date-input__icon-wrapper\" />\n                  </template>\n                </DatePicker>\n              </div>\n            </template>\n            <template #post-input-field>\n              <BaseIcon\n                v-if=\"showIcons\"\n                :name=\"isToTimeField ? 'clock' : 'calendar-many'\"\n                class=\"base-date-input__date-icon\"\n                @click.stop=\"toOpen = !toOpen\" />\n            </template>\n          </BaseInput>\n        </div>\n      </div>\n      <!-- @slot for adding elements after input -->\n      <slot name=\"post-input-field\" />\n    </div>\n\n    <div class=\"base-date-input__below\">\n      <!-- @slot to add elements below input fields e.g. add drop down -->\n      <slot name=\"below-input\" />\n    </div>\n  </div>\n</template>\n\n<script>\nimport ClickOutside from 'vue-click-outside';\nimport DatePicker from 'vue2-datepicker';\nimport { debounce } from '@/utils/utils';\n\nimport en from 'vue2-datepicker/locale/en';\nimport de from 'vue2-datepicker/locale/de';\nimport fr from 'vue2-datepicker/locale/fr';\n\nimport BaseInput from '@/components/BaseInput/BaseInput';\nimport BaseIcon from '../BaseIcon/BaseIcon';\n\n/**\n * Form Input Field Component for Date, Date - Date, Date - Time, or Time - Time\n *\n * for date also a format switch between date | year is available\n *\n */\n\nexport default {\n  name: 'BaseDateInput',\n  components: {\n    BaseInput,\n    BaseIcon,\n    BaseSwitchButton: () => import('@/components/BaseSwitchButton/BaseSwitchButton').then(m => m.default || m),\n    DatePicker,\n  },\n  directives: {\n    ClickOutside,\n  },\n  model: {\n    prop: 'input',\n    event: 'selected',\n  },\n  props: {\n  /**\n   * select date or datetime or a range\n   */\n    type: {\n      type: String,\n      default: 'single',\n      validator(val) {\n        return ['daterange', 'datetime', 'single', 'timerange'].includes(val);\n      },\n    },\n    /**\n     * input field settable from outside.\n     *   attention: if this is an object it needs to contain all the\n     *   properties (e.g. date_from, time_to) already otherwise only\n     *   a string will be returned\n     */\n    input: {\n      type: [Object, String, Date],\n      required: true,\n    },\n    /** label for input field, required for usability purposes, handle\n     * showing of label with property showLabel\n     */\n    label: {\n      type: String,\n      required: true,\n    },\n    /**\n     * defines if input label should be visible\n     */\n    showLabel: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * set a placeholder for the input field (object with date and time attribute respectively)\n     */\n    placeholder: {\n      type: [Object, String],\n      default: () => ({ date: 'Select Date', time: 'Select Time' }),\n    },\n    /**\n     * define the range separator\n     */\n    rangeSeparator: {\n      type: String,\n      default: 'â€“',\n    },\n    /**\n     * specify date format.\n     *\n     *  **date_year**: display tabs that allow for toggle between only choosing year\n     *   or complete date\n     *  **date_month_year**: display tabs that allow for toggle between choosing only year,\n     *   year and month or complete date\n     */\n    format: {\n      type: String,\n      default: 'day',\n      validator(val) {\n        return ['day', 'month', 'year', 'date_year', 'date_month_year'].includes(val);\n      },\n    },\n    /**\n     * specify labels displayed instead of 'DD.MM.YYYY' and 'YYYY'\n     *   should have the form `{ date: 'xxx', month: 'zzz', year: 'yyy' }`\n     */\n    dateFormatLabels: {\n      type: Object,\n      default: () => ({ date: 'DD.MM.YYYY', month: 'MM.YYYY', year: 'YYYY' }),\n      validator(val) {\n        const labelKeys = Object.keys(val);\n        return labelKeys.includes('date') && labelKeys.includes('year');\n      },\n    },\n    /**\n     * a legend for the date format switch buttons\n     */\n    formatTabsLegend: {\n      type: String,\n      default: 'Switch between date formats',\n    },\n    /**\n     * set calendar language (ISO 639-1).\n     * **caveat**: currently only `en`, `de` and `fr` are supported\n     *  @values de, en, fr\n     */\n    language: {\n      type: String,\n      default: 'en',\n      validator: val => ['de', 'en', 'fr'].includes(val),\n    },\n    /**\n     * set id\n     */\n    id: {\n      type: [Number, String],\n      default: 1,\n    },\n    /**\n     * define if standard form field styling should be\n     * used (otherwise no border, no box shadow)\n     */\n    useFormFieldStyling: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * option to have the border of the input field not displayed\n     */\n    showInputBorder: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * mark as required field (currently only used for aria-required)\n     */\n    required: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * mark the form field as invalid and ideally also provide an error message\n     * to display below the form field\n     * for an example see [BaseInput](BaseInput)\n     */\n    invalid: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * set `true` if input field should be disabled\n     * for an example see [BaseInput](BaseInput)\n     */\n    disabled: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * add an error message to be displayed below form field if field is invalid\n     * for an example see [BaseInput](BaseInput)\n     */\n    errorMessage: {\n      type: String,\n      default: '',\n    },\n    /**\n     * define if error icon should be shown\n     * for an example see [BaseInput](BaseInput)\n     */\n    showErrorIcon: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * if `true` a remove icon will be shown allowing to remove\n     * all input at once\n     * for an example see [BaseInput](BaseInput)\n     */\n    clearable: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * specify additional input field styling\n     */\n    inputClass: {\n      type: String,\n      default: '',\n    },\n    /**\n     * use this prop to deactivate automatic setting of focus as soon as input element\n     * becomes active - this might require external handling of focus setting!\n     */\n    setFocusOnActive: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * in order to be able to set input field active state from outside\n     */\n    isActive: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * use this prop to set a delay in ms before calender is displayed\n     */\n    isActiveDelay: {\n      type: Number,\n      default: 0,\n    },\n  },\n  data() {\n    return {\n      /**\n       * internal input representation with all possible values for\n       * date and time\n       * @typedef {Object} inputInt\n       * @property {string} inputInt.date - attribute a single date or datetime date is stored in\n       * @property {string} inputInt.date_from - storing daterange from\n       * @property {string} inputInt.date_to - storing daterange to\n       * @property {string} inputInt.time - storing the time for datetime type\n       * @property {string} inputInt.time_from - storing timerange from\n       * @property {string} inputInt.time_to - storing timerange to\n       */\n      inputInt: {\n        date: '',\n        date_from: '',\n        date_to: '',\n        time: '',\n        time_from: '',\n        time_to: '',\n      },\n      /**\n       * variable for toggling format between date and year for date_year format\n       * @type {string}\n       */\n      dateFormatInt: '',\n      /**\n       * variable to store the date when switching from date to year in order to be\n       * able to restore exact date when switching back\n       * @type {inputInt}\n       */\n      tempDateStore: {},\n      /**\n       * to steer closing of datepicker from input field once date is selected\n       * @type {boolean}\n       */\n      fromOpen: false,\n      /**\n       * to steer closing of datepicker to input field once date is selected\n       * @type {boolean}\n       */\n      toOpen: false,\n      /**\n       * variable to keep active state in sync with potential parent prop\n       * (this is needed as independent variable from toOpen and fromOpen for example in\n       * BaseAdvancedSearchRow to keep dropdown open even if datepicker is closed)\n       */\n      isActiveInt: false,\n      /**\n       * variable to steer if input fade out of from field should be shown\n       * @type {boolean}\n       */\n      useFadeOutFrom: false,\n      /**\n       * variable to steer if input fade out of to field should be shown\n       * @type {boolean}\n       */\n      useFadeOutTo: false,\n      /**\n       * variable to steer if icons should be shown (becoming false if not enough\n       * space)\n       * @type {boolean}\n       */\n      showIcons: true,\n      /**\n       * variable to store icon size which is calculated in the beginning and might be\n       * hidden later\n       * @type {number}\n       */\n      iconSize: 24,\n      /**\n       * Resize Observer to trigger fade out calculations when component is resized\n       * @type {?ResizeObserver}\n       */\n      resizeObserver: null,\n      /**\n       * function needs to be triggered when date switch is populated\n       * @type {?ResizeObserver}\n       */\n      labelAdditionsObserver: null,\n      /**\n       * datepicker localisations\n       *   using object fixes problem of missing localisation files in rollup-esm-build\n       */\n      lang: {\n        de,\n        en,\n        fr,\n      },\n      /**\n       * variable to set css class according to label elements wrapping or not\n       * @type {boolean}\n       */\n      wrapLabelRow: false,\n    };\n  },\n  computed: {\n    /**\n     * this is the format we want to store computed based on what\n     * was specified in format and what date toggle tabs (via dateFormatInt) might say\n     * TODO: check if this is still needed with custom input\n     * @returns {string}\n     */\n    datePickerValueFormat() {\n      if (this.format === 'year' || this.dateFormatInt === 'YYYY') {\n        return 'YYYY';\n      }\n      if (this.format === 'month' || this.dateFormatInt === 'MM.YYYY') {\n        return 'YYYY-MM';\n      }\n      return 'YYYY-MM-DD';\n    },\n    /**\n     * compute the date format needed for the date picker (display!)\n     * TODO: check if this is still needed with custom input\n     * @returns {string}\n     */\n    dateFormatDisplay() {\n      return this.datePickerValueFormat.split('-').reverse().join('.');\n    },\n    /**\n     * if the format is settable this.format is date_year and can not be\n     * used directly for the date picker component\n     * @returns {string}\n     */\n    minDateView() {\n      if (this.isSwitchableFormat && this.dateFormatInt === 'YYYY') {\n        return 'year';\n      }\n      if (this.isSwitchableFormat && this.dateFormatInt === 'MM.YYYY') {\n        return 'month';\n      }\n      if (this.isSwitchableFormat && this.dateFormatInt === 'DD.MM.YYYY') {\n        return 'day';\n      }\n      return this.format;\n    },\n    /**\n     * compute the properties of the object provided in input prop\n     * @returns {string[]}\n     */\n    inputProperties() {\n      return Object.keys(this.input);\n    },\n    /**\n     * check if input is just a single date or an object\n     * @returns {boolean}\n     */\n    isSingleDate() {\n      return typeof this.input === 'string' || !this.inputProperties.length;\n    },\n    /**\n     * handle input for the 'from' input field\n     */\n    inputFrom: {\n      /**\n       * get back the appropriate inputInt attribute value\n       * @returns {string}\n       */\n      get() {\n        // if it is a time field just return the time_from value\n        if (this.isFromTimeField) {\n          return this.inputInt.time_from;\n        }\n        // else it is a date (either single or date_from) --> convert it into the\n        // correct format for display (DD.MM.YYYY instead of the saved DD-MM-YYY)\n        return this.dateDisplay(this.inputInt.date || this.inputInt.date_from);\n      },\n      /**\n       * also assign them again accordingly\n       * @param {string} val - the value provided by the input element\n       */\n      set(val) {\n        if (this.isFromTimeField) {\n          this.inputInt.time_from = val;\n        } else if (this.inputProperties.includes('date_from')) {\n          this.inputInt.date_from = this.dateStorage(val);\n        } else {\n          this.inputInt.date = this.dateStorage(val);\n        }\n      },\n    },\n    /**\n     * as above - if there is only a single time field get value from 'time' variable\n     * if it is a range use 'time_to''\n     */\n    inputTo: {\n      /**\n       * get back the appropriate inputInt attribute value\n       * @returns {string}\n       */\n      get() {\n        // check if a to time field exists\n        if (this.isToTimeField) {\n          // return the appropriate attribute value\n          return this.inputInt.time || this.inputInt.time_to;\n        }\n        // else return the date_to attribute value\n        return this.dateDisplay(this.inputInt.date_to);\n      },\n      /**\n       * also assign them again accordingly\n       * @param {string} val - the value provided by the input element\n       */\n      set(val) {\n        // check if field is date field\n        if (!this.isToTimeField) {\n          // if so, set date_to attribute value and transform value appropriately\n          // TODO: this could be insufficient since currently no validity checks on input string\n          this.inputInt.date_to = this.dateStorage(val);\n          // else check if type is timerange\n        } else if (this.inputProperties.includes('time_from')) {\n          this.inputInt.time_to = val;\n          // else assume the type is datetime\n        } else {\n          this.inputInt.time = val;\n        }\n      },\n    },\n    /**\n     * determine if the initially provided date is a year or a full date\n     * (used to set the correct date display format and date/year switch button)\n     * @returns {boolean}\n     */\n    isDateFormatYear() {\n      return ((this.isSingleDate && this.inputInt.date && this.inputInt.date.length <= 4)\n        || this.inputProperties.some(key => !!key.includes('date')\n          && this.inputInt[key] && this.inputInt[key].length <= 4));\n    },\n    isDateFormatMonth() {\n      return ((this.isSingleDate && this.inputInt.date\n          && this.inputInt.date.length > 4 && this.inputInt.date.length <= 7)\n        || this.inputProperties.some(key => !!key.includes('date')\n          && this.inputInt[key]\n          && this.inputInt[key].length > 4 && this.inputInt[key].length <= 7));\n    },\n    /**\n     * check if format switch tabs should be shown\n     * @returns {boolean}\n     */\n    isSwitchableFormat() {\n      return this.format === 'date_month_year' || this.format === 'date_year';\n    },\n    /**\n     * return the format options for date, month, year switches\n     * @returns {[{label: string, value: string}]}\n     */\n    tabSwitchOptions() {\n      // minimal options\n      const options = [\n        { label: this.dateFormatLabels.date, value: 'DD.MM.YYYY' },\n        { label: this.dateFormatLabels.year, value: 'YYYY' },\n      ];\n      // if format can be month as well, add month option\n      if (this.format === 'date_month_year') {\n        options.splice(1, 0, {\n          label: this.dateFormatLabels.month,\n          value: 'MM.YYYY',\n        });\n      }\n      return options;\n    },\n    /**\n     * determine if the from field is a time field\n     * @returns {boolean}\n     */\n    isFromTimeField() {\n      return this.type === 'timerange';\n    },\n    /**\n     * determine if the to field is a time field\n     * @returns {boolean}\n     */\n    isToTimeField() {\n      return this.type === 'datetime' || this.type === 'timerange';\n    },\n    /**\n     * compute an object that takes component $listeners and manipulate them for custom\n     * needs\n     * @returns {Object}\n     */\n    inputListeners() {\n      return {\n        // add all the listeners from the parent\n        ...this.$listeners,\n        // and add custom listeners\n        ...{\n          // stop these BaseInput originating events to substitute them with the\n          // correct events in search container element\n          'clicked-outside': (event) => {\n            event.stopPropagation();\n          },\n          // need to stop the event triggered in original BaseInput as well\n          // and replace it with the internal active state variable\n          'update:is-active': () => {\n            /**\n             * replace BaseInput state with BaseDateInput field active state and\n             * propagate this one\n             *\n             * @event update:is-active\n             * @param {boolean} - is input field active\n             */\n            this.$emit('update:is-active', this.isActiveInt);\n          },\n        },\n      };\n    },\n    /**\n     * compute an object that takes component $listeners and manipulate them for custom\n     * needs\n     * @returns {Object}\n     */\n    dateInputListeners() {\n      return {\n        // add all the listeners from the parent\n        ...this.$listeners,\n        // and add custom listeners\n        input: () => {\n          /**\n           * Event emitted on input, passing input string\n           *\n           * @event input\n           * @param {string} - the input event value however\n           * passing only the event.target.value\n           *\n           */\n          this.$emit('input', this.getInputData());\n        },\n      };\n    },\n    /**\n     * check if label-addition slot exists is filled\n     */\n    labelRowSlotsHaveData() {\n      // get label-addition slot\n      const slotElements = this.$slots['label-addition'];\n      // check if slot exists and has data and actually has content\n      // (this did not work with SSR otherwise...)\n      return !!slotElements && !!slotElements.length\n        && slotElements.some(elem => elem.tag || elem.text);\n    },\n    /**\n     * determines if label row should be shown\n     * @returns {Boolean|boolean}\n     */\n    showLabelRow() {\n      // show label when prop is set true or a label addition was added via slot\n      return this.showLabel || this.isSwitchableFormat || this.labelRowSlotsHaveData;\n    },\n  },\n  watch: {\n    /**\n     * watch format and set correct dateFormat\n     */\n    format: {\n      handler(val) {\n        if (val === 'year') {\n          this.dateFormatInt = 'YYYY';\n          return;\n        }\n        if (val === 'month') {\n          this.dateFormatInt = 'MM.YYYY';\n          return;\n        }\n        this.dateFormatInt = 'DD.MM.YYYY';\n      },\n      immediate: true,\n    },\n    /**\n     * watch input set from outside and set internal inputInt accordingly as well as\n     * set the correct display format\n     */\n    input: {\n      handler(val) {\n        // check if input string is different from inputInt\n        if (JSON.stringify(val) !== JSON.stringify(this.getInputData())) {\n          this.inputInt = this.isSingleDate ? { date: val } : { ...val };\n          // check if external input was year format and set internal format accordingly\n          if (this.isSwitchableFormat) {\n            if (this.isDateFormatYear) {\n              this.dateFormatInt = 'YYYY';\n            } else if (this.isDateFormatMonth) {\n              this.dateFormatInt = 'MM.YYYY';\n            } else {\n              this.dateFormatInt = 'DD.MM.YYYY';\n            }\n          }\n        }\n      },\n      // to not need to do extra assignment in created()\n      immediate: true,\n    },\n    /**\n     * if inputInt changes inform parent about it\n     */\n    inputInt: {\n      handler() {\n        // the actual value is not needed here since data were transformed and\n        // original object structure with correct data is retrieved with function getInputData\n        if (JSON.stringify(this.input) !== JSON.stringify(this.getInputData())) {\n          this.emitData();\n        }\n      },\n      deep: true,\n    },\n    /**\n     * in order to allow user to restore previous date after switching\n     * from date to year and back store in temp variable (but only if previous date was full date\n     * (check necessary for starting with year where format is switched to 'YYYY'\n     * but no previous full date avaliable))\n     * @param {string} val - the changed dateFormatInt value\n     * @param {string} old - the previous value\n     */\n    dateFormatInt(val, old) {\n      // in order to allow user to restore previous date after switching\n      // from date to year and back store in temp variable if\n      // a) date is not just format 'YYYY' & switch was made from full date\n      if (!this.isDateFormatYear && old === 'DD.MM.YYYY') {\n        this.tempDateStore = { ...this.inputInt };\n        // b) tab switch was made from month to year\n      } else if (!this.isDateFormatYear\n        && (val === 'YYYY' && old === 'MM.YYYY')) {\n        // if there is no previous stored date just store everything\n        if (!this.tempDateStore) {\n          this.tempDateStore = { ...this.inputInt };\n          // if there was a previous stored date check for every date prop in inputInt\n          // if stored date should be overwritten\n        } else {\n          Object.keys(this.inputInt).filter(key => !!key.includes('date'))\n            .forEach((dateKey) => {\n              // date should be overwritten if month or year are different from\n              // the already stored date\n              if (!this.monthAndYearIdent(\n                this.inputInt[dateKey],\n                this.tempDateStore[dateKey],\n              )) {\n                this.$set(this.tempDateStore, dateKey, this.inputInt[dateKey]);\n              }\n            });\n        }\n      }\n      this.convertDate();\n    },\n    /**\n     * when input becomes inactive always also blur input field just in case\n     * @param {boolean} val - the changed fromOpen value\n     */\n    fromOpen(val) {\n      if (!val) {\n        this.$refs.inputFrom.blur();\n      } else {\n        this.toOpen = false;\n      }\n    },\n    /**\n     * when input becomes inactive always also blur input field just in case\n     * @param {boolean} val - the changed toOpen value\n     */\n    toOpen(val) {\n      if (!val && this.$refs.inputTo) {\n        this.$refs.inputTo.blur();\n      } else if (val) {\n        this.fromOpen = false;\n      }\n    },\n    /**\n     * watch for changes in input field active variable to keep in sync with parent\n     * @param {boolean} val - the changed internal is active variable\n     */\n    isActiveInt(val) {\n      if (val !== this.isActive) {\n        this.$emit('update:is-active', val);\n      }\n    },\n    /**\n     * also adjust internal variable when active state changes from outside\n     * @param {boolean} val - the changed isActive prop\n     */\n    isActive: {\n      handler(val) {\n        if (val !== this.isActiveInt) {\n          this.isActiveInt = val;\n        }\n        // if isActive is set false from outside also close date picker\n        if (!val) {\n          this.fromOpen = false;\n          this.toOpen = false;\n        }\n      },\n      immediate: true,\n    },\n  },\n  mounted() {\n    if (this.$refs.baseIcon) {\n      this.iconWidth = this.$refs.baseIcon.$el.clientWidth;\n    }\n    // initialize the resize observer to calculate fade out and label row when component is resized\n    this.initObservers();\n  },\n  updated() {\n    // this hack is necessary because otherwise keyboard navigation was impaired by the datepicker\n    // pop up elements\n    // check if datepicker element is actually open\n    if (this.fromOpen || this.toOpen) {\n      // wait until elements are rendered\n      this.$nextTick(() => {\n        // get all focusable elements that have the 'mx-' in the class name\n        // had to add 'div's as well because of some strange effect in Firefox\n        const keyboardfocusableElements = [...this.$el.querySelectorAll(\n          'div, a, button, input, textarea, select, details, [tabindex]:not([tabindex=\"-1\"])',\n        )]\n          .filter(el => !el.hasAttribute('disabled'))\n          .filter(el => el.className.includes('mx-'));\n        // iterate through the elements and add tabindex -1\n        keyboardfocusableElements.forEach((element) => {\n          element.setAttribute('tabindex', -1);\n        });\n      });\n    }\n  },\n  beforeDestroy() {\n    if (this.resizeObserver) this.resizeObserver.disconnect();\n    if (this.labelAdditionsObserver) this.labelAdditionsObserver.disconnect();\n  },\n  methods: {\n    initObservers() {\n      // create an observer with the fade out calc function\n      const tempResizeObserver = new ResizeObserver(debounce(50, () => {\n        if (this.showLabel && (this.isSwitchableFormat || this.labelRowSlotsHaveData)) {\n          this.calcLabelAdditionsWidth();\n        }\n        this.calcFadeOut(['From', 'To']);\n      }));\n      // put it on the relevant element\n      tempResizeObserver.observe(this.$refs.baseDateInput);\n      // store it in variable\n      this.resizeObserver = tempResizeObserver;\n\n      if (this.showLabel && (this.isSwitchableFormat || this.labelRowSlotsHaveData)) {\n        // second observer to trigger label additions width calc as soon as element is rendered\n        const tempLabelAdditionsObserver = new ResizeObserver(debounce(50, (entries, observer) => {\n          // only do calc when element is filled\n          if (entries[0].contentRect.width > 0) {\n            this.calcLabelAdditionsWidth(this.$refs.baseDateInput.clientWidth);\n            // only do this once as soon as elements are rendered - then disconnect!\n            observer.disconnect();\n          }\n        }));\n        tempLabelAdditionsObserver.observe(this.$refs.labelAdditions);\n        this.labelAdditionsObserver = tempLabelAdditionsObserver;\n      }\n    },\n    /**\n     * transform the date to the correct display format\n     * @param {string} dateString - the date string in YYYY-MM-DD format\n     */\n    dateDisplay(dateString) {\n      return dateString ? dateString.split('-').reverse().join('.') : '';\n    },\n    /**\n     * transform the date to the correct storage format\n     * @param {string} dateString - the date string in DD.MM.YYYY format\n     */\n    dateStorage(dateString) {\n      return dateString ? dateString.split('.').reverse().join('-') : '';\n    },\n    /**\n     * checks done on keydown events\n     * a) tab key needs separate handling and only needs to set input field close when\n     * there is no clearable button (or shift key was used for going to previous field)\n     * b) prevent user from entering chars other than number or period (date) or colon (time)\n     * and not more characters than the date format requires\n     * @param {KeyboardEvent} event - the keydown event\n     * @param {string} origin - is event coming from 'from' or 'to' field in title case\n     */\n    handleInputKeydown(event, origin) {\n      let currentInputString = this[`input${origin}`];\n      // get the key triggering the event\n      const { key } = event;\n      // now check for the specific input key to preventDefault and prevent unwanted\n      // characters\n      // create boolean to determine if it is a time field (otherwise date is assumed)\n      const isTimeField = this.type === 'timerange' || (this.type === 'datetime' && origin === 'to');\n      // if time ':' is allowed in input regex - otherwise '.'\n      const allowedFieldKey = isTimeField ? ':' : '\\\\.';\n      // create regex for allowed keys\n      const allowedKeysRegex = new RegExp(`([0-9]|${allowedFieldKey}|Backspace|Delete|Tab|Enter|ArrowRight|ArrowLeft)`);\n      // create regex that should not be allowed if max length is reached\n      const disallowedKeysOnLengthRegex = new RegExp(`([0-9]|${allowedFieldKey})`);\n      // get the max length for the respective format (for time: 'HH:mm' = 5)\n      const formatLength = isTimeField ? 5 : this.dateFormatInt.length;\n      // check if\n      // * key was not any of the allowed keys\n      // * or was an allowed key but the length is to long for the format in\n      //    question (and no text was selected = will be replaced)\n      // * if type is date and key was period and date format is year or last char in string was\n      //    already a period\n      // * if type is time and key was colon and last char was already a colon\n      if (!allowedKeysRegex.test(key)\n        || (disallowedKeysOnLengthRegex.test(key) && this[`input${origin}`].length >= formatLength\n          && document.activeElement.selectionEnd - document.activeElement.selectionStart === 0)\n        || (!isTimeField && key === '.' && (this.dateFormatInt === 'YYYY'\n          || currentInputString.charAt(currentInputString.length - 1) === '.'))\n        || (isTimeField && key === ':' && currentInputString.charAt(currentInputString.length - 1) === ':')) {\n        event.preventDefault();\n      }\n      // when the user tries to leave the field check if input string is valid\n      if (key === 'Enter' && currentInputString) {\n        this.checkDateValidity(origin);\n        currentInputString = this[`input${origin}`];\n      }\n      // check if key was tab because of reasons specified above and close picker if necessary\n      if (key === 'Enter' || (key === 'Tab' && (event.shiftKey || !this.clearable\n        || !currentInputString))) {\n        // if yes set the relevant input field open status to false\n        this[`${origin.charAt(0).toLowerCase()}${origin.slice(1)}Open`] = false;\n      }\n    },\n    /**\n     * this function is triggered with the input event - it checks the length of the value and\n     * adds the '.' (date) or (':') or '0' in the correct places if necessary\n     * @param {InputEvent} event - the input event\n     * @param {string} origin - is event coming from 'from' or 'to' field in title case\n     */\n    checkDate(event, origin) {\n      // get the value in question\n      const value = this[`input${origin}`];\n      const isTimeField = this.type === 'timerange' || (this.type === 'datetime' && origin.toLowerCase() === 'to');\n      const charToAdd = isTimeField ? ':' : '.';\n      // check if value is present and if input type is other than 'deleteContentBackward' because\n      // otherwise the dots can not be deleted anymore\n      if (value && event.inputType !== 'deleteContentBackward') {\n        // now check the date format and if input so far matches the appropriate regex\n        if ((!isTimeField && this.dateFormatInt === 'DD.MM.YYYY' && /^(\\d{2}$|\\d{2}\\.\\d{2})$/.test(value))\n            || ((this.dateFormatInt === 'MM.YYYY' || isTimeField) && /^\\d{2}$/.test(value))) {\n          // if so - add a period character\n          this[`input${origin}`] = `${value}${charToAdd}`;\n        }\n        const firstTwoDigitsRegex = new RegExp(`^[1-9]${isTimeField ? ':' : '\\\\.'}$`);\n        // check if input was a period - if yes - check date validity and add zeros if necessary\n        if (firstTwoDigitsRegex.test(value)) {\n          this[`input${origin}`] = `0${this[`input${origin}`]}`;\n        } else if (/^\\d{2}\\.\\d\\.$/.test(value)) {\n          const [day, month, year] = value.split('.');\n          this[`input${origin}`] = `${day}.0${month}.${year}`;\n        }\n      }\n    },\n    /**\n     * this function is triggered with the blur event on the input and does a last check on the\n     * validity of the value\n     * @param {string} origin - is event coming from 'from' or 'to' field in title case\n     */\n    checkDateValidity(origin) {\n      // get the value in question\n      let value = this[`input${origin}`];\n      // check if there is a value present\n      if (value) {\n        // important and mostly different checks to make depending if value is date or time\n        // so save that in variable\n        const isTimeField = this.type === 'timerange' || (this.type === 'datetime' && origin.toLowerCase() === 'to');\n        // also save the current format length\n        const formatLength = isTimeField ? 5 : this.dateFormatInt.length;\n        // get the separator depending on time or date field\n        const separator = isTimeField ? ':' : '.';\n        // get the array length of array with string split up by separator (should be same for\n        // format and value string)\n        const numberFormatParts = isTimeField ? 2 : this.dateFormatInt.split('.').length;\n        // first check if periods (date) or colons (time) are too many\n        if (value.split(separator).length > numberFormatParts) {\n          // just remove all the periods or colons - there the next check will add some again\n          this[`input${origin}`] = value.replaceAll('.', '');\n          value = this[`input${origin}`];\n        }\n        // check if there are too little separators\n        if (numberFormatParts > value.split(separator).length) {\n          // check if day and month (for DDMMYYYY) or month and year (for MMYYYY) or time\n          // are without period or colon respectively\n          if (formatLength !== 4 && /^\\d{3}/.test(value)) {\n            // this assumes the first two digits are for day or month respectively!\n            // TODO: not ideal that 2 digits are assumed - see if this can be improved\n            this[`input${origin}`] = `${value.slice(0, 2)}${separator}${value.slice(2, value.length)}`;\n            value = this[`input${origin}`];\n          }\n          // check if there is a second period between month and year (for DDMMYYYY)\n          if (this.dateFormatInt === 'DD.MM.YYYY' && formatLength !== 4 && /^\\d{2}\\.\\d{3}/.test(value)) {\n            // this assumes there are two digits for day and month respectively!\n            // TODO: not ideal that 2 digits are assumed - see if this can be improved\n            this[`input${origin}`] = `${value.slice(0, 5)}.${value.slice(5, value.length)}`;\n            value = this[`input${origin}`];\n          }\n        }\n        // second check if the length of the value is correct\n        if (value.length !== formatLength) {\n          // distinguish between date and time string\n          if (isTimeField) {\n            // check if minutes are missing\n            if (/^\\d{1,2}:?$/.test(value)) {\n              const [hours] = value.split(':');\n              this[`input${origin}`] = `${hours}:00`;\n              value = this[`input${origin}`];\n            }\n            // check if zeros out front are missing from hour\n            if (/^\\d:\\d{1,2}$/.test(value)) {\n              const [hours, minutes] = value.split(':');\n              this[`input${origin}`] = `0${hours}:${minutes}`;\n              value = this[`input${origin}`];\n            }\n            // check if zeros out front are missing from minute\n            if (/^\\d{2}:\\d$/.test(value)) {\n              const [hours, minutes] = value.split(':');\n              this[`input${origin}`] = `${hours}:0${minutes}`;\n              value = this[`input${origin}`];\n            }\n          } else {\n            // first check reason for length mismatch is year having only two digits or is\n            // completely missing for date format\n            if (this.dateFormatInt === 'DD.MM.YYYY' && /^\\d{1,2}\\.\\d{1,2}\\.?(\\d{0}|\\d{2})$/.test(value)) {\n              // determine current year\n              const currentYear = new Date().getFullYear();\n              const [day, month, year] = value.split('.');\n              // repair date and add first two year digits - if date more than 10 years to the\n              // future - make it 20. century\n              const century = (currentYear).toString().slice(0, 2);\n              this[`input${origin}`] = `${day}.${month}.${year > (currentYear + 10).toString().slice(2, 4)\n                ? Number(century - 1) : century}${year || currentYear.toString().slice(2, 4)}`;\n              value = this[`input${origin}`];\n            }\n            // for month format\n            if (this.dateFormatInt === 'MM.YYYY' && /^\\d{1,2}\\.?(\\d{0}|\\d{2})$/.test(value)) {\n              // determine current year\n              const currentYear = new Date().getFullYear();\n              const [month, year] = value.split('.');\n              // repair date and add first two year digits - if date more than 10 years to the\n              // future - make it current century - otherwise last century\n              const century = (currentYear).toString().slice(0, 2);\n              this[`input${origin}`] = `${month}.${year > (currentYear + 10).toString().slice(2, 4)\n                ? Number(century - 1) : century}${year || currentYear.toString().slice(2, 4)}`;\n              value = this[`input${origin}`];\n            }\n            // second check if the reason for the length not matching is that the day is\n            // missing a zero\n            if (this.dateFormatInt === 'DD.MM.YYYY' && /^[1-9]\\.\\d{1,2}\\.\\d{4}$/.test(value)) {\n              // get the values\n              const [day, month, year] = value.split('.');\n              // repair date and add a zero to day\n              this[`input${origin}`] = `0${day}.${month}.${year}`;\n              value = this[`input${origin}`];\n            }\n            // second check if the reason for mismatching length is that the zero in month\n            // is missing\n            if (['DD.MM.YYYY', 'MM.YYYY'].includes(this.dateFormatInt) && /^\\d{2}?\\.?[1-9]\\.\\d{4}$/.test(value)) {\n              // get values, reverse in order to be able to get also correct values for format\n              // 'month'\n              const [year, month, day] = value.split('.').reverse();\n              // repair date and add missing zero to month\n              this[`input${origin}`] = `${day}.0${month}.${year}`;\n              value = this[`input${origin}`];\n            }\n          }\n          // now check if time/date has now the correct length - if not still remove the value\n          if (value.length !== formatLength) {\n            this[`input${origin}`] = '';\n          }\n        }\n        // now check for general validity\n        if (isTimeField) {\n          // just add random date to see if time is valid\n          if (Number.isNaN(Date.parse(`12.12.1212T${value}`))) {\n            let [hours, minutes] = value.split(':');\n            // check if valid hours\n            if (!/^([0-1][0-9]|2[0-4])$/.test(hours)) {\n              hours = '00';\n            }\n            // check if valid minutes\n            if (!/^[0-5][0-9]$/.test(minutes)) {\n              minutes = '00';\n            }\n            // construct a new time\n            const newTime = `${hours}:${minutes}`;\n            // now check again if time is valid now if yes assign, if no delete the string\n            this[`input${origin}`] = Number.isNaN(Date.parse(`12.12.1212T${newTime}`)) ? newTime : '';\n            value = this[`input${origin}`];\n          }\n        } else {\n          // now truly check if date is a valid date\n          if (Number.isNaN(Date.parse(this.dateStorage(value)))) {\n            // TODO: check if date has appropriate number of periods\n            const [year, month, day] = value.split('.').reverse();\n            if (this.dateFormatInt === 'DD.MM.YYYY') {\n              // TODO: could this check already be done on input???\n              // check if something is wrong with the day\n              if (!/^(0[1-9]|[1-2][0-9]|3[0-1])/.test(day)) {\n                // replace day with appropriate value\n                this[`input${origin}`] = `01.${month}.${year}`;\n              }\n            } if (this.dateFormatInt !== 'YYYY') {\n              // check if something is wrong with the month\n              if (!/^(0[1-9]|1[0-2])/.test(month)) {\n                // replace month with appropriate value\n                this[`input${origin}`] = `${day ? `${day}.` : ''}01.${year}`;\n              }\n            }\n          }\n          // since technically invalid dates (like 30.02.2000) will also be considered a\n          // vaild date by Date.parse() just convert to Date and back one more time\n          // new Date(input) will always convert to the actual day in the next month\n          // e.g. 31.06. --> 01.07. ; 30.02. --> 02.03.\n          const tempDate = this.getDateString(this.convertToDate(this.dateStorage(this[`input${origin}`])));\n          if (!Number.isNaN(Date.parse(this.dateStorage(tempDate)))) {\n            this[`input${origin}`] = this.getDateString(this.convertToDate(this.dateStorage(this[`input${origin}`])));\n          } else {\n            this[`input${origin}`] = '';\n          }\n        }\n        // after everything also still check if the new date/time string needs a fade out\n        this.calcFadeOut([origin]);\n      }\n      const data = this.getInputData();\n      /**\n       * this event is emitted when the value was validated in case input should just be considered\n       * after date validation\n       *\n       * @event value-validated\n       * @param {string, Object} - the validated string or input object\n       */\n      this.$emit('value-validated', data);\n    },\n    /**\n     * a function to have the time picker close automatically as soon as minutes\n     * are selected\n     * @param {string} origin - is it from the 'from' or 'to' part of the picker\n     * @param {any} time - the selected time (not needed here but passed by event)\n     * @param {string} type - was 'hour' or 'minute' selected\n     */\n    closeTimePicker(origin, time, type) {\n      if (type === 'minute') {\n        this[`${origin}Open`] = false;\n        // check if the new date/time string needs a fade out\n        this.calcFadeOut([`${origin.charAt(0).toUpperCase()}${origin.slice(1)}`]);\n      }\n    },\n    /**\n     * function triggered on datepicker 'pick' event, handling date picker closing\n     * and date validation\n     * @param origin\n     * @param isTimeField\n     */\n    datePicked(origin, isTimeField) {\n      if (!isTimeField) {\n        this[`${origin}Open`] = false;\n      }\n      // need this here because on blur() date is not updated\n      this.checkDateValidity(origin);\n    },\n    /**\n     * handle click outside event and adjust input active variable accordingly\n     * @param {MouseEvent} event - the event provided by the click outside directive\n     */\n    clickedOutside(event) {\n      this.isActiveInt = false;\n      /**\n       * emit a custom clicked-outside event instead of BaseInput event (propagation stopped)\n       *\n       * @event clicked-outside\n       * @param {MouseEvent} - the native Event\n       */\n      this.$emit('clicked-outside', event);\n    },\n    /**\n     * handle click inside the component and adjust input active variable accordingly\n     * @param {MouseEvent} event - event triggered by mouse click\n     */\n    clickedInside(event) {\n      this.isActiveInt = true;\n      /**\n       * event additionally triggered to BaseInput default click-input-field to also\n       * set field active if component sourroundings are clicked\n       *\n       * @event click-input-field\n       * @param {MouseEvent} - the native Event\n       */\n      this.$emit('click-input-field', event);\n    },\n    /**\n     * data emit function, transforming data before emit event\n     */\n    emitData() {\n      // get a data object that only contains fields that were also present\n      // in external input\n      const data = this.getInputData();\n      /**\n       * emit an event when focus leaves the input\n       *\n       * @event selected\n       * @param {string, Object} - the input string or object\n       */\n      this.$emit('selected', data);\n    },\n    /**\n     * convert function triggered on format tab switch\n     */\n    convertDate() {\n      Object.keys(this.inputInt).filter(key => !!key.includes('date'))\n        .forEach((dateKey) => {\n          const dateToConvert = this.inputInt[dateKey];\n          if (dateToConvert) {\n            if (this.minDateView === 'year') {\n              // convert date string to real date in order to get year and convert back to string\n              this.$set(this.inputInt, dateKey, this.convertToDate(dateToConvert)\n                .getFullYear().toString());\n            } else if (this.minDateView === 'month') {\n              const newDate = !!this.tempDateStore\n                // get stored date if\n                // a) previous date was full date and month and year\n                // are identical with stored year and month\n                && ((!this.isDateFormatYear\n                && this.monthAndYearIdent(this.tempDateStore[dateKey], dateToConvert))\n                // b) previous date was year and it is identical with stored year\n                || (new Date(this.tempDateStore[dateKey])\n                  .getFullYear().toString() === dateToConvert))\n                // else use current input date\n                ? this.tempDateStore[dateKey] : dateToConvert;\n              this.$set(\n                this.inputInt,\n                dateKey,\n                this.getDateString(this.convertToDate(newDate), true),\n              );\n            } else {\n              // check if a previous date was stored and year (coming from year)\n              const useStoredDate = !!this.tempDateStore && ((this.isDateFormatYear\n                && new Date(this.tempDateStore[dateKey]).getFullYear().toString() === dateToConvert)\n                // or month and year (coming from month) was changed or is still the same\n                || (this.isDateFormatMonth\n                && this.monthAndYearIdent(this.tempDateStore[dateKey], dateToConvert)));\n              // if a previous date was stored use this one else use the input date\n              const newDate = useStoredDate ? this.tempDateStore[dateKey] : dateToConvert;\n              // set the new date (converted to date and formatted\n              // in the correct format YYYY-MM-DD)\n              this.$set(\n                this.inputInt,\n                dateKey,\n                this.getDateString(this.convertToDate(newDate)),\n              );\n            }\n          }\n        });\n    },\n    /**\n     * if input was just a single string return that otherwise\n     * only return the properties provided by external input\n     * if input is empty set value to empty string instead of null (default vue2-datepicker)\n     * @returns {string | Object}\n     */\n    getInputData() {\n      if (this.isSingleDate) {\n        return this.inputInt.date !== null ? this.inputInt.date : '';\n      }\n      const data = {};\n      this.inputProperties.forEach(key => this.$set(data, key, this.inputInt[key] !== null ? this.inputInt[key] : ''));\n      return data;\n    },\n    /**\n     * convert a value to a date in local time at zero hours\n     *\n     * @param value: the date string stored in db (format YYYY-MM-DD)\n     * @returns {Date} - (e.g. Fri Jul 30 2021 00:00:00 GMT+0200 (Central European Summer Time))\n     */\n    convertToDate(value) {\n      return new Date(`${value}T00:00:00.000`);\n    },\n    /**\n     * a function to convert a date to a string in the format YYYY-MM-DD\n     *\n     * @param {Date} date in format\n     * @returns {string} - returns a string in format YYYY-MM-DD\n     */\n    getDateString(date) {\n      // there is always a year\n      let dateString = `${date.getFullYear().toString()}`;\n      // if date format is not 'year' only - add month\n      if (this.dateFormatInt !== 'YYYY') {\n        const month = (date.getMonth() + 1).toString();\n        dateString = `${dateString}-${month.length < 2 ? '0' : ''}${month}`;\n      }\n      // if date format is 'date' - add day\n      if (this.dateFormatInt === 'DD.MM.YYYY') {\n        const day = date.getDate().toString();\n        dateString = `${dateString}-${day.length < 2 ? '0' : ''}${day}`;\n      }\n      return dateString;\n    },\n    monthAndYearIdent(date1, date2) {\n      const convertedDate1 = this.convertToDate(date1);\n      const convertedDate2 = this.convertToDate(date2);\n      const monthDate1 = convertedDate1.getMonth();\n      const monthDate2 = convertedDate2.getMonth();\n      const yearDate1 = convertedDate1.getFullYear();\n      const yearDate2 = convertedDate2.getFullYear();\n      return monthDate1 === monthDate2 && yearDate1 === yearDate2;\n    },\n    /**\n     * function to calculate if fade out in the input fields should be shown, needs to be\n     * recalculated after resize or if input changes\n     */\n    calcFadeOut(inputFields) {\n      // now iterate through the relevant fields\n      inputFields.forEach((field) => {\n        // check if element exists\n        if (this.$refs[`input${field}`]) {\n          // now get the input field value\n          const inputValue = this.$refs[`input${field}`].value;\n          // for width (and fade out) calculation either use that or the placeholder visible\n          // in the field (this is saved in a separate variable from inputValue because for\n          // show icons only input value is relevant)\n          const text = inputValue || this.$refs[`input${field}`].getAttribute('placeholder');\n          // now check if any of the two exists\n          if (text) {\n            // create a span\n            const span = document.createElement('span');\n            // hide the span\n            span.setAttribute('class', 'hide');\n            // add the input extracted text to this span\n            span.innerHTML = text;\n            // add the element to the document body\n            document.body.appendChild(span);\n            // get the width of that element\n            const textWidth = span.offsetWidth;\n            // remove the element again\n            document.body.removeChild(span);\n            // now also get the input width\n            const inputWidth = this.$refs[`input${field}`].offsetWidth;\n            // check if the input value or placeholder width exceeds input width\n            if (textWidth > inputWidth) {\n              // if yes and there is input and icons are shown\n              if (inputValue && this.showIcons) {\n                // remove icons\n                this.showIcons = false;\n                // otherwise use fade out\n              } else {\n                this[`useFadeOut${field}`] = true;\n              }\n              // if input value or placeholder fit the input width\n            } else if (textWidth <= inputWidth) {\n              // check first if the fade out is used\n              if (this[`useFadeOut${field}`]) {\n                // if so - disable this one first\n                this[`useFadeOut${field}`] = false;\n                // else check if the icon would actually fit in the input together with the\n                // input width - if so - show icons\n              } else if (!this.showIcons && textWidth + this.iconWidth <= inputWidth) {\n                this.showIcons = true;\n              }\n            }\n          }\n        }\n      });\n    },\n    /**\n     * function to correctly style the date format switch buttons and prevent\n     * overlay with label\n     */\n    calcLabelAdditionsWidth() {\n      // get the complete element width\n      const observableWidth = this.$refs.baseDateInput.clientWidth;\n      // get the label margin\n      const labelMargin = this.showLabel\n        ? Number(getComputedStyle(this.$refs.label)['margin-right'].replace('px', '')) : 0;\n      const labelWidth = this.showLabel ? this.$refs.label.clientWidth : 0;\n      // calculate the remaining container space after label, label margin and date switch width\n      const spacingLeft = observableWidth\n        - labelWidth\n        - labelMargin\n        - this.$refs.labelAdditions.clientWidth;\n      // if no space is left set a class that sets label additions width to 100% so element has to wrap\n      this.wrapLabelRow = spacingLeft < 0;\n    },\n    /**\n     * add delay before value is set\n     *\n     * @param {String} key\n     * @param {boolean} value\n     */\n    isActiveHandler(key, value) {\n      // if false set value immediately\n      if (!value) {\n        this[key] = value;\n        return;\n      }\n\n      // otherwise add a delay\n      setTimeout(() => {\n        this[key] = value;\n      }, this.isActiveDelay);\n    },\n  },\n};\n</script>\n\n<style lang=\"scss\" scoped>\n  @import '../../styles/variables.scss';\n\n  .base-date-input {\n    display: flex;\n    flex-direction: column;\n    width: 100%;\n    position: relative;\n\n    .base-date-input__label-row {\n      display: flex;\n      flex-wrap: wrap;\n      width: 100%;\n      height: 100%;\n      justify-content: space-between;\n      align-items: center;\n\n      &.base-date-input__label-row--visible {\n        margin-bottom: $spacing-small-half;\n      }\n\n      .base-date-input__label {\n        color: $font-color-second;\n        margin-bottom: $spacing-small-half;\n        text-align: left;\n        align-self: flex-end;\n        margin-right: 50px;\n      }\n\n      .base-date-input__label-additions {\n        position: relative;\n        display: flex;\n        flex-wrap: wrap;\n        align-items: center;\n        justify-content: flex-end;\n        flex: 1 1 auto;\n        height: $line-height;\n\n        &.base-date-input__label-additions--switch-height {\n          height: calc(#{$line-height} + #{$spacing-small-half});\n\n          &.base-date-input__label-additions--wrap {\n            margin-top: 2px;\n          }\n        }\n\n        &.base-date-input__label-additions--wrap {\n          width: 100%;\n        }\n      }\n\n      .base-date-input__label-additions-inner {\n        position: absolute;\n        right: 0;\n        display: flex;\n        align-items: center;\n        margin-bottom: $spacing-small-half;\n\n        &.base-date-input__label-additions-inner--switch {\n          bottom: 0;\n          margin-bottom: calc(-#{$spacing-small-half} / 2);\n\n          @media screen and (max-width: $mobile) {\n            margin-bottom: calc(-#{$spacing-small} - 2px);\n          }\n        }\n        &.base-date-input__label-additions-inner--no-label-switch {\n          margin-bottom:  2px;\n\n          @media screen and (max-width: $mobile) {\n            margin-bottom: calc(-#{$spacing-small} + 1px);\n          }\n        }\n\n        .base-date-input__switch-buttons {\n          bottom: 0;\n          display: flex;\n          line-height: $line-height;\n        }\n      }\n    }\n\n    .base-date-input__field-wrapper {\n      display: flex;\n      align-items: baseline;\n      width: 100%;\n\n      .base-date-input__input-fields {\n        display: flex;\n        align-items: center;\n        flex: 1 1 auto;\n        flex-wrap: wrap;\n\n        .base-date-input__input-line {\n          display: flex;\n          flex: 1 1 auto;\n          align-items: center;\n\n          .base-date-input__input-wrapper {\n\n            & + .base-date-input__input-wrapper {\n              margin-left: $spacing;\n            }\n\n            .base-date-input__datepicker {\n              flex-grow: 1;\n              width: auto;\n              font-family: inherit;\n              font-size: inherit;\n              line-height: $row-height-small;\n\n              .base-date-input__input {\n                padding: $spacing-small-half 0;\n                min-height: $row-height-small;\n                width: 100%;\n              }\n            }\n\n            .base-date-input__icon-wrapper::before {\n              content: '';\n            }\n\n            .base-date-input__date-icon {\n              position: relative;\n              width: $icon-large;\n              height: $icon-large;\n              color: $font-color-second;\n              cursor: pointer;\n              flex-shrink: 0;\n              align-self: center;\n              margin-left: $spacing-small;\n            }\n          }\n\n          .base-date-input__separator {\n            padding: 0 $spacing;\n          }\n        }\n      }\n    }\n\n    .base-date-input__below {\n      position: relative;\n    }\n  }\n\n  @media screen and (max-width: $mobile) {\n    .base-date-input .base-date-input__label-row .base-date-input__label-additions {\n      align-items: center;\n    }\n  }\n</style>\n\n<style lang=\"scss\">\n  @import '../../styles/_datepicker.scss';\n</style>\n"],"names":["_sfc_main","BaseInput","BaseIcon","m","DatePicker","ClickOutside","val","labelKeys","de","en","fr","key","options","event","slotElements","elem","old","dateKey","el","element","tempResizeObserver","debounce","tempLabelAdditionsObserver","entries","observer","dateString","origin","currentInputString","isTimeField","allowedFieldKey","allowedKeysRegex","disallowedKeysOnLengthRegex","formatLength","value","charToAdd","day","month","year","separator","numberFormatParts","hours","minutes","currentYear","century","newTime","tempDate","data","time","type","dateToConvert","newDate","date","date1","date2","convertedDate1","convertedDate2","monthDate1","monthDate2","yearDate1","yearDate2","inputFields","field","inputValue","text","span","textWidth","inputWidth","observableWidth","labelMargin","labelWidth","spacingLeft"],"mappings":"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"}