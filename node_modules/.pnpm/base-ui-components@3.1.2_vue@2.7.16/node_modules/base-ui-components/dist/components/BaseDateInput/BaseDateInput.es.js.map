{"version":3,"file":"BaseDateInput.es.js","sources":["../../../src/components/BaseDateInput/BaseDateInput.vue"],"sourcesContent":["<template>\n  <div\n    ref=\"baseDateInput\"\n    class=\"base-date-input\">\n    <div\n      v-if=\"showLabelRow\"\n      :class=\"['base-date-input__label-row',\n               { 'base-date-input__label-row--visible': showLabel }]\">\n      <legend\n        v-if=\"showLabel\"\n        ref=\"label\"\n        class=\"base-date-input__label\"\n        @click.prevent=\"\">\n        {{ label }}\n      </legend>\n      <div\n        :class=\"['base-date-input__label-additions',\n                 {'base-date-input__label-additions--switch-height': isSwitchableFormat },\n                 {'base-date-input__label-additions--wrap': wrapLabelRow }]\">\n        <div\n          ref=\"labelAdditions\"\n          :class=\"['base-date-input__label-additions-inner',\n                   {'base-date-input__label-additions-inner--switch': isSwitchableFormat },\n                   {'base-date-input__label-additions-inner--no-label-switch': isSwitchableFormat\n                     && !showLabel }]\">\n          <!-- @slot to add additional elements to the label row -->\n          <slot name=\"label-addition\" />\n          <BaseSwitchButton\n            v-if=\"isSwitchableFormat\"\n            v-model=\"dateFormatInt\"\n            :options=\"tabSwitchOptions\"\n            :label=\"formatTabsLegend\"\n            :active-tab=\"dateFormatInt\"\n            class=\"base-date-input__switch-buttons\" />\n        </div>\n      </div>\n    </div>\n\n    <!-- FORM FIELDS -->\n    <!-- keydown event is counter productive to workflow here -->\n    <!-- eslint-disable-next-line vuejs-accessibility/click-events-have-key-events -->\n    <div\n      v-click-outside=\"clickedOutside\"\n      class=\"base-date-input__field-wrapper\"\n      @click=\"clickedInside\">\n      <!-- @slot to add elements within form field but before the input element line for an example see [BaseInput](BaseInput)-->\n      <slot name=\"pre-input-field\" />\n      <div class=\"base-date-input__input-fields\">\n        <!-- @slot add elements within input form field but before all other elements - this field wraps if necessary for an example see [BaseInput](BaseInput) -->\n        <slot name=\"input-field-addition-before\" />\n        <div class=\"base-date-input__input-line\">\n          <!-- @slot add elements directly in the input line (no wrapping) for an example see [BaseInput](BaseInput)-->\n          <slot name=\"input-field-inline-before\" />\n          <!-- INPUT FROM -->\n          <BaseInput\n            :id=\"label + '-' + id\"\n            v-model=\"inputFrom\"\n            :label=\"label\"\n            :show-label=\"false\"\n            :is-active=\"fromOpen\"\n            :use-form-field-styling=\"useFormFieldStyling\"\n            :show-input-border=\"showInputBorder\"\n            :clearable=\"clearable\"\n            :required=\"required\"\n            :invalid=\"invalid\"\n            :disabled=\"disabled\"\n            :show-error-icon=\"showErrorIcon\"\n            :error-message=\"errorMessage\"\n            :input-class=\"inputClass\"\n            :set-focus-on-active=\"setFocusOnActive\"\n            :use-fade-out=\"useFadeOutFrom\"\n            class=\"base-date-input__input-wrapper\"\n            @update:is-active=\"isActiveHandler('fromOpen', $event)\"\n            v-on=\"inputListeners\">\n            <template #input>\n              <div\n                class=\"base-date-input__datepicker\">\n                <DatePicker\n                  v-model=\"inputFrom\"\n                  :input-attr=\"{ id: label + '-' + id }\"\n                  :placeholder=\"isFromTimeField ? placeholder.time : placeholder.date\"\n                  :clearable=\"false\"\n                  :append-to-body=\"false\"\n                  :lang=\"lang[language]\"\n                  :open=\"fromOpen\"\n                  :type=\"isFromTimeField ? 'time' : minDateView\"\n                  :format=\"isFromTimeField ? 'HH:mm' : dateFormatDisplay\"\n                  :value-type=\"isFromTimeField ? 'format' : dateFormatInt\"\n                  input-class=\"base-date-input__datepicker-input\"\n                  @pick=\"datePicked('from')\"\n                  @click.native.prevent.stop=\"\"\n                  @change=\"isFromTimeField ? closeTimePicker('from', ...arguments, $event) : ''\">\n                  <template #input>\n                    <!-- need to disable because label is there - it is just in BaseInput\n                    component -->\n                    <!-- eslint-disable-next-line  vuejs-accessibility/form-control-has-label -->\n                    <input\n                      :id=\"label + '-' + id\"\n                      ref=\"inputFrom\"\n                      v-model=\"inputFrom\"\n                      :placeholder=\"placeholder.date || placeholder\"\n                      :type=\"'text'\"\n                      :aria-describedby=\"label + '-' + id\"\n                      :aria-required=\"required.toString()\"\n                      :aria-invalid=\"invalid.toString()\"\n                      :required=\"required\"\n                      :disabled=\"disabled\"\n                      :aria-disabled=\"disabled\"\n                      :class=\"['base-date-input__input', inputClass]\"\n                      autocomplete=\"off\"\n                      @blur=\"checkDateValidity('From')\"\n                      @input=\"checkDate($event, 'From')\"\n                      @keydown=\"handleInputKeydown($event, 'From')\"\n                      v-on=\"dateInputListeners\">\n                  </template>\n                  <!-- this empty element is here so that the default icon of datepicker\n                  is not used -->\n                  <template #icon-calendar>\n                    <div class=\"base-date-input__icon-wrapper\" />\n                  </template>\n                </DatePicker>\n              </div>\n            </template>\n            <template #post-input-field>\n              <BaseIcon\n                v-if=\"showIcons\"\n                ref=\"baseIcon\"\n                :name=\"isFromTimeField ? 'clock' : 'calendar-many'\"\n                class=\"base-date-input__date-icon\"\n                @click.stop=\"fromOpen = !fromOpen\" />\n            </template>\n          </BaseInput>\n\n          <span\n            v-if=\"type === 'daterange' || type === 'timerange'\"\n            class=\"base-date-input__separator\">{{ rangeSeparator }}</span>\n\n          <!-- INPUT TO -->\n          <BaseInput\n            v-if=\"type !== 'single'\"\n            :id=\"label + '-to-' + id\"\n            v-model=\"inputTo\"\n            :label=\"label\"\n            :show-label=\"false\"\n            :is-active=\"toOpen\"\n            :use-form-field-styling=\"useFormFieldStyling\"\n            :show-input-border=\"showInputBorder\"\n            :clearable=\"clearable\"\n            :required=\"required\"\n            :invalid=\"invalid\"\n            :disabled=\"disabled\"\n            :show-error-icon=\"showErrorIcon\"\n            :error-message=\"errorMessage\"\n            :set-focus-on-active=\"setFocusOnActive\"\n            :use-fade-out=\"useFadeOutTo\"\n            class=\"base-date-input__input-wrapper\"\n            @update:is-active=\"isActiveHandler('toOpen', $event)\"\n            v-on=\"inputListeners\">\n            <template #input>\n              <div\n                class=\"base-date-input__datepicker\">\n                <DatePicker\n                  v-model=\"inputTo\"\n                  :input-attr=\"{ id: label + '-' + id }\"\n                  :placeholder=\"isToTimeField ? placeholder.time : placeholder.date\"\n                  :clearable=\"false\"\n                  :append-to-body=\"false\"\n                  :lang=\"lang[language]\"\n                  :open=\"toOpen\"\n                  :type=\"isToTimeField ? 'time' : minDateView\"\n                  :format=\"isToTimeField ? 'HH:mm' : dateFormatDisplay\"\n                  :value-type=\"isToTimeField ? 'format' : datePickerValueFormat\"\n                  input-class=\"base-date-input__datepicker-input\"\n                  @pick=\"datePicked('to')\"\n                  @click.native.prevent.stop=\"\"\n                  @change=\"isToTimeField ? closeTimePicker('to', ...arguments, $event) : ''\">\n                  <template #input>\n                    <!-- need to disable because label is there - it is just in BaseInput\n                      component -->\n                    <!-- eslint-disable-next-line  vuejs-accessibility/form-control-has-label -->\n                    <input\n                      :id=\"label + '-to-' + id\"\n                      ref=\"inputTo\"\n                      v-model=\"inputTo\"\n                      :placeholder=\"placeholder.date || placeholder\"\n                      :type=\"'text'\"\n                      :aria-describedby=\"label + '-to-' + id\"\n                      :aria-required=\"required.toString()\"\n                      :aria-invalid=\"invalid.toString()\"\n                      :required=\"required\"\n                      :disabled=\"disabled\"\n                      :aria-disabled=\"disabled\"\n                      autocomplete=\"off\"\n                      :class=\"['base-date-input__input', inputClass]\"\n                      @blur=\"checkDateValidity('To')\"\n                      @input=\"checkDate($event, 'To')\"\n                      @keydown=\"handleInputKeydown($event, 'To')\"\n                      v-on=\"dateInputListeners\">\n                  </template>\n                  <!-- this empty element is here so that the default icon of\n                  datepicker is not used -->\n                  <template #icon-calendar>\n                    <div class=\"base-date-input__icon-wrapper\" />\n                  </template>\n                </DatePicker>\n              </div>\n            </template>\n            <template #post-input-field>\n              <BaseIcon\n                v-if=\"showIcons\"\n                :name=\"isToTimeField ? 'clock' : 'calendar-many'\"\n                class=\"base-date-input__date-icon\"\n                @click.stop=\"toOpen = !toOpen\" />\n            </template>\n          </BaseInput>\n        </div>\n      </div>\n      <!-- @slot for adding elements after input -->\n      <slot name=\"post-input-field\" />\n    </div>\n\n    <div class=\"base-date-input__below\">\n      <!-- @slot to add elements below input fields e.g. add drop down -->\n      <slot name=\"below-input\" />\n    </div>\n  </div>\n</template>\n\n<script>\nimport ClickOutside from 'vue-click-outside';\nimport DatePicker from 'vue2-datepicker';\nimport { debounce } from '@/utils/utils';\n\nimport en from 'vue2-datepicker/locale/en';\nimport de from 'vue2-datepicker/locale/de';\nimport fr from 'vue2-datepicker/locale/fr';\n\nimport BaseInput from '@/components/BaseInput/BaseInput';\nimport BaseIcon from '../BaseIcon/BaseIcon';\n\n/**\n * Form Input Field Component for Date, Date - Date, Date - Time, or Time - Time\n *\n * for date also a format switch between date | year is available\n *\n */\n\nexport default {\n  name: 'BaseDateInput',\n  components: {\n    BaseInput,\n    BaseIcon,\n    BaseSwitchButton: () => import('@/components/BaseSwitchButton/BaseSwitchButton').then(m => m.default || m),\n    DatePicker,\n  },\n  directives: {\n    ClickOutside,\n  },\n  model: {\n    prop: 'input',\n    event: 'selected',\n  },\n  props: {\n  /**\n   * select date or datetime or a range\n   */\n    type: {\n      type: String,\n      default: 'single',\n      validator(val) {\n        return ['daterange', 'datetime', 'single', 'timerange'].includes(val);\n      },\n    },\n    /**\n     * input field settable from outside.\n     *   attention: if this is an object it needs to contain all the\n     *   properties (e.g. date_from, time_to) already otherwise only\n     *   a string will be returned\n     */\n    input: {\n      type: [Object, String, Date],\n      required: true,\n    },\n    /** label for input field, required for usability purposes, handle\n     * showing of label with property showLabel\n     */\n    label: {\n      type: String,\n      required: true,\n    },\n    /**\n     * defines if input label should be visible\n     */\n    showLabel: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * set a placeholder for the input field (object with date and time attribute respectively)\n     */\n    placeholder: {\n      type: [Object, String],\n      default: () => ({ date: 'Select Date', time: 'Select Time' }),\n    },\n    /**\n     * define the range separator\n     */\n    rangeSeparator: {\n      type: String,\n      default: 'â€“',\n    },\n    /**\n     * specify date format.\n     *\n     *  **date_year**: display tabs that allow for toggle between only choosing year\n     *   or complete date\n     *  **date_month_year**: display tabs that allow for toggle between choosing only year,\n     *   year and month or complete date\n     */\n    format: {\n      type: String,\n      default: 'day',\n      validator(val) {\n        return ['day', 'month', 'year', 'date_year', 'date_month_year'].includes(val);\n      },\n    },\n    /**\n     * specify labels displayed instead of 'DD.MM.YYYY' and 'YYYY'\n     *   should have the form `{ date: 'xxx', month: 'zzz', year: 'yyy' }`\n     */\n    dateFormatLabels: {\n      type: Object,\n      default: () => ({ date: 'DD.MM.YYYY', month: 'MM.YYYY', year: 'YYYY' }),\n      validator(val) {\n        const labelKeys = Object.keys(val);\n        return labelKeys.includes('date') && labelKeys.includes('year');\n      },\n    },\n    /**\n     * a legend for the date format switch buttons\n     */\n    formatTabsLegend: {\n      type: String,\n      default: 'Switch between date formats',\n    },\n    /**\n     * set calendar language (ISO 639-1).\n     * **caveat**: currently only `en`, `de` and `fr` are supported\n     *  @values de, en, fr\n     */\n    language: {\n      type: String,\n      default: 'en',\n      validator: val => ['de', 'en', 'fr'].includes(val),\n    },\n    /**\n     * set id\n     */\n    id: {\n      type: [Number, String],\n      default: 1,\n    },\n    /**\n     * define if standard form field styling should be\n     * used (otherwise no border, no box shadow)\n     */\n    useFormFieldStyling: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * option to have the border of the input field not displayed\n     */\n    showInputBorder: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * mark as required field (currently only used for aria-required)\n     */\n    required: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * mark the form field as invalid and ideally also provide an error message\n     * to display below the form field\n     * for an example see [BaseInput](BaseInput)\n     */\n    invalid: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * set `true` if input field should be disabled\n     * for an example see [BaseInput](BaseInput)\n     */\n    disabled: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * add an error message to be displayed below form field if field is invalid\n     * for an example see [BaseInput](BaseInput)\n     */\n    errorMessage: {\n      type: String,\n      default: '',\n    },\n    /**\n     * define if error icon should be shown\n     * for an example see [BaseInput](BaseInput)\n     */\n    showErrorIcon: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * if `true` a remove icon will be shown allowing to remove\n     * all input at once\n     * for an example see [BaseInput](BaseInput)\n     */\n    clearable: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * specify additional input field styling\n     */\n    inputClass: {\n      type: String,\n      default: '',\n    },\n    /**\n     * use this prop to deactivate automatic setting of focus as soon as input element\n     * becomes active - this might require external handling of focus setting!\n     */\n    setFocusOnActive: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * in order to be able to set input field active state from outside\n     */\n    isActive: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * use this prop to set a delay in ms before calender is displayed\n     */\n    isActiveDelay: {\n      type: Number,\n      default: 0,\n    },\n  },\n  data() {\n    return {\n      /**\n       * internal input representation with all possible values for\n       * date and time\n       * @typedef {Object} inputInt\n       * @property {string} inputInt.date - attribute a single date or datetime date is stored in\n       * @property {string} inputInt.date_from - storing daterange from\n       * @property {string} inputInt.date_to - storing daterange to\n       * @property {string} inputInt.time - storing the time for datetime type\n       * @property {string} inputInt.time_from - storing timerange from\n       * @property {string} inputInt.time_to - storing timerange to\n       */\n      inputInt: {\n        date: '',\n        date_from: '',\n        date_to: '',\n        time: '',\n        time_from: '',\n        time_to: '',\n      },\n      /**\n       * variable for toggling format between date and year for date_year format\n       * @type {string}\n       */\n      dateFormatInt: '',\n      /**\n       * variable to store the date when switching from date to year in order to be\n       * able to restore exact date when switching back\n       * @type {inputInt}\n       */\n      tempDateStore: {},\n      /**\n       * to steer closing of datepicker from input field once date is selected\n       * @type {boolean}\n       */\n      fromOpen: false,\n      /**\n       * to steer closing of datepicker to input field once date is selected\n       * @type {boolean}\n       */\n      toOpen: false,\n      /**\n       * variable to keep active state in sync with potential parent prop\n       * (this is needed as independent variable from toOpen and fromOpen for example in\n       * BaseAdvancedSearchRow to keep dropdown open even if datepicker is closed)\n       */\n      isActiveInt: false,\n      /**\n       * variable to steer if input fade out of from field should be shown\n       * @type {boolean}\n       */\n      useFadeOutFrom: false,\n      /**\n       * variable to steer if input fade out of to field should be shown\n       * @type {boolean}\n       */\n      useFadeOutTo: false,\n      /**\n       * variable to steer if icons should be shown (becoming false if not enough\n       * space)\n       * @type {boolean}\n       */\n      showIcons: true,\n      /**\n       * variable to store icon size which is calculated in the beginning and might be\n       * hidden later\n       * @type {number}\n       */\n      iconSize: 24,\n      /**\n       * Resize Observer to trigger fade out calculations when component is resized\n       * @type {?ResizeObserver}\n       */\n      resizeObserver: null,\n      /**\n       * function needs to be triggered when date switch is populated\n       * @type {?ResizeObserver}\n       */\n      labelAdditionsObserver: null,\n      /**\n       * datepicker localisations\n       *   using object fixes problem of missing localisation files in rollup-esm-build\n       */\n      lang: {\n        de,\n        en,\n        fr,\n      },\n      /**\n       * variable to set css class according to label elements wrapping or not\n       * @type {boolean}\n       */\n      wrapLabelRow: false,\n    };\n  },\n  computed: {\n    /**\n     * this is the format we want to store computed based on what\n     * was specified in format and what date toggle tabs (via dateFormatInt) might say\n     * TODO: check if this is still needed with custom input\n     * @returns {string}\n     */\n    datePickerValueFormat() {\n      if (this.format === 'year' || this.dateFormatInt === 'YYYY') {\n        return 'YYYY';\n      }\n      if (this.format === 'month' || this.dateFormatInt === 'MM.YYYY') {\n        return 'YYYY-MM';\n      }\n      return 'YYYY-MM-DD';\n    },\n    /**\n     * compute the date format needed for the date picker (display!)\n     * TODO: check if this is still needed with custom input\n     * @returns {string}\n     */\n    dateFormatDisplay() {\n      return this.datePickerValueFormat.split('-').reverse().join('.');\n    },\n    /**\n     * if the format is settable this.format is date_year and can not be\n     * used directly for the date picker component\n     * @returns {string}\n     */\n    minDateView() {\n      if (this.isSwitchableFormat && this.dateFormatInt === 'YYYY') {\n        return 'year';\n      }\n      if (this.isSwitchableFormat && this.dateFormatInt === 'MM.YYYY') {\n        return 'month';\n      }\n      if (this.isSwitchableFormat && this.dateFormatInt === 'DD.MM.YYYY') {\n        return 'day';\n      }\n      return this.format;\n    },\n    /**\n     * compute the properties of the object provided in input prop\n     * @returns {string[]}\n     */\n    inputProperties() {\n      return Object.keys(this.input);\n    },\n    /**\n     * check if input is just a single date or an object\n     * @returns {boolean}\n     */\n    isSingleDate() {\n      return typeof this.input === 'string' || !this.inputProperties.length;\n    },\n    /**\n     * handle input for the 'from' input field\n     */\n    inputFrom: {\n      /**\n       * get back the appropriate inputInt attribute value\n       * @returns {string}\n       */\n      get() {\n        // if it is a time field just return the time_from value\n        if (this.isFromTimeField) {\n          return this.inputInt.time_from;\n        }\n        // else it is a date (either single or date_from) --> convert it into the\n        // correct format for display (DD.MM.YYYY instead of the saved DD-MM-YYY)\n        return this.dateDisplay(this.inputInt.date || this.inputInt.date_from);\n      },\n      /**\n       * also assign them again accordingly\n       * @param {string} val - the value provided by the input element\n       */\n      set(val) {\n        if (this.isFromTimeField) {\n          this.inputInt.time_from = val;\n        } else if (this.inputProperties.includes('date_from')) {\n          this.inputInt.date_from = this.dateStorage(val);\n        } else {\n          this.inputInt.date = this.dateStorage(val);\n        }\n      },\n    },\n    /**\n     * as above - if there is only a single time field get value from 'time' variable\n     * if it is a range use 'time_to''\n     */\n    inputTo: {\n      /**\n       * get back the appropriate inputInt attribute value\n       * @returns {string}\n       */\n      get() {\n        // check if a to time field exists\n        if (this.isToTimeField) {\n          // return the appropriate attribute value\n          return this.inputInt.time || this.inputInt.time_to;\n        }\n        // else return the date_to attribute value\n        return this.dateDisplay(this.inputInt.date_to);\n      },\n      /**\n       * also assign them again accordingly\n       * @param {string} val - the value provided by the input element\n       */\n      set(val) {\n        // check if field is date field\n        if (!this.isToTimeField) {\n          // if so, set date_to attribute value and transform value appropriately\n          // TODO: this could be insufficient since currently no validity checks on input string\n          this.inputInt.date_to = this.dateStorage(val);\n          // else check if type is timerange\n        } else if (this.inputProperties.includes('time_from')) {\n          this.inputInt.time_to = val;\n          // else assume the type is datetime\n        } else {\n          this.inputInt.time = val;\n        }\n      },\n    },\n    /**\n     * determine if the initially provided date is a year or a full date\n     * (used to set the correct date display format and date/year switch button)\n     * @returns {boolean}\n     */\n    isDateFormatYear() {\n      return ((this.isSingleDate && this.inputInt.date && this.inputInt.date.length <= 4)\n        || this.inputProperties.some(key => !!key.includes('date')\n          && this.inputInt[key] && this.inputInt[key].length <= 4));\n    },\n    isDateFormatMonth() {\n      return ((this.isSingleDate && this.inputInt.date\n          && this.inputInt.date.length > 4 && this.inputInt.date.length <= 7)\n        || this.inputProperties.some(key => !!key.includes('date')\n          && this.inputInt[key]\n          && this.inputInt[key].length > 4 && this.inputInt[key].length <= 7));\n    },\n    /**\n     * check if format switch tabs should be shown\n     * @returns {boolean}\n     */\n    isSwitchableFormat() {\n      return this.format === 'date_month_year' || this.format === 'date_year';\n    },\n    /**\n     * return the format options for date, month, year switches\n     * @returns {[{label: string, value: string}]}\n     */\n    tabSwitchOptions() {\n      // minimal options\n      const options = [\n        { label: this.dateFormatLabels.date, value: 'DD.MM.YYYY' },\n        { label: this.dateFormatLabels.year, value: 'YYYY' },\n      ];\n      // if format can be month as well, add month option\n      if (this.format === 'date_month_year') {\n        options.splice(1, 0, {\n          label: this.dateFormatLabels.month,\n          value: 'MM.YYYY',\n        });\n      }\n      return options;\n    },\n    /**\n     * determine if the from field is a time field\n     * @returns {boolean}\n     */\n    isFromTimeField() {\n      return this.type === 'timerange';\n    },\n    /**\n     * determine if the to field is a time field\n     * @returns {boolean}\n     */\n    isToTimeField() {\n      return this.type === 'datetime' || this.type === 'timerange';\n    },\n    /**\n     * compute an object that takes component $listeners and manipulate them for custom\n     * needs\n     * @returns {Object}\n     */\n    inputListeners() {\n      return {\n        // add all the listeners from the parent\n        ...this.$listeners,\n        // and add custom listeners\n        ...{\n          // stop these BaseInput originating events to substitute them with the\n          // correct events in search container element\n          'clicked-outside': (event) => {\n            event.stopPropagation();\n          },\n          // need to stop the event triggered in original BaseInput as well\n          // and replace it with the internal active state variable\n          'update:is-active': () => {\n            /**\n             * replace BaseInput state with BaseDateInput field active state and\n             * propagate this one\n             *\n             * @event update:is-active\n             * @param {boolean} - is input field active\n             */\n            this.$emit('update:is-active', this.isActiveInt);\n          },\n        },\n      };\n    },\n    /**\n     * compute an object that takes component $listeners and manipulate them for custom\n     * needs\n     * @returns {Object}\n     */\n    dateInputListeners() {\n      return {\n        // add all the listeners from the parent\n        ...this.$listeners,\n        // and add custom listeners\n        input: () => {\n          /**\n           * Event emitted on input, passing input string\n           *\n           * @event input\n           * @param {string} - the input event value however\n           * passing only the event.target.value\n           *\n           */\n          this.$emit('input', this.getInputData());\n        },\n      };\n    },\n    /**\n     * check if label-addition slot exists is filled\n     */\n    labelRowSlotsHaveData() {\n      // get label-addition slot\n      const slotElements = this.$slots['label-addition'];\n      // check if slot exists and has data and actually has content\n      // (this did not work with SSR otherwise...)\n      return !!slotElements && !!slotElements.length\n        && slotElements.some(elem => elem.tag || elem.text);\n    },\n    /**\n     * determines if label row should be shown\n     * @returns {Boolean|boolean}\n     */\n    showLabelRow() {\n      // show label when prop is set true or a label addition was added via slot\n      return this.showLabel || this.isSwitchableFormat || this.labelRowSlotsHaveData;\n    },\n  },\n  watch: {\n    /**\n     * watch format and set correct dateFormat\n     */\n    format: {\n      handler(val) {\n        if (val === 'year') {\n          this.dateFormatInt = 'YYYY';\n          return;\n        }\n        if (val === 'month') {\n          this.dateFormatInt = 'MM.YYYY';\n          return;\n        }\n        this.dateFormatInt = 'DD.MM.YYYY';\n      },\n      immediate: true,\n    },\n    /**\n     * watch input set from outside and set internal inputInt accordingly as well as\n     * set the correct display format\n     */\n    input: {\n      handler(val) {\n        // check if input string is different from inputInt\n        if (JSON.stringify(val) !== JSON.stringify(this.getInputData())) {\n          this.inputInt = this.isSingleDate ? { date: val } : { ...val };\n          // check if external input was year format and set internal format accordingly\n          if (this.isSwitchableFormat) {\n            if (this.isDateFormatYear) {\n              this.dateFormatInt = 'YYYY';\n            } else if (this.isDateFormatMonth) {\n              this.dateFormatInt = 'MM.YYYY';\n            } else {\n              this.dateFormatInt = 'DD.MM.YYYY';\n            }\n          }\n        }\n      },\n      // to not need to do extra assignment in created()\n      immediate: true,\n    },\n    /**\n     * if inputInt changes inform parent about it\n     */\n    inputInt: {\n      handler() {\n        // the actual value is not needed here since data were transformed and\n        // original object structure with correct data is retrieved with function getInputData\n        if (JSON.stringify(this.input) !== JSON.stringify(this.getInputData())) {\n          this.emitData();\n        }\n      },\n      deep: true,\n    },\n    /**\n     * in order to allow user to restore previous date after switching\n     * from date to year and back store in temp variable (but only if previous date was full date\n     * (check necessary for starting with year where format is switched to 'YYYY'\n     * but no previous full date avaliable))\n     * @param {string} val - the changed dateFormatInt value\n     * @param {string} old - the previous value\n     */\n    dateFormatInt(val, old) {\n      // in order to allow user to restore previous date after switching\n      // from date to year and back store in temp variable if\n      // a) date is not just format 'YYYY' & switch was made from full date\n      if (!this.isDateFormatYear && old === 'DD.MM.YYYY') {\n        this.tempDateStore = { ...this.inputInt };\n        // b) tab switch was made from month to year\n      } else if (!this.isDateFormatYear\n        && (val === 'YYYY' && old === 'MM.YYYY')) {\n        // if there is no previous stored date just store everything\n        if (!this.tempDateStore) {\n          this.tempDateStore = { ...this.inputInt };\n          // if there was a previous stored date check for every date prop in inputInt\n          // if stored date should be overwritten\n        } else {\n          Object.keys(this.inputInt).filter(key => !!key.includes('date'))\n            .forEach((dateKey) => {\n              // date should be overwritten if month or year are different from\n              // the already stored date\n              if (!this.monthAndYearIdent(\n                this.inputInt[dateKey],\n                this.tempDateStore[dateKey],\n              )) {\n                this.$set(this.tempDateStore, dateKey, this.inputInt[dateKey]);\n              }\n            });\n        }\n      }\n      this.convertDate();\n    },\n    /**\n     * when input becomes inactive always also blur input field just in case\n     * @param {boolean} val - the changed fromOpen value\n     */\n    fromOpen(val) {\n      if (!val) {\n        this.$refs.inputFrom.blur();\n      } else {\n        this.toOpen = false;\n      }\n    },\n    /**\n     * when input becomes inactive always also blur input field just in case\n     * @param {boolean} val - the changed toOpen value\n     */\n    toOpen(val) {\n      if (!val && this.$refs.inputTo) {\n        this.$refs.inputTo.blur();\n      } else if (val) {\n        this.fromOpen = false;\n      }\n    },\n    /**\n     * watch for changes in input field active variable to keep in sync with parent\n     * @param {boolean} val - the changed internal is active variable\n     */\n    isActiveInt(val) {\n      if (val !== this.isActive) {\n        this.$emit('update:is-active', val);\n      }\n    },\n    /**\n     * also adjust internal variable when active state changes from outside\n     * @param {boolean} val - the changed isActive prop\n     */\n    isActive: {\n      handler(val) {\n        if (val !== this.isActiveInt) {\n          this.isActiveInt = val;\n        }\n        // if isActive is set false from outside also close date picker\n        if (!val) {\n          this.fromOpen = false;\n          this.toOpen = false;\n        }\n      },\n      immediate: true,\n    },\n  },\n  mounted() {\n    if (this.$refs.baseIcon) {\n      this.iconWidth = this.$refs.baseIcon.$el.clientWidth;\n    }\n    // initialize the resize observer to calculate fade out and label row when component is resized\n    this.initObservers();\n  },\n  updated() {\n    // this hack is necessary because otherwise keyboard navigation was impaired by the datepicker\n    // pop up elements\n    // check if datepicker element is actually open\n    if (this.fromOpen || this.toOpen) {\n      // wait until elements are rendered\n      this.$nextTick(() => {\n        // get all focusable elements that have the 'mx-' in the class name\n        // had to add 'div's as well because of some strange effect in Firefox\n        const keyboardfocusableElements = [...this.$el.querySelectorAll(\n          'div, a, button, input, textarea, select, details, [tabindex]:not([tabindex=\"-1\"])',\n        )]\n          .filter(el => !el.hasAttribute('disabled'))\n          .filter(el => el.className.includes('mx-'));\n        // iterate through the elements and add tabindex -1\n        keyboardfocusableElements.forEach((element) => {\n          element.setAttribute('tabindex', -1);\n        });\n      });\n    }\n  },\n  beforeDestroy() {\n    if (this.resizeObserver) this.resizeObserver.disconnect();\n    if (this.labelAdditionsObserver) this.labelAdditionsObserver.disconnect();\n  },\n  methods: {\n    initObservers() {\n      // create an observer with the fade out calc function\n      const tempResizeObserver = new ResizeObserver(debounce(50, () => {\n        if (this.showLabel && (this.isSwitchableFormat || this.labelRowSlotsHaveData)) {\n          this.calcLabelAdditionsWidth();\n        }\n        this.calcFadeOut(['From', 'To']);\n      }));\n      // put it on the relevant element\n      tempResizeObserver.observe(this.$refs.baseDateInput);\n      // store it in variable\n      this.resizeObserver = tempResizeObserver;\n\n      if (this.showLabel && (this.isSwitchableFormat || this.labelRowSlotsHaveData)) {\n        // second observer to trigger label additions width calc as soon as element is rendered\n        const tempLabelAdditionsObserver = new ResizeObserver(debounce(50, (entries, observer) => {\n          // only do calc when element is filled\n          if (entries[0].contentRect.width > 0) {\n            this.calcLabelAdditionsWidth(this.$refs.baseDateInput.clientWidth);\n            // only do this once as soon as elements are rendered - then disconnect!\n            observer.disconnect();\n          }\n        }));\n        tempLabelAdditionsObserver.observe(this.$refs.labelAdditions);\n        this.labelAdditionsObserver = tempLabelAdditionsObserver;\n      }\n    },\n    /**\n     * transform the date to the correct display format\n     * @param {string} dateString - the date string in YYYY-MM-DD format\n     */\n    dateDisplay(dateString) {\n      return dateString ? dateString.split('-').reverse().join('.') : '';\n    },\n    /**\n     * transform the date to the correct storage format\n     * @param {string} dateString - the date string in DD.MM.YYYY format\n     */\n    dateStorage(dateString) {\n      return dateString ? dateString.split('.').reverse().join('-') : '';\n    },\n    /**\n     * checks done on keydown events\n     * a) tab key needs separate handling and only needs to set input field close when\n     * there is no clearable button (or shift key was used for going to previous field)\n     * b) prevent user from entering chars other than number or period (date) or colon (time)\n     * and not more characters than the date format requires\n     * @param {KeyboardEvent} event - the keydown event\n     * @param {string} origin - is event coming from 'from' or 'to' field in title case\n     */\n    handleInputKeydown(event, origin) {\n      let currentInputString = this[`input${origin}`];\n      // get the key triggering the event\n      const { key } = event;\n      // now check for the specific input key to preventDefault and prevent unwanted\n      // characters\n      // create boolean to determine if it is a time field (otherwise date is assumed)\n      const isTimeField = this.type === 'timerange' || (this.type === 'datetime' && origin === 'to');\n      // if time ':' is allowed in input regex - otherwise '.'\n      const allowedFieldKey = isTimeField ? ':' : '\\\\.';\n      // create regex for allowed keys\n      const allowedKeysRegex = new RegExp(`([0-9]|${allowedFieldKey}|Backspace|Delete|Tab|Enter|ArrowRight|ArrowLeft)`);\n      // create regex that should not be allowed if max length is reached\n      const disallowedKeysOnLengthRegex = new RegExp(`([0-9]|${allowedFieldKey})`);\n      // get the max length for the respective format (for time: 'HH:mm' = 5)\n      const formatLength = isTimeField ? 5 : this.dateFormatInt.length;\n      // check if\n      // * key was not any of the allowed keys\n      // * or was an allowed key but the length is to long for the format in\n      //    question (and no text was selected = will be replaced)\n      // * if type is date and key was period and date format is year or last char in string was\n      //    already a period\n      // * if type is time and key was colon and last char was already a colon\n      if (!allowedKeysRegex.test(key)\n        || (disallowedKeysOnLengthRegex.test(key) && this[`input${origin}`].length >= formatLength\n          && document.activeElement.selectionEnd - document.activeElement.selectionStart === 0)\n        || (!isTimeField && key === '.' && (this.dateFormatInt === 'YYYY'\n          || currentInputString.charAt(currentInputString.length - 1) === '.'))\n        || (isTimeField && key === ':' && currentInputString.charAt(currentInputString.length - 1) === ':')) {\n        event.preventDefault();\n      }\n      // when the user tries to leave the field check if input string is valid\n      if (key === 'Enter' && currentInputString) {\n        this.checkDateValidity(origin);\n        currentInputString = this[`input${origin}`];\n      }\n      // check if key was tab because of reasons specified above and close picker if necessary\n      if (key === 'Enter' || (key === 'Tab' && (event.shiftKey || !this.clearable\n        || !currentInputString))) {\n        // if yes set the relevant input field open status to false\n        this[`${origin.charAt(0).toLowerCase()}${origin.slice(1)}Open`] = false;\n      }\n    },\n    /**\n     * this function is triggered with the input event - it checks the length of the value and\n     * adds the '.' (date) or (':') or '0' in the correct places if necessary\n     * @param {InputEvent} event - the input event\n     * @param {string} origin - is event coming from 'from' or 'to' field in title case\n     */\n    checkDate(event, origin) {\n      // get the value in question\n      const value = this[`input${origin}`];\n      const isTimeField = this.type === 'timerange' || (this.type === 'datetime' && origin.toLowerCase() === 'to');\n      const charToAdd = isTimeField ? ':' : '.';\n      // check if value is present and if input type is other than 'deleteContentBackward' because\n      // otherwise the dots can not be deleted anymore\n      if (value && event.inputType !== 'deleteContentBackward') {\n        // now check the date format and if input so far matches the appropriate regex\n        if ((!isTimeField && this.dateFormatInt === 'DD.MM.YYYY' && /^(\\d{2}$|\\d{2}\\.\\d{2})$/.test(value))\n            || ((this.dateFormatInt === 'MM.YYYY' || isTimeField) && /^\\d{2}$/.test(value))) {\n          // if so - add a period character\n          this[`input${origin}`] = `${value}${charToAdd}`;\n        }\n        const firstTwoDigitsRegex = new RegExp(`^[1-9]${isTimeField ? ':' : '\\\\.'}$`);\n        // check if input was a period - if yes - check date validity and add zeros if necessary\n        if (firstTwoDigitsRegex.test(value)) {\n          this[`input${origin}`] = `0${this[`input${origin}`]}`;\n        } else if (/^\\d{2}\\.\\d\\.$/.test(value)) {\n          const [day, month, year] = value.split('.');\n          this[`input${origin}`] = `${day}.0${month}.${year}`;\n        }\n      }\n    },\n    /**\n     * this function is triggered with the blur event on the input and does a last check on the\n     * validity of the value\n     * @param {string} origin - is event coming from 'from' or 'to' field in title case\n     */\n    checkDateValidity(origin) {\n      // get the value in question\n      let value = this[`input${origin}`];\n      // check if there is a value present\n      if (value) {\n        // important and mostly different checks to make depending if value is date or time\n        // so save that in variable\n        const isTimeField = this.type === 'timerange' || (this.type === 'datetime' && origin.toLowerCase() === 'to');\n        // also save the current format length\n        const formatLength = isTimeField ? 5 : this.dateFormatInt.length;\n        // get the separator depending on time or date field\n        const separator = isTimeField ? ':' : '.';\n        // get the array length of array with string split up by separator (should be same for\n        // format and value string)\n        const numberFormatParts = isTimeField ? 2 : this.dateFormatInt.split('.').length;\n        // first check if periods (date) or colons (time) are too many\n        if (value.split(separator).length > numberFormatParts) {\n          // just remove all the periods or colons - there the next check will add some again\n          this[`input${origin}`] = value.replaceAll('.', '');\n          value = this[`input${origin}`];\n        }\n        // check if there are too little separators\n        if (numberFormatParts > value.split(separator).length) {\n          // check if day and month (for DDMMYYYY) or month and year (for MMYYYY) or time\n          // are without period or colon respectively\n          if (formatLength !== 4 && /^\\d{3}/.test(value)) {\n            // this assumes the first two digits are for day or month respectively!\n            // TODO: not ideal that 2 digits are assumed - see if this can be improved\n            this[`input${origin}`] = `${value.slice(0, 2)}${separator}${value.slice(2, value.length)}`;\n            value = this[`input${origin}`];\n          }\n          // check if there is a second period between month and year (for DDMMYYYY)\n          if (this.dateFormatInt === 'DD.MM.YYYY' && formatLength !== 4 && /^\\d{2}\\.\\d{3}/.test(value)) {\n            // this assumes there are two digits for day and month respectively!\n            // TODO: not ideal that 2 digits are assumed - see if this can be improved\n            this[`input${origin}`] = `${value.slice(0, 5)}.${value.slice(5, value.length)}`;\n            value = this[`input${origin}`];\n          }\n        }\n        // second check if the length of the value is correct\n        if (value.length !== formatLength) {\n          // distinguish between date and time string\n          if (isTimeField) {\n            // check if minutes are missing\n            if (/^\\d{1,2}:?$/.test(value)) {\n              const [hours] = value.split(':');\n              this[`input${origin}`] = `${hours}:00`;\n              value = this[`input${origin}`];\n            }\n            // check if zeros out front are missing from hour\n            if (/^\\d:\\d{1,2}$/.test(value)) {\n              const [hours, minutes] = value.split(':');\n              this[`input${origin}`] = `0${hours}:${minutes}`;\n              value = this[`input${origin}`];\n            }\n            // check if zeros out front are missing from minute\n            if (/^\\d{2}:\\d$/.test(value)) {\n              const [hours, minutes] = value.split(':');\n              this[`input${origin}`] = `${hours}:0${minutes}`;\n              value = this[`input${origin}`];\n            }\n          } else {\n            // first check reason for length mismatch is year having only two digits or is\n            // completely missing for date format\n            if (this.dateFormatInt === 'DD.MM.YYYY' && /^\\d{1,2}\\.\\d{1,2}\\.?(\\d{0}|\\d{2})$/.test(value)) {\n              // determine current year\n              const currentYear = new Date().getFullYear();\n              const [day, month, year] = value.split('.');\n              // repair date and add first two year digits - if date more than 10 years to the\n              // future - make it 20. century\n              const century = (currentYear).toString().slice(0, 2);\n              this[`input${origin}`] = `${day}.${month}.${year > (currentYear + 10).toString().slice(2, 4)\n                ? Number(century - 1) : century}${year || currentYear.toString().slice(2, 4)}`;\n              value = this[`input${origin}`];\n            }\n            // for month format\n            if (this.dateFormatInt === 'MM.YYYY' && /^\\d{1,2}\\.?(\\d{0}|\\d{2})$/.test(value)) {\n              // determine current year\n              const currentYear = new Date().getFullYear();\n              const [month, year] = value.split('.');\n              // repair date and add first two year digits - if date more than 10 years to the\n              // future - make it current century - otherwise last century\n              const century = (currentYear).toString().slice(0, 2);\n              this[`input${origin}`] = `${month}.${year > (currentYear + 10).toString().slice(2, 4)\n                ? Number(century - 1) : century}${year || currentYear.toString().slice(2, 4)}`;\n              value = this[`input${origin}`];\n            }\n            // second check if the reason for the length not matching is that the day is\n            // missing a zero\n            if (this.dateFormatInt === 'DD.MM.YYYY' && /^[1-9]\\.\\d{1,2}\\.\\d{4}$/.test(value)) {\n              // get the values\n              const [day, month, year] = value.split('.');\n              // repair date and add a zero to day\n              this[`input${origin}`] = `0${day}.${month}.${year}`;\n              value = this[`input${origin}`];\n            }\n            // second check if the reason for mismatching length is that the zero in month\n            // is missing\n            if (['DD.MM.YYYY', 'MM.YYYY'].includes(this.dateFormatInt) && /^\\d{2}?\\.?[1-9]\\.\\d{4}$/.test(value)) {\n              // get values, reverse in order to be able to get also correct values for format\n              // 'month'\n              const [year, month, day] = value.split('.').reverse();\n              // repair date and add missing zero to month\n              this[`input${origin}`] = `${day}.0${month}.${year}`;\n              value = this[`input${origin}`];\n            }\n          }\n          // now check if time/date has now the correct length - if not still remove the value\n          if (value.length !== formatLength) {\n            this[`input${origin}`] = '';\n          }\n        }\n        // now check for general validity\n        if (isTimeField) {\n          // just add random date to see if time is valid\n          if (Number.isNaN(Date.parse(`12.12.1212T${value}`))) {\n            let [hours, minutes] = value.split(':');\n            // check if valid hours\n            if (!/^([0-1][0-9]|2[0-4])$/.test(hours)) {\n              hours = '00';\n            }\n            // check if valid minutes\n            if (!/^[0-5][0-9]$/.test(minutes)) {\n              minutes = '00';\n            }\n            // construct a new time\n            const newTime = `${hours}:${minutes}`;\n            // now check again if time is valid now if yes assign, if no delete the string\n            this[`input${origin}`] = Number.isNaN(Date.parse(`12.12.1212T${newTime}`)) ? newTime : '';\n            value = this[`input${origin}`];\n          }\n        } else {\n          // now truly check if date is a valid date\n          if (Number.isNaN(Date.parse(this.dateStorage(value)))) {\n            // TODO: check if date has appropriate number of periods\n            const [year, month, day] = value.split('.').reverse();\n            if (this.dateFormatInt === 'DD.MM.YYYY') {\n              // TODO: could this check already be done on input???\n              // check if something is wrong with the day\n              if (!/^(0[1-9]|[1-2][0-9]|3[0-1])/.test(day)) {\n                // replace day with appropriate value\n                this[`input${origin}`] = `01.${month}.${year}`;\n              }\n            } if (this.dateFormatInt !== 'YYYY') {\n              // check if something is wrong with the month\n              if (!/^(0[1-9]|1[0-2])/.test(month)) {\n                // replace month with appropriate value\n                this[`input${origin}`] = `${day ? `${day}.` : ''}01.${year}`;\n              }\n            }\n          }\n          // since technically invalid dates (like 30.02.2000) will also be considered a\n          // vaild date by Date.parse() just convert to Date and back one more time\n          // new Date(input) will always convert to the actual day in the next month\n          // e.g. 31.06. --> 01.07. ; 30.02. --> 02.03.\n          const tempDate = this.getDateString(this.convertToDate(this.dateStorage(this[`input${origin}`])));\n          if (!Number.isNaN(Date.parse(this.dateStorage(tempDate)))) {\n            this[`input${origin}`] = this.getDateString(this.convertToDate(this.dateStorage(this[`input${origin}`])));\n          } else {\n            this[`input${origin}`] = '';\n          }\n        }\n        // after everything also still check if the new date/time string needs a fade out\n        this.calcFadeOut([origin]);\n      }\n      const data = this.getInputData();\n      /**\n       * this event is emitted when the value was validated in case input should just be considered\n       * after date validation\n       *\n       * @event value-validated\n       * @param {string, Object} - the validated string or input object\n       */\n      this.$emit('value-validated', data);\n    },\n    /**\n     * a function to have the time picker close automatically as soon as minutes\n     * are selected\n     * @param {string} origin - is it from the 'from' or 'to' part of the picker\n     * @param {any} time - the selected time (not needed here but passed by event)\n     * @param {string} type - was 'hour' or 'minute' selected\n     */\n    closeTimePicker(origin, time, type) {\n      if (type === 'minute') {\n        this[`${origin}Open`] = false;\n        // check if the new date/time string needs a fade out\n        this.calcFadeOut([`${origin.charAt(0).toUpperCase()}${origin.slice(1)}`]);\n      }\n    },\n    /**\n     * function triggered on datepicker 'pick' event, handling date picker closing\n     * and date validation\n     * @param origin\n     * @param isTimeField\n     */\n    datePicked(origin, isTimeField) {\n      if (!isTimeField) {\n        this[`${origin}Open`] = false;\n      }\n      // need this here because on blur() date is not updated\n      this.checkDateValidity(origin);\n    },\n    /**\n     * handle click outside event and adjust input active variable accordingly\n     * @param {MouseEvent} event - the event provided by the click outside directive\n     */\n    clickedOutside(event) {\n      this.isActiveInt = false;\n      /**\n       * emit a custom clicked-outside event instead of BaseInput event (propagation stopped)\n       *\n       * @event clicked-outside\n       * @param {MouseEvent} - the native Event\n       */\n      this.$emit('clicked-outside', event);\n    },\n    /**\n     * handle click inside the component and adjust input active variable accordingly\n     * @param {MouseEvent} event - event triggered by mouse click\n     */\n    clickedInside(event) {\n      this.isActiveInt = true;\n      /**\n       * event additionally triggered to BaseInput default click-input-field to also\n       * set field active if component sourroundings are clicked\n       *\n       * @event click-input-field\n       * @param {MouseEvent} - the native Event\n       */\n      this.$emit('click-input-field', event);\n    },\n    /**\n     * data emit function, transforming data before emit event\n     */\n    emitData() {\n      // get a data object that only contains fields that were also present\n      // in external input\n      const data = this.getInputData();\n      /**\n       * emit an event when focus leaves the input\n       *\n       * @event selected\n       * @param {string, Object} - the input string or object\n       */\n      this.$emit('selected', data);\n    },\n    /**\n     * convert function triggered on format tab switch\n     */\n    convertDate() {\n      Object.keys(this.inputInt).filter(key => !!key.includes('date'))\n        .forEach((dateKey) => {\n          const dateToConvert = this.inputInt[dateKey];\n          if (dateToConvert) {\n            if (this.minDateView === 'year') {\n              // convert date string to real date in order to get year and convert back to string\n              this.$set(this.inputInt, dateKey, this.convertToDate(dateToConvert)\n                .getFullYear().toString());\n            } else if (this.minDateView === 'month') {\n              const newDate = !!this.tempDateStore\n                // get stored date if\n                // a) previous date was full date and month and year\n                // are identical with stored year and month\n                && ((!this.isDateFormatYear\n                && this.monthAndYearIdent(this.tempDateStore[dateKey], dateToConvert))\n                // b) previous date was year and it is identical with stored year\n                || (new Date(this.tempDateStore[dateKey])\n                  .getFullYear().toString() === dateToConvert))\n                // else use current input date\n                ? this.tempDateStore[dateKey] : dateToConvert;\n              this.$set(\n                this.inputInt,\n                dateKey,\n                this.getDateString(this.convertToDate(newDate), true),\n              );\n            } else {\n              // check if a previous date was stored and year (coming from year)\n              const useStoredDate = !!this.tempDateStore && ((this.isDateFormatYear\n                && new Date(this.tempDateStore[dateKey]).getFullYear().toString() === dateToConvert)\n                // or month and year (coming from month) was changed or is still the same\n                || (this.isDateFormatMonth\n                && this.monthAndYearIdent(this.tempDateStore[dateKey], dateToConvert)));\n              // if a previous date was stored use this one else use the input date\n              const newDate = useStoredDate ? this.tempDateStore[dateKey] : dateToConvert;\n              // set the new date (converted to date and formatted\n              // in the correct format YYYY-MM-DD)\n              this.$set(\n                this.inputInt,\n                dateKey,\n                this.getDateString(this.convertToDate(newDate)),\n              );\n            }\n          }\n        });\n    },\n    /**\n     * if input was just a single string return that otherwise\n     * only return the properties provided by external input\n     * if input is empty set value to empty string instead of null (default vue2-datepicker)\n     * @returns {string | Object}\n     */\n    getInputData() {\n      if (this.isSingleDate) {\n        return this.inputInt.date !== null ? this.inputInt.date : '';\n      }\n      const data = {};\n      this.inputProperties.forEach(key => this.$set(data, key, this.inputInt[key] !== null ? this.inputInt[key] : ''));\n      return data;\n    },\n    /**\n     * convert a value to a date in local time at zero hours\n     *\n     * @param value: the date string stored in db (format YYYY-MM-DD)\n     * @returns {Date} - (e.g. Fri Jul 30 2021 00:00:00 GMT+0200 (Central European Summer Time))\n     */\n    convertToDate(value) {\n      return new Date(`${value}T00:00:00.000`);\n    },\n    /**\n     * a function to convert a date to a string in the format YYYY-MM-DD\n     *\n     * @param {Date} date in format\n     * @returns {string} - returns a string in format YYYY-MM-DD\n     */\n    getDateString(date) {\n      // there is always a year\n      let dateString = `${date.getFullYear().toString()}`;\n      // if date format is not 'year' only - add month\n      if (this.dateFormatInt !== 'YYYY') {\n        const month = (date.getMonth() + 1).toString();\n        dateString = `${dateString}-${month.length < 2 ? '0' : ''}${month}`;\n      }\n      // if date format is 'date' - add day\n      if (this.dateFormatInt === 'DD.MM.YYYY') {\n        const day = date.getDate().toString();\n        dateString = `${dateString}-${day.length < 2 ? '0' : ''}${day}`;\n      }\n      return dateString;\n    },\n    monthAndYearIdent(date1, date2) {\n      const convertedDate1 = this.convertToDate(date1);\n      const convertedDate2 = this.convertToDate(date2);\n      const monthDate1 = convertedDate1.getMonth();\n      const monthDate2 = convertedDate2.getMonth();\n      const yearDate1 = convertedDate1.getFullYear();\n      const yearDate2 = convertedDate2.getFullYear();\n      return monthDate1 === monthDate2 && yearDate1 === yearDate2;\n    },\n    /**\n     * function to calculate if fade out in the input fields should be shown, needs to be\n     * recalculated after resize or if input changes\n     */\n    calcFadeOut(inputFields) {\n      // now iterate through the relevant fields\n      inputFields.forEach((field) => {\n        // check if element exists\n        if (this.$refs[`input${field}`]) {\n          // now get the input field value\n          const inputValue = this.$refs[`input${field}`].value;\n          // for width (and fade out) calculation either use that or the placeholder visible\n          // in the field (this is saved in a separate variable from inputValue because for\n          // show icons only input value is relevant)\n          const text = inputValue || this.$refs[`input${field}`].getAttribute('placeholder');\n          // now check if any of the two exists\n          if (text) {\n            // create a span\n            const span = document.createElement('span');\n            // hide the span\n            span.setAttribute('class', 'hide');\n            // add the input extracted text to this span\n            span.innerHTML = text;\n            // add the element to the document body\n            document.body.appendChild(span);\n            // get the width of that element\n            const textWidth = span.offsetWidth;\n            // remove the element again\n            document.body.removeChild(span);\n            // now also get the input width\n            const inputWidth = this.$refs[`input${field}`].offsetWidth;\n            // check if the input value or placeholder width exceeds input width\n            if (textWidth > inputWidth) {\n              // if yes and there is input and icons are shown\n              if (inputValue && this.showIcons) {\n                // remove icons\n                this.showIcons = false;\n                // otherwise use fade out\n              } else {\n                this[`useFadeOut${field}`] = true;\n              }\n              // if input value or placeholder fit the input width\n            } else if (textWidth <= inputWidth) {\n              // check first if the fade out is used\n              if (this[`useFadeOut${field}`]) {\n                // if so - disable this one first\n                this[`useFadeOut${field}`] = false;\n                // else check if the icon would actually fit in the input together with the\n                // input width - if so - show icons\n              } else if (!this.showIcons && textWidth + this.iconWidth <= inputWidth) {\n                this.showIcons = true;\n              }\n            }\n          }\n        }\n      });\n    },\n    /**\n     * function to correctly style the date format switch buttons and prevent\n     * overlay with label\n     */\n    calcLabelAdditionsWidth() {\n      // get the complete element width\n      const observableWidth = this.$refs.baseDateInput.clientWidth;\n      // get the label margin\n      const labelMargin = this.showLabel\n        ? Number(getComputedStyle(this.$refs.label)['margin-right'].replace('px', '')) : 0;\n      const labelWidth = this.showLabel ? this.$refs.label.clientWidth : 0;\n      // calculate the remaining container space after label, label margin and date switch width\n      const spacingLeft = observableWidth\n        - labelWidth\n        - labelMargin\n        - this.$refs.labelAdditions.clientWidth;\n      // if no space is left set a class that sets label additions width to 100% so element has to wrap\n      this.wrapLabelRow = spacingLeft < 0;\n    },\n    /**\n     * add delay before value is set\n     *\n     * @param {String} key\n     * @param {boolean} value\n     */\n    isActiveHandler(key, value) {\n      // if false set value immediately\n      if (!value) {\n        this[key] = value;\n        return;\n      }\n\n      // otherwise add a delay\n      setTimeout(() => {\n        this[key] = value;\n      }, this.isActiveDelay);\n    },\n  },\n};\n</script>\n\n<style lang=\"scss\" scoped>\n  @import '../../styles/variables.scss';\n\n  .base-date-input {\n    display: flex;\n    flex-direction: column;\n    width: 100%;\n    position: relative;\n\n    .base-date-input__label-row {\n      display: flex;\n      flex-wrap: wrap;\n      width: 100%;\n      height: 100%;\n      justify-content: space-between;\n      align-items: center;\n\n      &.base-date-input__label-row--visible {\n        margin-bottom: $spacing-small-half;\n      }\n\n      .base-date-input__label {\n        color: $font-color-second;\n        margin-bottom: $spacing-small-half;\n        text-align: left;\n        align-self: flex-end;\n        margin-right: 50px;\n      }\n\n      .base-date-input__label-additions {\n        position: relative;\n        display: flex;\n        flex-wrap: wrap;\n        align-items: center;\n        justify-content: flex-end;\n        flex: 1 1 auto;\n        height: $line-height;\n\n        &.base-date-input__label-additions--switch-height {\n          height: calc(#{$line-height} + #{$spacing-small-half});\n\n          &.base-date-input__label-additions--wrap {\n            margin-top: 2px;\n          }\n        }\n\n        &.base-date-input__label-additions--wrap {\n          width: 100%;\n        }\n      }\n\n      .base-date-input__label-additions-inner {\n        position: absolute;\n        right: 0;\n        display: flex;\n        align-items: center;\n        margin-bottom: $spacing-small-half;\n\n        &.base-date-input__label-additions-inner--switch {\n          bottom: 0;\n          margin-bottom: calc(-#{$spacing-small-half} / 2);\n\n          @media screen and (max-width: $mobile) {\n            margin-bottom: calc(-#{$spacing-small} - 2px);\n          }\n        }\n        &.base-date-input__label-additions-inner--no-label-switch {\n          margin-bottom:  2px;\n\n          @media screen and (max-width: $mobile) {\n            margin-bottom: calc(-#{$spacing-small} + 1px);\n          }\n        }\n\n        .base-date-input__switch-buttons {\n          bottom: 0;\n          display: flex;\n          line-height: $line-height;\n        }\n      }\n    }\n\n    .base-date-input__field-wrapper {\n      display: flex;\n      align-items: baseline;\n      width: 100%;\n\n      .base-date-input__input-fields {\n        display: flex;\n        align-items: center;\n        flex: 1 1 auto;\n        flex-wrap: wrap;\n\n        .base-date-input__input-line {\n          display: flex;\n          flex: 1 1 auto;\n          align-items: center;\n\n          .base-date-input__input-wrapper {\n\n            & + .base-date-input__input-wrapper {\n              margin-left: $spacing;\n            }\n\n            .base-date-input__datepicker {\n              flex-grow: 1;\n              width: auto;\n              font-family: inherit;\n              font-size: inherit;\n              line-height: $row-height-small;\n\n              .base-date-input__input {\n                padding: $spacing-small-half 0;\n                min-height: $row-height-small;\n                width: 100%;\n              }\n            }\n\n            .base-date-input__icon-wrapper::before {\n              content: '';\n            }\n\n            .base-date-input__date-icon {\n              position: relative;\n              width: $icon-large;\n              height: $icon-large;\n              color: $font-color-second;\n              cursor: pointer;\n              flex-shrink: 0;\n              align-self: center;\n              margin-left: $spacing-small;\n            }\n          }\n\n          .base-date-input__separator {\n            padding: 0 $spacing;\n          }\n        }\n      }\n    }\n\n    .base-date-input__below {\n      position: relative;\n    }\n  }\n\n  @media screen and (max-width: $mobile) {\n    .base-date-input .base-date-input__label-row .base-date-input__label-additions {\n      align-items: center;\n    }\n  }\n</style>\n\n<style lang=\"scss\">\n  @import '../../styles/_datepicker.scss';\n</style>\n"],"names":["_sfc_main","BaseInput","BaseIcon","m","DatePicker","ClickOutside","val","labelKeys","de","en","fr","key","options","event","slotElements","elem","old","dateKey","el","element","tempResizeObserver","debounce","tempLabelAdditionsObserver","entries","observer","dateString","origin","currentInputString","isTimeField","allowedFieldKey","allowedKeysRegex","disallowedKeysOnLengthRegex","formatLength","value","charToAdd","day","month","year","separator","numberFormatParts","hours","minutes","currentYear","century","newTime","tempDate","data","time","type","dateToConvert","newDate","date","date1","date2","convertedDate1","convertedDate2","monthDate1","monthDate2","yearDate1","yearDate2","inputFields","field","inputValue","text","span","textWidth","inputWidth","observableWidth","labelMargin","labelWidth","spacingLeft"],"mappings":"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"}