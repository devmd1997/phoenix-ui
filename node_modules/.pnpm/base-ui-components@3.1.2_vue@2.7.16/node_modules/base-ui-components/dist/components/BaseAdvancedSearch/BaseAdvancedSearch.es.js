import { sort as o, hasData as s, createId as n } from "../../utils/utils.es.js";
import p from "../BaseAdvancedSearchRow/BaseAdvancedSearchRow.es.js";
import "./BaseAdvancedSearch.vue_vue_type_style_index_0_scoped_88b7ce5e_lang.es.js";
import d from "../../_virtual/_plugin-vue2_normalizer.es.js";
const c = {
  name: "BaseAdvancedSearch",
  components: {
    BaseAdvancedSearchRow: p
  },
  props: {
    filterList: {
      type: Array,
      default: () => [],
      validator: (t) => !t.length || t.every((e) => !!e.type && (!["chips", "chipssingle"].includes(e.type) || e.freetext_allowed || !!e.options))
    },
    appliedFilters: {
      type: Array,
      default: () => [],
      validator: (t) => !t.length || t.every((e) => e.type)
    },
    autocompleteResults: {
      type: Array,
      default: () => []
    },
    defaultFilter: {
      type: Object,
      default: () => ({
        label: "Fulltext",
        id: "default",
        type: "text",
        options: [],
        filter_values: []
      }),
      validator: (t) => t === null || t.type && (!["chips", "chipssingle"].includes(t.type) || t.options)
    },
    language: {
      type: String,
      default: ""
    },
    isLoadingIndex: {
      type: Number,
      default: -1
    },
    advancedSearchText: {
      type: Object,
      default: () => ({
        title: "Advanced Search",
        subtext: "Select a filter",
        availableOptions: "Available options",
        addFilter: "Add filter",
        removeFilter: "Remove filter",
        selectFilterLabel: "Select filter",
        searchLabel: "Search for Entries"
      }),
      validator: (t) => [
        "title",
        "subtext",
        "availableOptions",
        "addFilter",
        "removeFilter",
        "selectFilterLabel",
        "searchLabel"
      ].every((e) => Object.keys(t).includes(e))
    },
    dropDownInfoTexts: {
      type: Object,
      default: () => ({
        autocompleteNoOptions: "No matching options found",
        autocompleteOngoing: "Autocomplete is being fetched...",
        autocompleteInitial: "Please start typing or select a filter to see options",
        chipsNoOptions: "No more options available",
        chipsMaxOptions: "Please start typing to see options",
        chipsNoMatch: "No matching options were found",
        chipsOngoing: "Options are being loaded..."
      }),
      validator: (t) => [
        "autocompleteNoOptions",
        "autocompleteOngoing",
        "autocompleteInitial",
        "chipsNoOptions",
        "chipsOngoing",
        "chipsMaxOptions",
        "chipsNoMatch"
      ].every((e) => Object.keys(t).includes(e))
    },
    placeholder: {
      type: [Object, String],
      default: () => ({
        filterRow: "Add values to your filter",
        main: "Search and Discover"
      }),
      validator: (t) => typeof t == "string" || ["filterRow", "main"].every((e) => Object.keys(t).includes(e))
    },
    identifierPropertyName: {
      type: [Object, String],
      default: () => ({
        filter: "id",
        autocompleteOption: "id",
        controlledVocabularyOption: "id"
      })
    },
    labelPropertyName: {
      type: [Object, String],
      default: () => ({
        filter: "label",
        autocompleteOption: "title",
        controlledVocabularyOption: "label"
      })
    },
    autocompletePropertyNames: {
      type: Object,
      default: () => ({
        label: "label",
        id: "id",
        data: "data"
      }),
      validator: (t) => ["id", "label", "data"].every((e) => Object.keys(t).includes(e))
    },
    assistiveText: {
      type: Object,
      default: () => ({})
    },
    applyBoxShadow: {
      type: Boolean,
      default: !0
    },
    dateFieldDelay: {
      type: Number,
      default: 0
    }
  },
  data() {
    return {
      appliedFiltersInt: [],
      mainFilter: null,
      filtersAutocompleteResults: [],
      autocompleteIndex: -1,
      originalMainFilter: null
    };
  },
  computed: {
    filtersLoadingState() {
      return [
        ...this.appliedFiltersInt.map((t, e) => this.autocompleteIndex === e),
        this.autocompleteIndex === this.appliedFiltersInt.length
      ];
    },
    displayedFilters() {
      const t = [...this.filterList].filter((e) => !e.hidden);
      return o(t, this.labelPropertyName.filter);
    },
    mainFilterIndex() {
      const t = this.appliedFilters.length - 1;
      return t > 0 ? t : 0;
    }
  },
  watch: {
    autocompleteResults(t) {
      this.autocompleteIndex >= 0 && (this.$set(this.filtersAutocompleteResults, this.autocompleteIndex, [...t]), this.autocompleteIndex = -1);
    },
    isLoadingIndex() {
    },
    appliedFiltersInt: {
      handler(t) {
        JSON.stringify(t) !== JSON.stringify(this.appliedFilters.slice(1)) && this.$emit("update:applied-filters", [...t, this.mainFilter]);
      },
      deep: !0
    },
    appliedFilters: {
      handler(t) {
        t && JSON.stringify(t.slice(0, -1)) !== JSON.stringify(this.appliedFiltersInt) && ([, ...this.appliedFiltersInt] = JSON.parse(JSON.stringify([t, ...t.slice(0, -1)]))), t && t.length >= 1 && JSON.stringify(this.mainFilter) !== JSON.stringify(t[this.mainFilterIndex]) ? [this.mainFilter] = JSON.parse(JSON.stringify(t.slice(-1))) : (!t || t < 1) && (this.mainFilter = { ...this.defaultFilter });
      },
      immediate: !0
    },
    mainFilter(t) {
      if (t && t.filter_values) {
        const e = s(t.filter_values), i = !!this.originalMainFilter && !!this.originalMainFilter.filter_values && s(this.originalMainFilter.filter_values);
        this.originalMainFilter && (this.originalMainFilter.id !== t.id || e !== i || e && i && JSON.stringify(this.originalMainFilter.filter_values !== JSON.stringify(t.filter_values))) && (this.originalMainFilter = JSON.parse(JSON.stringify(this.mainFilter)), this.search());
      }
      this.$emit("update:applied-filters", [...this.appliedFiltersInt, t]);
    }
  },
  created() {
    this.mainFilter || (this.mainFilter = JSON.parse(JSON.stringify(this.defaultFilter))), this.originalMainFilter = JSON.parse(JSON.stringify(this.mainFilter));
  },
  methods: {
    addFilterRow({ filter: t, input: e }) {
      let i = t.type.includes("date") ? t.filter_values : [...t.filter_values], l = !1;
      t.type === "text" && e.trim() && (!t.filter_values || !t.filter_values.length || this.mainFilter.filter_values[0] !== e.trim()) ? (i = [e], l = !0) : t.type === "chips" && t.freetext_allowed && e.trim() && (i = [
        ...t.filter_values,
        {
          [this.labelPropertyName.autocompleteOption]: e
        }
      ], l = !0), this.appliedFiltersInt.push({
        ...t,
        filter_values: i
      }), this.mainFilter = {
        ...this.defaultFilter
      }, this.originalMainFilter = JSON.parse(JSON.stringify(this.mainFilter)), l && this.search();
    },
    removeFilter(t, e) {
      this.appliedFiltersInt.splice(e, 1), this.search();
    },
    updateFilter(t, e) {
      this.$set(this.appliedFiltersInt, e, JSON.parse(JSON.stringify(t))), this.search();
    },
    fetchAutocomplete({ input: t, filter: e }, i) {
      t ? this.autocompleteIndex = i : this.$set(this.filtersAutocompleteResults, i, []), this.$emit("fetch-autocomplete", { searchString: t, filter: e, index: i });
    },
    search() {
      this.$emit("search", [...this.appliedFiltersInt, this.mainFilter]);
    },
    getRowId() {
      return n();
    }
  }
};
var u = function() {
  var e = this, i = e._self._c;
  return i("div", { staticClass: "base-advanced-search" }, [e.appliedFiltersInt && e.appliedFiltersInt.length ? e._l(e.appliedFiltersInt, function(l, a) {
    return i("BaseAdvancedSearchRow", { key: "filter-" + a, staticClass: "base-advanced-search__filter-row", attrs: { "search-row-id": e.getRowId(), "is-main-search": !1, "autocomplete-results": e.filtersAutocompleteResults[a], "filter-list": e.displayedFilters, "applied-filter": l, "is-loading": e.filtersLoadingState[a], "default-filter": e.defaultFilter, placeholder: e.placeholder.filterRow || e.placeholder, "autocomplete-property-names": e.autocompletePropertyNames, "label-property-name": e.labelPropertyName, "identifier-property-name": e.identifierPropertyName, "drop-down-info-texts": e.dropDownInfoTexts, "advanced-search-text": e.advancedSearchText, "assistive-text": e.assistiveText, "date-field-delay": e.dateFieldDelay, language: e.language }, on: { "remove-filter": function(r) {
      return e.removeFilter(r, a);
    }, "update:applied-filter": function(r) {
      return e.updateFilter(r, a);
    }, "fetch-autocomplete-results": function(r) {
      return e.fetchAutocomplete(r, a);
    } } });
  }) : e._e(), i("BaseAdvancedSearchRow", e._b({ attrs: { "search-row-id": "main", "is-main-search": !0, "applied-filter": e.mainFilter, "filter-list": e.displayedFilters, "default-filter": e.defaultFilter, "autocomplete-results": e.filtersAutocompleteResults[e.mainFilterIndex], "is-loading": e.filtersLoadingState[e.mainFilterIndex], placeholder: e.placeholder.main || e.placeholder, "autocomplete-property-names": e.autocompletePropertyNames, "label-property-name": e.labelPropertyName, "identifier-property-name": e.identifierPropertyName, "drop-down-info-texts": e.dropDownInfoTexts, "advanced-search-text": e.advancedSearchText, "assistive-text": e.assistiveText, "date-field-delay": e.dateFieldDelay, language: e.language }, on: { "update:appliedFilter": function(l) {
    e.mainFilter = l;
  }, "update:applied-filter": function(l) {
    e.mainFilter = l;
  }, "add-filter-row": e.addFilterRow, "fetch-autocomplete-results": function(l) {
    return e.fetchAutocomplete(l, e.mainFilterIndex);
  } } }, "BaseAdvancedSearchRow", e.$listeners, !1))], 2);
}, f = [], h = /* @__PURE__ */ d(
  c,
  u,
  f,
  !1,
  null,
  "88b7ce5e",
  null,
  null
);
const O = h.exports;
export {
  O as default
};
//# sourceMappingURL=BaseAdvancedSearch.es.js.map
