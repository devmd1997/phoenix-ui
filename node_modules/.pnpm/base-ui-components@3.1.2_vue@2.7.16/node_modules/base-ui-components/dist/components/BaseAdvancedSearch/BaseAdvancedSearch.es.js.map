{"version":3,"file":"BaseAdvancedSearch.es.js","sources":["../../../src/components/BaseAdvancedSearch/BaseAdvancedSearch.vue"],"sourcesContent":["<template>\n  <div class=\"base-advanced-search\">\n    <template v-if=\"appliedFiltersInt && appliedFiltersInt.length\">\n      <BaseAdvancedSearchRow\n        v-for=\"(filter, index) in appliedFiltersInt\"\n        :key=\"'filter-' + index\"\n        :search-row-id=\"getRowId()\"\n        :is-main-search=\"false\"\n        :autocomplete-results=\"filtersAutocompleteResults[index]\"\n        :filter-list=\"displayedFilters\"\n        :applied-filter=\"filter\"\n        :is-loading=\"filtersLoadingState[index]\"\n        :default-filter=\"defaultFilter\"\n        :placeholder=\"placeholder.filterRow || placeholder\"\n        :autocomplete-property-names=\"autocompletePropertyNames\"\n        :label-property-name=\"labelPropertyName\"\n        :identifier-property-name=\"identifierPropertyName\"\n        :drop-down-info-texts=\"dropDownInfoTexts\"\n        :advanced-search-text=\"advancedSearchText\"\n        :assistive-text=\"assistiveText\"\n        :date-field-delay=\"dateFieldDelay\"\n        :language=\"language\"\n        class=\"base-advanced-search__filter-row\"\n        @remove-filter=\"removeFilter($event, index)\"\n        @update:applied-filter=\"updateFilter($event, index)\"\n        @fetch-autocomplete-results=\"fetchAutocomplete($event, index)\" />\n    </template>\n\n    <BaseAdvancedSearchRow\n      :search-row-id=\"'main'\"\n      :is-main-search=\"true\"\n      :applied-filter.sync=\"mainFilter\"\n      :filter-list=\"displayedFilters\"\n      :default-filter=\"defaultFilter\"\n      :autocomplete-results=\"filtersAutocompleteResults[mainFilterIndex]\"\n      :is-loading=\"filtersLoadingState[mainFilterIndex]\"\n      :placeholder=\"placeholder.main || placeholder\"\n      :autocomplete-property-names=\"autocompletePropertyNames\"\n      :label-property-name=\"labelPropertyName\"\n      :identifier-property-name=\"identifierPropertyName\"\n      :drop-down-info-texts=\"dropDownInfoTexts\"\n      :advanced-search-text=\"advancedSearchText\"\n      :assistive-text=\"assistiveText\"\n      :date-field-delay=\"dateFieldDelay\"\n      :language=\"language\"\n      v-bind=\"$listeners\"\n      @add-filter-row=\"addFilterRow\"\n      @fetch-autocomplete-results=\"fetchAutocomplete($event, mainFilterIndex)\" />\n  </div>\n</template>\n\n<script>\nimport { createId, hasData, sort } from '@/utils/utils';\nimport BaseAdvancedSearchRow from '@/components/BaseAdvancedSearchRow/BaseAdvancedSearchRow';\n\n/**\n * @typedef Filter\n * @property {string} label|* - property 'label' indicating the label or an equivalent\n *  custom property defined in prop labelPropertyName.filter\n * @property {string} id|* - property 'id' used as unique identifier or an equivalent\n *  custom property defined in prop identifierPropertyName.filter\n * @property {string} type - a filter type defining the type of search element shown\n *  @values text, chips, chipssingle, date, daterange\n * @property {boolean} [hidden] - exclude filters that have this attribute true from display\n * @property {boolean} [freetext_allowed] - property specifc for type: chips determining\n *  if options are autocompleted (true) or used from the options property (false)\n * @property {Object[]} [options] - the options used for chips filter types with\n *  freetext_allowed false\n * @property {Object[]|string[]|string|Object} [filter_values] - the values a filter contains - only\n *  relevant for applied filters, not for filters coming from backend presented in the drop down\n * @property {string[]} [subsets] - if a filter of `type` 'text' or 'chips' with `freetext_allowed`\n *      (thus triggering autocomplete) has subordinate filters for which the autosuggest results\n *      should also be shown - add these filter ids here\n */\n\nexport default {\n  name: 'BaseAdvancedSearch',\n  components: {\n    BaseAdvancedSearchRow,\n  },\n  props: {\n    /**\n     * list of available filters, needs to be an array of objects with the following properties:\n     *\n     *    **label** `string` - the label of the filter (displayed\n     *      if not main search) - this prop can be customized by specifying\n     *      `labelPropertyName.filter`.\n     *    **id** `string` - the identifier of the filter (displayed\n     *      if not main search) - this prop can be customized by specifying\n     *      `identifierPropertyName.filter`.\n     *    **type** `string` - the filter type. Possible values: `text`, `chips`, `chipssingle`, `date`, `daterange`.\n     *    **hidden** `boolean` - filters with this attribute true will be filtered from\n     *      displayed filter list.\n     *    **freetext_allowed** `boolean` - determines if predetermined options from `options`\n     *      property are used or autocomplete is used.\n     *    **options** `Object[]` - for filter type `chips` and `chipssingle` the controlled\n     *      vocabulary options.\n     *     **subsets** `string[]` - if a filter of `type` 'text' or 'chips' with\n     *      `freetext_allowed` (thus triggering autocomplete) has subordinate filters for which\n     *      the autosuggest results should also be shown - add the filter identifiers here\n     */\n    filterList: {\n      type: Array,\n      default: () => ([]),\n      validator: val => !val.length\n        // make sure a filter type is present and type is other than chips or freetext is\n        // allowed - otherwise it needs to have an options property\n        || (val.every(v => !!v.type\n          && (!['chips', 'chipssingle'].includes(v.type) || v.freetext_allowed || !!v.options))),\n    },\n    /**\n     * possibility to set applied filters from outside, for necessary object properties\n     * see `filterList` (except `options` - this property is not necessary for applied filters)\n     */\n    appliedFilters: {\n      type: Array,\n      default: () => ([]),\n      // don't check for options on applied filters - not necessary\n      validator: val => !val.length || val.every(v => v.type),\n    },\n    /**\n     * provide the component with the fetched autocomplete results\n     * (drop down options).\n     * this needs to be an object array with the properties specified in\n     * `autocompletePropertyNames`.\n     */\n    autocompleteResults: {\n      type: Array,\n      default: () => [],\n    },\n    /**\n     * specify a default value for a filter that is set when none of the\n     * available filters is selected, should have the following properties:\n     *\n     *    **label** `string` - the label of the filter (displayed\n     *      if not main search) - this prop can be customized by specifying\n     *      `labelPropertyName.filter`.\n     *    **id** `string` - the identifier of the filter (displayed\n     *      if not main search) - this prop can be customized by specifying\n     *      `identifierPropertyName.filter`.\n     *    **type** `string` - the filter type. Possible values: `text`, `chips`, `chipssingle`, `date`, `daterange`.\n     *    **options** `Object[]` - for filter type `chips` and `chipssingle` the controlled\n     *      vocabulary options.\n     *    **filter_values** `Object[], string[], Object` - the values selected - object for date\n     *    or array of objects or strings for type `text`, type `chips` and `chipssingle`,\n     *\n     *    defaultFilter does not need the property `subsets` since results for all filters are\n     *    shown per default\n     */\n    defaultFilter: {\n      type: Object,\n      default: () => ({\n        label: 'Fulltext',\n        id: 'default',\n        type: 'text',\n        options: [],\n        filter_values: [],\n      }),\n      validator: val => val === null || (val.type\n        && (!['chips', 'chipssingle'].includes(val.type) || val.options)),\n    },\n    /**\n     * specify a language (ISO 639-1) (used for label if label is language specific object\n     * e.g. `{ de: 'xxx', en: 'yyy' }`).\n     */\n    language: {\n      type: String,\n      default: '',\n    },\n    /**\n     * set the row loader from outside per row index\n     */\n    isLoadingIndex: {\n      type: Number,\n      default: -1,\n    },\n    /**\n     * specify informational texts for the component - this needs to be an object with the following\n     * properties (if you don't want to display any text leave an empty string):\n     *\n     *     **title**: text shown as first line on the drop-down in filters area.\n     *     **subtext**: text shown as second line on the drop-down in filters area.\n     *     **availableOptions**: text shown with chips options for controlled vocabulary\n     *     search.\n     *     **addFilter**: text/label used for add filter icon.\n     *     **removeFilter**: text/label used for remove filter icon.\n     *     **selectFilterLabel**: label (not visible) used for filter chips input field.\n     *     **searchLabel**: label (not visible) used for search input field.\n     *\n     *  The values of this object might be plain text or a key for an i18n file.\n     * This prop can be ignored when the `no-options` slot is used.\n     */\n    advancedSearchText: {\n      type: Object,\n      default: () => ({\n        title: 'Advanced Search',\n        subtext: 'Select a filter',\n        availableOptions: 'Available options',\n        addFilter: 'Add filter',\n        removeFilter: 'Remove filter',\n        selectFilterLabel: 'Select filter',\n        searchLabel: 'Search for Entries',\n      }),\n      // checking if all necessary properties are part of the provided object\n      validator: val => ['title', 'subtext', 'availableOptions',\n        'addFilter', 'removeFilter', 'selectFilterLabel', 'searchLabel']\n        .every(prop => Object.keys(val).includes(prop)),\n    },\n    /**\n     * specify informational texts for the drop-down - this needs to be an object with the following\n     * properties:\n     *\n     *     **autocompleteNoOptions**: info text shown when autocomplete search does not yield\n     *        any results.\n     *     **autocompleteOngoing**: info text displayed while autocomplete search is ongoing\n     *        (and no previous results are displayed).\n     *     **autocompleteInitial**: info text shown when user first opens the search\n     *        component.\n     *     **chipsNoOptions**: info text shown when no options for controlled vocabulary search\n     *        are available (anymore).\n     *     **chipsMaxOptions**: text displayed if more than max number of options that can be\n     *        displayed are available (configure via prop `maxNumberControlledOptions`).\n     *     **chipsNoMatch**: text displayed if string in input does not match any options.\n     *     **chipsOngoing**: info text shown when controlled vocabulary chips are being\n     *        fetched.\n     *\n     *  The values of this object might be plain text or a key for an i18n file\n     * This prop can be ignored when the `no-options` slot is used.\n     */\n    dropDownInfoTexts: {\n      type: Object,\n      default: () => ({\n        autocompleteNoOptions: 'No matching options found',\n        autocompleteOngoing: 'Autocomplete is being fetched...',\n        autocompleteInitial: 'Please start typing or select a filter to see options',\n        chipsNoOptions: 'No more options available',\n        chipsMaxOptions: 'Please start typing to see options',\n        chipsNoMatch: 'No matching options were found',\n        chipsOngoing: 'Options are being loaded...',\n      }),\n      // checking if all necessary properties are part of the provided object\n      validator: val => ['autocompleteNoOptions', 'autocompleteOngoing', 'autocompleteInitial',\n        'chipsNoOptions', 'chipsOngoing', 'chipsMaxOptions', 'chipsNoMatch']\n        .every(prop => Object.keys(val).includes(prop)),\n    },\n    /**\n     * add a placeholder for the search input, either a string used for every row or\n     * add separate values for main filter row and already added filters\n     * properties:\n     *     **filterRow**: for already added filter rows.\n     *     **main**: for the primary search input field.\n     *\n     *  each of these specific placeholders can again be a string or an object with different\n     *  placeholders for each search type (`text`, `chips`, `date`)\n     */\n    placeholder: {\n      type: [Object, String],\n      default: () => ({\n        filterRow: 'Add values to your filter',\n        main: 'Search and Discover',\n      }),\n      validator: val => typeof val === 'string' || ['filterRow', 'main']\n        .every(prop => Object.keys(val).includes(prop)),\n    },\n    /**\n     * specify the object property that can be used for identification of filters,\n     * autocomplete options and controlled vocabulary options.\n     *   Could be a string (used for all the mentioned objects) or an object with the following\n     *   properties:\n     *     **filter**: identifier property name in filter objects.\n     *     **autocompleteOption**: identifier property name in autocomplete option objects.\n     *     **controlledVocabularyOption**: identifier property name in controlled\n     *     vocabulary option objects.\n     */\n    identifierPropertyName: {\n      type: [Object, String],\n      default: () => ({\n        filter: 'id',\n        autocompleteOption: 'id',\n        controlledVocabularyOption: 'id',\n      }),\n    },\n    /**\n     * specify the object property that should be used for label display of filters,\n     * autocomplete options and controlled vocabulary options.\n     *   Could be a string (used for all the mentioned objects) or an object with the following\n     *   properties:\n     *     **filter**: label property name in filter objects.\n     *     **autocompleteOption**: label property name in autocomplete option objects.\n     *     **controlledVocabularyOption**: label property name in controlled\n     *     vocabulary option objects.\n     */\n    labelPropertyName: {\n      type: [Object, String],\n      default: () => ({\n        filter: 'label',\n        autocompleteOption: 'title',\n        controlledVocabularyOption: 'label',\n      }),\n    },\n    /**\n     * autocomplete results need a label, and id and a data property that contains all the actual\n     * autocomplete results for that specific category\n     * TODO: make category optional\n     */\n    autocompletePropertyNames: {\n      type: Object,\n      default: () => ({\n        label: 'label',\n        id: 'id',\n        data: 'data',\n      }),\n      // check if all the necessary attributes are included in the provided object\n      validator: val => ['id', 'label', 'data'].every(key => Object.keys(val).includes(key)),\n    },\n    /**\n     * this prop gives the option to add assistive text for screen readers.\n     * properties:\n     * **selectedOption**: text read when a selected option is focused (currently only\n     *  working for type chips with autocomplete (=freetext_allowed))\n     */\n    assistiveText: {\n      type: Object,\n      default: () => ({}),\n    },\n    /**\n     * if desired the box shadow around the search rows can be deactivated here\n     */\n    applyBoxShadow: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * use this prop to set a delay in ms before date input calendar is displayed\n     */\n    dateFieldDelay: {\n      type: Number,\n      default: 0,\n    },\n  },\n  data() {\n    return {\n      /**\n       * internal variable to handle applied filters also when set from outside\n       * @type {Filter[]}\n       */\n      appliedFiltersInt: [],\n      /**\n       * the filter used in the main search field - not added to applied filters yet\n       * @type {Filter}\n       */\n      mainFilter: null,\n      /**\n       * store the autocomplete results for each filter in this variable to have\n       * it available even when other filter was used in the meantime\n       * @type {Object[]}\n       */\n      filtersAutocompleteResults: [],\n      /**\n       * a variable storing the info for which filter autocomplete results were\n       * requested\n       * @type {number}\n       */\n      autocompleteIndex: -1,\n      originalMainFilter: null,\n    };\n  },\n  computed: {\n    /**\n     * store the loading state of every filter\n     *\n     * @returns {boolean[]}\n     */\n    filtersLoadingState() {\n      return [\n        ...this.appliedFiltersInt\n          .map((filter, index) => (this.autocompleteIndex === index)),\n        // add one at the end for main search field (not added to applied filters array yet)\n        this.autocompleteIndex === this.appliedFiltersInt.length,\n      ];\n    },\n    /**\n     * the actually displayed filters\n     * @returns {Filter[]}\n     */\n    displayedFilters() {\n      // filter filters with property hidden true\n      const displayed = [...this.filterList].filter(f => !f.hidden);\n      // sort them\n      return sort(displayed, this.labelPropertyName.filter);\n    },\n    mainFilterIndex() {\n      const lastFilterIndex = this.appliedFilters.length - 1;\n      return lastFilterIndex > 0 ? lastFilterIndex : 0;\n    },\n  },\n  watch: {\n    /**\n     * watch prop autocompleteResults to assign it to the correct filter row\n     */\n    autocompleteResults(val) {\n      // check if autocomplete is active for any field ( > -1 )\n      if (this.autocompleteIndex >= 0) {\n        // if yes set the results on the filter row active\n        this.$set(this.filtersAutocompleteResults, this.autocompleteIndex, [...val]);\n        this.autocompleteIndex = -1;\n      }\n    },\n    /**\n     * set autocomplete loading from outside\n     */\n    isLoadingIndex() {\n      // this.autocompleteIndex = val;\n    },\n    /**\n     * have appliedFilters in sync with parent to be able to set them from outside\n     */\n    appliedFiltersInt: {\n      handler(val) {\n        // check if val is actually different from prop value\n        if (JSON.stringify(val) !== JSON.stringify(this.appliedFilters.slice(1))) {\n          // if yes - inform parent\n          this.$emit('update:applied-filters', [...val, this.mainFilter]);\n        }\n      },\n      deep: true,\n    },\n    /**\n     * have appliedFilters in sync with parent to be able to set them from outside\n     */\n    appliedFilters: {\n      handler(val) {\n        // check if value is different from internal value\n        if (val\n          && JSON.stringify(val.slice(0, -1)) !== JSON.stringify(this.appliedFiltersInt)) {\n          // if yes - update internal value\n          [, ...this.appliedFiltersInt] = JSON.parse(JSON\n            .stringify([val, ...val.slice(0, -1)]));\n        }\n        // also check if main filter is different separately!\n        if (val && val.length >= 1\n          && JSON.stringify(this.mainFilter) !== JSON.stringify(val[this.mainFilterIndex])) {\n          [this.mainFilter] = JSON.parse(JSON.stringify(val.slice(-1)));\n        } else if (!val || val < 1) {\n          this.mainFilter = { ...this.defaultFilter };\n        }\n      },\n      immediate: true,\n    },\n    /**\n     * watch main filter since changes are not directly handled via update:applied-filters\n     * event and trigger search if anything changed\n     * @param {Filter} val - the updated main filter\n     */\n    mainFilter(val) {\n      // make sure mainFilter exists and has property filter_values\n      if (val && val.filter_values) {\n        // store values to compare in variables\n        const mainFilterHasData = hasData(val.filter_values);\n        // for original filter also check right here if property filter_values actually\n        // exists\n        const originalMainFilterHasData = !!this.originalMainFilter\n          && !!this.originalMainFilter.filter_values\n          && hasData(this.originalMainFilter.filter_values);\n        // now check a) if originalMainFilter exists already and\n        // b) filter itself has switched (and there are actually data to search for)\n        // c) original data and current data diverge (only one of them does not have data)\n        // d) or both have data but data are different from each other\n        if (this.originalMainFilter && (this.originalMainFilter.id !== val.id\n          || mainFilterHasData !== originalMainFilterHasData\n          || (mainFilterHasData && originalMainFilterHasData\n          && (JSON.stringify(this.originalMainFilter.filter_values\n              !== JSON.stringify(val.filter_values)))))) {\n          // if so - update original data\n          this.originalMainFilter = JSON.parse(JSON.stringify(this.mainFilter));\n          // and trigger search\n          this.search();\n        }\n      }\n      /**\n       * inform parent of changes in applied filters\n       *\n       * @event update:applied-filters\n       * @param {Filter[]} - the list of updated applied filters\n       */\n      this.$emit('update:applied-filters', [...this.appliedFiltersInt, val]);\n    },\n  },\n  created() {\n    // check if mainFilter was already set (e.g. from outside)\n    if (!this.mainFilter) {\n      // if not set default filter\n      this.mainFilter = JSON.parse(JSON.stringify(this.defaultFilter));\n    }\n    this.originalMainFilter = JSON.parse(JSON.stringify(this.mainFilter));\n  },\n  methods: {\n    /**\n     * function to add a filter row after '+' icon was triggered\n     */\n    addFilterRow({ filter, input }) {\n      // first handle remaining input and add it to filter values if necessary\n      // therefore have separate variable and assign the original values first (in case no\n      // modifications are necessary)\n      let newFilterValues = filter.type.includes('date') ? filter.filter_values\n        : [...filter.filter_values];\n      // have variable for search trigger in case additional values are added and should trigger\n      // search\n      let triggerSearch = false;\n      // now check if type is text and the current value saved in filter does not equal text input\n      if (filter.type === 'text' && input.trim() && (!filter.filter_values || !filter.filter_values.length\n        || this.mainFilter.filter_values[0] !== input.trim())) {\n        // in that case assign new value and set search trigger true\n        newFilterValues = [input];\n        triggerSearch = true;\n        // else if type is freetext chips add the value at the end of the array\n      } else if (filter.type === 'chips' && filter.freetext_allowed && input.trim()) {\n        newFilterValues = [\n          ...filter.filter_values,\n          {\n            [this.labelPropertyName.autocompleteOption]: input,\n          },\n        ];\n        // also here triger search after\n        triggerSearch = true;\n      }\n      // now finally add filter to internal filter list\n      this.appliedFiltersInt.push({\n        ...filter,\n        filter_values: newFilterValues,\n      });\n      // and reset the main filter\n      this.mainFilter = {\n        ...this.defaultFilter,\n      };\n      // and store the main filter to compare to later\n      this.originalMainFilter = JSON.parse(JSON.stringify(this.mainFilter));\n      // now check if search should be triggered\n      if (triggerSearch) {\n        this.search();\n      }\n    },\n    /**\n     * remove filter after 'x' was triggered\n     * @param {Filter} filter - the filter to remove\n     * @param {number} index - the index of the filter\n     */\n    removeFilter(filter, index) {\n      this.appliedFiltersInt.splice(index, 1);\n      // trigger search to update search results\n      this.search();\n    },\n    /**\n     * function called when a filter object within a filter row changes\n     * @param {Filter} filter - the filter that was altered\n     * @param {number} index - the index of the filter\n     */\n    updateFilter(filter, index) {\n      this.$set(this.appliedFiltersInt, index, JSON.parse(JSON.stringify(filter)));\n      // trigger search to update search results\n      this.search();\n    },\n    /**\n     * @param {string} input - the search string to autocomplete\n     * @param {Filter} filter - the filter the autocomplete was triggered for\n     * @param {number} index - the index of the filter\n     */\n    fetchAutocomplete({ input, filter }, index) {\n      if (input) {\n        // if input string present set autocomplete variable to correct filter row\n        this.autocompleteIndex = index;\n      } else {\n        // else reset the autocomplete results\n        this.$set(this.filtersAutocompleteResults, index, []);\n      }\n      // stil emit fetch-autocomplete no matter if input string present or not to give\n      // parent opportunity to also update\n      /**\n       * inform parent to fetch autocomplete data for the provided filter\n       *\n       * @event fetch-autocomplete\n       * @type {Object} - object with the following properties:\n       * @property {string} searchString - the string to autocomplete\n       * @property {Filter} filter - the filter object\n       * @property {number} index - the filter index of all filters (main and applied)\n       */\n      this.$emit('fetch-autocomplete', { searchString: input, filter, index });\n    },\n    /**\n     * search function\n     */\n    search() {\n      /**\n       * inform parent that search should be triggered\n       *\n       * @event search\n       * @param {Filter[]} - the updated list of applied filters\n       */\n      this.$emit('search', [...this.appliedFiltersInt, this.mainFilter]);\n    },\n    /**\n     * create an internal row id for unique identification of added filter rows\n     *\n     * @returns {string}\n     */\n    getRowId() {\n      // call utils function to return a \"random\" string\n      return createId();\n    },\n  },\n};\n</script>\n\n<style lang=\"scss\" scoped>\n@import \"../../styles/variables\";\n\n.base-advanced-search__filter-row {\n  margin-bottom: $spacing;\n}\n</style>\n"],"names":["_sfc_main","BaseAdvancedSearchRow","val","v","prop","key","filter","index","displayed","f","sort","lastFilterIndex","mainFilterHasData","hasData","originalMainFilterHasData","input","newFilterValues","triggerSearch","createId"],"mappings":"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"}