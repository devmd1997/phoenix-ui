{"version":3,"file":"BaseFormFieldCreator.cjs.js","sources":["../../../src/components/BaseFormFieldCreator/BaseFormFieldCreator.vue"],"sourcesContent":["<template>\n  <div>\n    <!-- TEXT FIELD -->\n    <!-- AUTOCOMPLETE -->\n    <!-- MULTILINE -->\n    <component\n      :is=\"fieldElement\"\n      v-if=\"fieldType !== 'date' && fieldType !== 'chips'\n        && fieldType !== 'chips-below' && fieldType !== 'group'\n        && fieldType !== 'boolean'\"\n      :id=\"fieldKey\"\n      :key=\"fieldKey\"\n      v-bind=\"fieldProps\"\n      :label=\"labelInt\"\n      :show-label=\"fieldProps.showLabel !== undefined ? fieldProps.showLabel : showLabel\"\n      :placeholder=\"placeholderInt\"\n      :tabs=\"fieldType === 'multiline' ? fieldProps.tabs || tabs : false\"\n      :tab-labels=\"fieldType === 'multiline'\n        ? fieldProps.tabLabels || tabs.map(tab => getI18nTerm(tab)) : false\"\n      :tabs-legend=\"fieldType === 'multiline'\n        ? fieldProps.tabsLegend || getI18nTerm('form.textTabsLegend') : false\"\n      :active-tab=\"fieldType === 'multiline' ? activeTab : false\"\n      :list=\"fieldType === 'autocomplete'\n        ? dropDownList.length ? dropDownList : fieldProps.list || [] : false\"\n      :is-loading=\"autocompleteLoading\"\n      :input=\"fieldValueInt\"\n      :field-type=\"isNumberField ? 'number' : fieldProps.fieldType || 'text'\"\n      :invalid=\"invalid || fieldProps.invalid\"\n      :required=\"required || fieldProps.required\"\n      :error-message=\"errorMessage || fieldProps.errorMessage\"\n      :validation-texts=\"fieldProps.validationTexts\n        ? (fieldProps.validationTexts[!isNumberField ? fieldType : 'text']\n          || fieldProps.validationTexts)\n        : validationTexts[!isNumberField ? fieldType : 'text']\"\n      :show-error-icon=\"showErrorIcon\"\n      :clearable=\"clearable\"\n      :min-length=\"field.minLength || fieldProps.minLength\"\n      :max-length=\"field.maxLength || fieldProps.maxLength\"\n      :min=\"typeof formFieldXAttrs.min !== 'undefined' ? formFieldXAttrs.min : fieldProps.min\"\n      :max=\"typeof formFieldXAttrs.max !== 'undefined' ? formFieldXAttrs.max : fieldProps.max\"\n      :decimals=\"allowedDecimals\"\n      :decimal-separator=\"fieldProps.decimalSeparator || language === 'de' ? ',' : '.'\"\n      @keydown.enter=\"onEnter\"\n      @input=\"setInputValue($event)\"\n      @fetch-dropdown-entries=\"$emit('fetch-autocomplete', {\n        value: $event,\n        name: field.name,\n        source: formFieldXAttrs.source,\n      })\">\n      <template\n        #label-addition>\n        <!-- @slot Slot to allow for additional elements on the right side of the label row <div> (e.g. language tabs))\n          @binding {string} fieldName -->\n        <slot\n          :field-name=\"field.name\"\n          name=\"label-addition\" />\n        <BaseDropDown\n          v-if=\"fieldType === 'multiline' && field.items\n            && field.items.properties && field.items.properties.type\"\n          :id=\"fieldKey\"\n          :selected-option=\"fieldValueInt && fieldValueInt.type && fieldValueInt.type.source\n            ? fieldValueInt.type : textTypeDefault\"\n          :options=\"textTypeOptions\"\n          :label=\"getI18nTerm('form.texttype')\"\n          :language=\"language\"\n          value-prop=\"source\"\n          class=\"base-form-field-creator__multiline-dropdown\"\n          @value-selected=\"setMultilineDropDown\" />\n      </template>\n      <template #pre-input-field>\n        <!-- @slot slot to add elements within the form field but in a row before the actual input field. for an example see [BaseInput](BaseInput)\n          @binding {string} fieldName - the name of the current field for identification purposes -->\n        <slot\n          :field-name=\"field.name\"\n          name=\"pre-input-field\" />\n      </template>\n      <template\n        #input-field-addition-before>\n        <!-- @slot Slot to allow for additional elements in the input field <div> (before <input>)\n          @binding {string} fieldName - the name of the current field for identification purposes -->\n        <slot\n          :field-name=\"field.name\"\n          name=\"input-field-addition-before\" />\n      </template>\n      <template #input-field-inline-before>\n        <!-- @slot to add elements directly inline before the input (contrary to input-field-addition-before this does not wrap). for an example see [BaseInput](BaseInput)\n          @binding {string} fieldName - the name of the current field for identification purposes-->\n        <slot\n          :field-name=\"field.name\"\n          name=\"input-field-inline-before\" />\n      </template>\n      <template #input-field-addition-after>\n        <!-- @slot for adding elements after input\n          @binding {string} fieldName - the name of the current field for identification purposes -->\n        <slot\n          :field-name=\"field.name\"\n          name=\"input-field-addition-after\" />\n      </template>\n      <template #post-input-field>\n        <!-- @slot for adding elements at the end covering the whole height\n          @binding {string} fieldName - the name of the current field for identification purposes -->\n        <slot\n          :field-name=\"field.name\"\n          name=\"post-input-field\" />\n      </template>\n      <template #error-icon>\n        <!-- @slot use a custom icon instead of standard error/warning icon -->\n        <slot\n          name=\"error-icon\" />\n      </template>\n      <template #remove-icon>\n        <!-- @slot use a custom icon instead of standard remove icon -->\n        <slot\n          name=\"remove-icon\" />\n      </template>\n      <template #below-input>\n        <!-- @slot below-input slot added to e.g. add drop down\n          @binding {string} fieldName - the name of the current field for identification purposes -->\n        <slot\n          :field-name=\"field.name\"\n          name=\"below-input\" />\n      </template>\n    </component>\n\n    <!-- DATE FIELD -->\n    <fieldset\n      v-else-if=\"fieldType === 'date'\"\n      class=\"base-form-field-creator__date-fieldset\">\n      <div class=\"base-form-field-creator__date-field-wrapper\">\n        <BaseDateInput\n          :id=\"fieldKey\"\n          :key=\"fieldKey + '_date'\"\n          v-model=\"fieldValueInt\"\n          v-bind=\"fieldProps\"\n          :label=\"labelInt\"\n          :show-label=\"fieldProps.showLabel !== undefined ? fieldProps.showLabel : showLabel\"\n          :placeholder=\"placeholderInt\"\n          :range-separator=\"fieldProps.rangeSeparator || getI18nTerm('form.until')\"\n          :format=\"formFieldXAttrs.date_format || fieldProps.format\"\n          :type=\"dateType.includes('timerange') ? dateType.includes('daterange')\n            ? 'daterange' : 'single' : dateType\"\n          :date-format-labels=\"fieldProps.dateFormatLabels\n            || {\n              date: getI18nTerm('form.date'),\n              month: getI18nTerm('form.month'),\n              year: getI18nTerm('form.year'),\n            }\"\n          :format-tabs-legend=\"fieldProps.formatTabsLegend || getI18nTerm('form.dateTabsLegend')\"\n          :language=\"language\"\n          :invalid=\"invalid || fieldProps.invalid\"\n          :required=\"required || fieldProps.required\"\n          :error-message=\"errorMessage || fieldProps.errorMessage\"\n          class=\"base-form-field-creator__date-field\">\n          <template\n            #label-addition>\n            <!-- @slot Slot to allow for additional elements on the right side of the label row <div> (e.g. language tabs))\n              @binding {string} fieldName -->\n            <slot\n              :field-name=\"field.name\"\n              name=\"label-addition\" />\n          </template>\n          <template #pre-input-field>\n            <!-- @slot slot to add elements within the form field but in a row before the actual input field. for an example see [BaseInput](BaseInput)\n              @binding {string} fieldName - the name of the current field for identification purposes -->\n            <slot\n              :field-name=\"field.name\"\n              name=\"pre-input-field\" />\n          </template>\n          <template\n            #input-field-addition-before>\n            <!-- @slot Slot to allow for additional elements in the input field <div> (before <input>)\n              @binding {string} fieldName - the name of the current field for identification purposes -->\n            <slot\n              :field-name=\"field.name\"\n              name=\"input-field-addition-before\" />\n          </template>\n          <template #input-field-inline-before>\n            <!-- @slot to add elements directly inline before the input (contrary to input-field-addition-before this does not wrap). for an example see [BaseInput](BaseInput)\n              @binding {string} fieldName - the name of the current field for identification purposes -->\n            <slot\n              :field-name=\"field.name\"\n              name=\"input-field-inline-before\" />\n          </template>\n          <template #input-field-addition-after>\n            <!-- @slot for adding elements after input\n              @binding {string} fieldName - the name of the current field for identification purposes -->\n            <slot\n              :field-name=\"field.name\"\n              name=\"input-field-addition-after\" />\n          </template>\n          <template #post-input-field>\n            <!-- @slot for adding elements at the end covering the whole height\n              @binding {string} fieldName - the name of the current field for identification purposes -->\n            <slot\n              :field-name=\"field.name\"\n              name=\"post-input-field\" />\n          </template>\n          <template #error-icon>\n            <!-- @slot use a custom icon instead of standard error/warning icon -->\n            <slot\n              name=\"error-icon\" />\n          </template>\n          <template #remove-icon>\n            <!-- @slot use a custom icon instead of standard remove icon -->\n            <slot\n              name=\"remove-icon\" />\n          </template>\n          <template #below-input>\n            <!-- @slot below-input slot added to e.g. add drop down\n              @binding {string} fieldName - the name of the current field for identification purposes -->\n            <slot\n              :field-name=\"field.name\"\n              name=\"below-input\" />\n          </template>\n        </BaseDateInput>\n        <BaseDateInput\n          v-if=\"dateType.includes('timerange')\"\n          :id=\"fieldKey\"\n          :key=\"fieldKey + '_time'\"\n          v-model=\"fieldValueInt\"\n          v-bind=\"fieldProps\"\n          :label=\"field.properties.time_from.title\"\n          :show-label=\"false\"\n          :placeholder=\"placeholderInt.time\"\n          :range-separator=\"fieldProps.rangeSeparator || getI18nTerm('form.until')\"\n          :invalid=\"invalid || fieldProps.invalid\"\n          :required=\"required || fieldProps.required\"\n          :error-message=\"errorMessage || fieldProps.errorMessage\"\n          type=\"timerange\"\n          class=\"base-form-field-creator__date-field\" />\n      </div>\n    </fieldset>\n\n    <!-- CHIPS INPUT -->\n    <component\n      :is=\"fieldElement\"\n      v-else-if=\"fieldType === 'chips' || fieldType === 'chips-below'\"\n      :id=\"fieldKey\"\n      :key=\"fieldKey\"\n      v-model=\"fieldValueInt\"\n      v-bind=\"fieldProps\"\n      :placeholder=\"placeholderInt\"\n      :label=\"labelInt\"\n      :show-label=\"fieldProps.showLabel !== undefined ? fieldProps.showLabel : showLabel\"\n      :list=\"dropDownList.length ? dropDownList : fieldProps.list || []\"\n      :allow-dynamic-drop-down-entries=\"formFieldXAttrs.dynamic_autosuggest\n        || !!fieldProps.allowDynamicDropDownEntries\"\n      :allow-multiple-entries=\"!isChipsSingleSelect\"\n      :allow-unknown-entries=\"formFieldXAttrs.allow_unknown_entries\n        || !!fieldProps.allowUnknownEntries\"\n      :draggable=\"!!fieldProps.draggable || !isChipsSingleSelect\"\n      :hoverbox-content=\"hoverBoxData || fieldProps.hoverBoxData\"\n      :sortable=\"field.name === 'keywords' || formFieldXAttrs.sortable\n        || !!fieldProps.sortable\"\n      :is-loading=\"autocompleteLoading\"\n      :sort-text=\"fieldProps.sortText || sortText\"\n      :sort-name=\"fieldProps.sortName || isContributorOrEquivalent\"\n      :language=\"formFieldXAttrs.set_label_language\n        || fieldType === 'chips-below' ? language : ''\"\n      :drop-down-no-options-info=\"fieldProps.dropDownNoOptionsInfo || getI18nTerm('form.noMatch')\"\n      :additional-prop-options=\"fieldType === 'chips-below' ? secondaryDropdown : false\"\n      :additional-prop-placeholder=\"fieldType === 'chips-below'\n        ? fieldProps.additionalPropPlaceholder || getI18nTerm('form.selectRoles') : false\"\n      :additional-property-name=\"fieldType === 'chips-below'\n        ? fieldProps.additionalPropertyName || 'roles' : false\"\n      :invalid=\"invalid || fieldProps.invalid\"\n      :required=\"required || fieldProps.required\"\n      :error-message=\"errorMessage || fieldProps.errorMessage\"\n      :show-error-icon=\"showErrorIcon\"\n      :identifier-property-name=\"fieldProps.identifierPropertyName || identifierPropertyName\"\n      :label-property-name=\"fieldProps.labelPropertyName || labelPropertyName\"\n      @fetch-dropdown-entries=\"fetchAutocomplete\"\n      @input=\"textInput = $event\"\n      @hoverbox-active=\"fetchBoxData\">\n      <template\n        #drop-down-entry=\"props\">\n        <span>\n          {{ getLabel(props.item.label) }}\n        </span>\n        <span class=\"base-form-field-creator__chips-dropdown-second\">\n          {{ props.item.additional }}\n        </span>\n        <span class=\"base-form-field-creator__chips-dropdown-third\">\n          {{ props.item.source_name }}\n        </span>\n      </template>\n      <template #no-options>\n        <span v-if=\"formFieldXAttrs.dynamic_autosuggest && !fieldInput\">\n          {{ getI18nTerm('form.startTyping') }}\n        </span>\n        <span v-else-if=\"!formFieldXAttrs.dynamic_autosuggest && textInput\">\n          {{ getI18nTerm('form.noMatch') }}\n        </span>\n        <span v-else-if=\"fieldInput && !fetchingData && !autocompleteLoading\">\n          {{ getI18nTerm('form.noResult') }}\n        </span>\n        <span v-else>\n          {{ getI18nTerm('form.fetchingResults') }}\n        </span>\n      </template>\n      <template\n        #label-addition>\n        <!-- @slot Slot to allow for additional elements on the right side of the label row <div> (e.g. language tabs))\n          @binding {string} fieldName - the name of the current field for identification purposes -->\n        <slot\n          :field-name=\"field.name\"\n          name=\"label-addition\" />\n      </template>\n      <template #pre-input-field>\n        <!-- @slot slot to add elements within the form field but in a row before the actual input field. for an example see [BaseInput](BaseInput)\n          @binding {string} fieldName - the name of the current field for identification purposes -->\n        <slot\n          :field-name=\"field.name\"\n          name=\"pre-input-field\" />\n      </template>\n      <template\n        #input-field-addition-before>\n        <!-- @slot Slot to allow for additional elements in the input field <div> (before <input>)\n          @binding {string} fieldName - the name of the current field for identification purposes -->\n        <slot\n          :field-name=\"field.name\"\n          name=\"input-field-addition-before\" />\n      </template>\n      <template #input-field-inline-before>\n        <!-- @slot to add elements directly inline before the input (contrary to input-field-addition-before this does not wrap). for an example see [BaseInput](BaseInput)\n          @binding {string} fieldName - the name of the current field for identification purposes -->\n        <slot\n          :field-name=\"field.name\"\n          name=\"input-field-inline-before\" />\n      </template>\n      <template #input-field-addition-after>\n        <!-- @slot for adding elements after input\n          @binding {string} fieldName - the name of the current field for identification purposes -->\n        <slot\n          :field-name=\"field.name\"\n          name=\"input-field-addition-after\" />\n      </template>\n      <template #post-input-field>\n        <!-- @slot for adding elements at the end covering the whole height\n          @binding {string} fieldName - the name of the current field for identification purposes -->\n        <slot\n          :field-name=\"field.name\"\n          name=\"post-input-field\" />\n      </template>\n      <template #error-icon>\n        <!-- @slot use a custom icon instead of standard error/warning icon -->\n        <slot\n          name=\"error-icon\" />\n      </template>\n      <template #remove-icon>\n        <!-- @slot use a custom icon instead of standard remove icon -->\n        <slot\n          :field-name=\"field.name\" />\n      </template>\n      <template #below-input>\n        <!-- @slot below-input slot added to e.g. add drop down\n          @binding {string} fieldName - the name of the current field for identification purposes -->\n        <slot\n          :field-name=\"field.name\"\n          name=\"below-input\" />\n      </template>\n    </component>\n\n    <!-- FIELD GROUPS -->\n    <div\n      v-else-if=\"fieldType === 'group'\"\n      :key=\"fieldKey\"\n      class=\"base-form-field-creator__field-array\">\n      <div\n        v-if=\"formFieldXAttrs.show_label\"\n        class=\"base-form-field-creator__field-array-label\">\n        {{ `${labelInt}:` }}\n      </div>\n      <div\n        :key=\"fieldKey\"\n        class=\"base-form-field-creator__subform-wrapper\">\n        <BaseForm\n          :form-field-json=\"groupFormFields\"\n          :value-list=\"fieldValueInt\"\n          :form-id=\"fieldKey + '_' + field.name\"\n          :field-props=\"fieldProps\"\n          :drop-down-lists=\"fieldGroupDropDownLists\"\n          v-bind=\"fieldGroupParams\"\n          class=\"base-form-field-creator__subform\"\n          @values-changed=\"$emit('field-value-changed', $event)\"\n          @fetch-autocomplete=\"subFormFetchAutocomplete\">\n          <template\n            #label-addition=\"{ fieldName, groupNames }\">\n            <!-- @slot Slot to allow for additional elements on the right side of the label row <div> (e.g. language tabs))\n              @binding {string} fieldName - the name of the current field for identification purposes\n              @binding {string[]} groupNames - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              :field-name=\"fieldName\"\n              :group-names=\"(groupNames ? groupNames : []).concat(field.name)\"\n              name=\"label-addition\" />\n          </template>\n          <template #pre-input-field=\"{ fieldName, groupNames }\">\n            <!-- @slot slot to add elements within the form field but in a row before the actual input field. for an example see [BaseInput](BaseInput)\n              @binding {string} fieldName - the name of the current field for identification purposes\n              @binding {string[]} groupNames - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              :field-name=\"fieldName\"\n              :group-names=\"(groupNames ? groupNames : []).concat(field.name)\"\n              name=\"pre-input-field\" />\n          </template>\n          <template\n            #input-field-addition-before=\"{ fieldName, groupNames }\">\n            <!-- @slot Slot to allow for additional elements in the input field <div> (before <input>)\n              @binding {string} fieldName - the name of the current field for identification purposes\n              @binding {string[]} groupNames - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              :field-name=\"fieldName\"\n              :group-names=\"(groupNames ? groupNames : []).concat(field.name)\"\n              name=\"input-field-addition-before\" />\n          </template>\n          <template #input-field-inline-before=\"{ fieldName, groupNames }\">\n            <!-- @slot to add elements directly inline before the input (contrary to input-field-addition-before this does not wrap). for an example see [BaseInput](BaseInput)\n              @binding {string} fieldName - the name of the current field for identification purposes\n              @binding {string[]} groupNames - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              :field-name=\"fieldName\"\n              :group-names=\"(groupNames ? groupNames : []).concat(field.name)\"\n              name=\"input-field-inline-before\" />\n          </template>\n          <template #input-field-addition-after=\"{ fieldName, groupNames }\">\n            <!-- @slot for adding elements after input\n              @binding {string} fieldName - the name of the current field for identification purposes\n              @binding {string[]} groupNames - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              :field-name=\"fieldName\"\n              :group-names=\"(groupNames ? groupNames : []).concat(field.name)\"\n              name=\"input-field-addition-after\" />\n          </template>\n          <template #post-input-field=\"{ fieldName, groupNames }\">\n            <!-- @slot for adding elements at the end covering the whole height\n              @binding {string} fieldName - the name of the current field for identification purposes\n              @binding {string[]} groupNames - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              :field-name=\"fieldName\"\n              :group-names=\"(groupNames ? groupNames : []).concat(field.name)\"\n              name=\"post-input-field\" />\n          </template>\n          <template #error-icon>\n            <!-- @slot use a custom icon instead of standard error/warning icon -->\n            <slot\n              name=\"error-icon\" />\n          </template>\n          <template #remove-icon>\n            <!-- @slot use a custom icon instead of standard remove icon -->\n            <slot\n              name=\"remove-icon\" />\n          </template>\n          <template #below-input=\"{ fieldName, groupNames }\">\n            <!-- @slot below-input slot added to e.g. add drop down\n              @binding {string} fieldName - the name of the current field for identification purposes\n              @binding {string[]} groupNames - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              :field-name=\"fieldName\"\n              :group-names=\"(groupNames ? groupNames : []).concat(field.name)\"\n              name=\"below-input\" />\n          </template>\n        </BaseForm>\n      </div>\n    </div>\n\n    <!-- FIELD BOOLEAN -->\n    <template\n      v-else-if=\"fieldType === 'boolean'\">\n      <BaseToggle\n        v-bind=\"fieldProps\"\n        :name=\"fieldKey\"\n        :label=\"labelInt\"\n        :checked=\"fieldValue\"\n        :bind-slot-to-state=\"fieldProps.bindSlotToState || true\"\n        class=\"base-form-field-creator__toggle\"\n        @clicked=\"$emit('field-value-changed', $event)\">\n        <BaseLink\n          v-if=\"formFieldXAttrs.subtext && formFieldXAttrs.subtext.value\"\n          :source=\"formFieldXAttrs.subtext.source || ''\"\n          :url=\"formFieldXAttrs.subtext.url || ''\"\n          :value=\"formFieldXAttrs.subtext.value\" />\n      </BaseToggle>\n    </template>\n  </div>\n</template>\n\n<script>\nimport i18n from '../../mixins/i18n';\n\n/**\n * A component for form field creation via [openAPI](https://spec.openapis.org/oas/v3.1.0/) standard\n */\n\nexport default {\n  name: 'BaseFormFieldCreator',\n  components: {\n    BaseDropDown: () => import('../BaseDropDown/BaseDropDown').then(m => m.default || m),\n    BaseDateInput: () => import('../BaseDateInput/BaseDateInput').then(m => m.default || m),\n    BaseForm: () => import('../BaseForm/BaseForm').then(m => m.default || m),\n    BaseToggle: () => import('../BaseToggle/BaseToggle').then(m => m.default || m),\n    BaseLink: () => import('../BaseLink/BaseLink').then(m => m.default || m),\n  },\n  mixins: [i18n],\n  props: {\n    /**\n     * a key to uniquely identify the field\n     */\n    fieldKey: {\n      type: [Number, String],\n      required: true,\n    },\n    /**\n     * field information as provided in [openAPI](https://spec.openapis.org/oas/v3.1.0#schema-object) standard\n     */\n    field: {\n      type: Object,\n      required: true,\n    },\n    /**\n     * the field value\n     */\n    fieldValue: {\n      type: [Object, String, Array, Date, Number, Boolean],\n      required: true,\n    },\n    /**\n     * add properties any input field can take and set values - find the possible variables at the\n     * respective input components:\n     * [BaseInput](BaseInput)\n     * [BaseAutocompleteInput](BaseAutocompleteInput)\n     * [BaseMultilineTextInput](BaseMultilineTextInput)\n     * [BaseChipsInput](BaseChipsInput)\n     * [BaseChipsBelow](BaseChipsBelow)\n     * [BaseDateInput](BaseDateInput)\n     * [BaseToggle](BaseToggle)\n     *\n     * **Caveat**: this means several input field properties are settable via separate props as well\n     * as via `fieldProps` (e.g. `language`, `required`, `sortText`) the logic here is the following:\n     *  separate props will have priority over `fieldProps` values **unless** the separate\n     *  prop has a default value other than ones evaluating to `false` (boolean false,\n     *  empty string).\n     *  Field props that are set via `x-attrs` (e.g. `allowUnknownEntries`) in the OpenAPI definition\n     *  have priority over `fieldProps` set values.\n     *  Fields for which a unified appearance makes sense (e.g. `clearable`, `showErrorIcon`) or that\n     *  are modified internally (e.g. `input`, `selectedList`) might not be settable\n     *  via `fieldProps`.\n     */\n    fieldProps: {\n      type: Object,\n      default: () => ({}),\n    },\n    /**\n     * a label for the field\n     */\n    label: {\n      type: String,\n      default: '',\n    },\n    /**\n     * define if field label should be shown\n     */\n    showLabel: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * a placeholder for the field\n     * per default the placeholder attribute in OpenAPI `x-attrs` field will be used\n     * (no need to specify that)\n     */\n    placeholder: {\n      type: [String, Object],\n      default: '',\n    },\n    /**\n     * provide an options list for `autocomplete`, `chips` or `chips-below` fields\n     * for field type `group` provide a nested object with field names\n     * as properties and an array for each field to ensure the correct options are assigned\n     * even if field names within different groups are identical\n     */\n    dropDownList: {\n      type: [Array, Object],\n      default: () => [],\n    },\n    /**\n     * provide a second options list (needed e.g. for texts field (text type) or\n     * contributors field (roles)\n     */\n    secondaryDropdown: {\n      type: Array,\n      default: () => [],\n    },\n    /**\n     * provide data for elements that have a hover box (chips)\n     */\n    hoverBoxData: {\n      type: Object,\n      default: () => ({}),\n    },\n    /**\n     * possibility to steer field loading (`chips`, `autocomplete`) from outside\n     */\n    autocompleteLoading: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * set the current language\n     */\n    language: {\n      type: String,\n      default: 'en',\n    },\n    /**\n     * provide available locales\n     */\n    availableLocales: {\n      type: Array,\n      default: () => [],\n    },\n    /**\n     * set a sorting text\n     */\n    sortText: {\n      type: String,\n      default: 'Sort A - Z',\n    },\n    /**\n     * pass down all necessary options for potential subform.\n     *   see [BaseForm props](BaseForm)\n     */\n    fieldGroupParams: {\n      type: Object,\n      default: () => ({}),\n    },\n    /**\n     * mark as required field (currently only used for `aria-required` attribute)\n     */\n    required: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * mark the form field as invalid and ideally also provide an error message\n     * to display below the form field.\n     * for an example see [BaseInput](BaseInput)\n     */\n    invalid: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * add an error message to be displayed below form field if field is invalid.\n     * for an example see [BaseInput](BaseInput)\n     */\n    errorMessage: {\n      type: String,\n      default: '',\n    },\n    /**\n     * define validation texts to be displayed below form field if input is invalid.\n     * for an example see [BaseInput](BaseInput)\n     */\n    validationTexts: {\n      type: Object,\n      default: () => ({\n        text: {\n          min: 'Value must be greater than or equal to {value}.',\n          max: 'Value must be less than or equal to {value}.',\n          minLength: 'Text must be at least {value} character(s) long.',\n          maxLength: 'Text cannot be longer than {value} characters.',\n        },\n      }),\n      // checking if all necessary properties are part of the provided object\n      validator: val => ['text'].every(prop => Object.keys(val).includes(prop))\n        && ['min', 'max', 'minLength', 'maxLength']\n          .every(prop => Object.keys(val.text).includes(prop)),\n    },\n    /**\n     * define if error icon should be shown.\n     * for an example see [BaseInput](BaseInput)\n     */\n    showErrorIcon: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * if `true` a remove icon will be shown allowing to remove\n     * all input at once.\n     * for an example see [BaseInput](BaseInput)\n     */\n    clearable: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * specify the object property that should be used as identifier\n     */\n    identifierPropertyName: {\n      type: String,\n      default: 'source',\n    },\n    /**\n     * specify the object property that should be used as value to be displayed\n     */\n    labelPropertyName: {\n      type: String,\n      default: 'label',\n    },\n  },\n  data() {\n    return {\n      /**\n       * internal representation of field value\n       * @type {any}\n       */\n      fieldValueInt: null,\n      /**\n       * variable for current text input in chips fields\n       * @type {string}\n       */\n      textInput: '',\n      /**\n       * internal loading indicator\n       * @type {boolean}\n       */\n      fetchingData: false,\n      /**\n       * internal active tab for multiline text field\n       * @type {string}\n       */\n      activeTab: '',\n    };\n  },\n  computed: {\n    /**\n     * import the relevant component\n     * @returns {(function(): *)|null}\n     */\n    fieldElement() {\n      if (this.fieldType === 'text' || this.fieldType === 'integer' || this.fieldType === 'float') {\n        return () => import('../BaseInput/BaseInput');\n      } if (this.fieldType === 'multiline') {\n        return () => import('../BaseMultilineTextInput/BaseMultilineTextInput');\n      } if (this.fieldType === 'autocomplete') {\n        return () => import('../BaseAutocompleteInput/BaseAutocompleteInput');\n      } if (this.fieldType === 'chips') {\n        return () => import('../BaseChipsInput/BaseChipsInput');\n      } if (this.fieldType === 'chips-below') {\n        return () => import('../BaseChipsBelow/BaseChipsBelow');\n      }\n      return null;\n    },\n    /**\n     * check which date field type was provided and set type accordingly\n     * @returns {string}\n     */\n    dateType() {\n      // check if date is an Object with properties or just string (= single date)\n      // also need to check items in case date field is repeatable\n      const props = this.field.properties || (this.field.items && this.field.items.properties)\n        ? Object.keys(this.field.properties || this.field.items.properties) : [];\n      if (!this.field.properties && (!this.field.items || !this.field.items.properties)) {\n        return 'single';\n      }\n      if (props.includes('date_to') && props.includes('time_to')) {\n        return 'daterangetimerange';\n      }\n      if (props.includes('date') && props.includes('time_to')) {\n        return 'datetimerange';\n      }\n      if (props.includes('time')) {\n        return 'datetime';\n      }\n      if (props.includes('date_to')) {\n        return 'daterange';\n      }\n      return 'single';\n    },\n    /**\n     * get field properties from swagger info - necessary for subforms\n     * @returns {Object}\n     */\n    groupFormFields() {\n      // check if field group is a list (=repeatable) or not\n      if (this.field.type === 'array') {\n        return this.field.items.properties;\n      }\n      return this.field.properties;\n    },\n    /**\n     * function to check if dropdowns for field groups are nested. Nesting was necessary\n     * to ensure every field group gets their own dropdown even if field names are identical.\n     * For backwards compatibility keep using direct base level fieldName array as fallback.\n     * @returns {{ [fieldName]: Object[] }}\n     */\n    fieldGroupDropDownLists() {\n      // get field name\n      const fieldName = this.field.name;\n      // get parent BaseForm $props.dropDownLists that were passed to BaseFormFieldCreator\n      // as fieldGroupParams\n      const { dropDownLists } = this.fieldGroupParams;\n      // check if the nested object with the fieldName exists, if not fall back to use\n      // field name directly\n      return dropDownLists && dropDownLists[fieldName]\n        ? dropDownLists[fieldName] : dropDownLists;\n    },\n    formFieldXAttrs() {\n      // x-attrs should exist however just in case if not return an empty object\n      // so that ['x-attrs'][xAttrProperty] does not throw errors\n      return this.field['x-attrs'] || {};\n    },\n    // the type default for texts field\n    textTypeDefault() {\n      return {\n        // map the language specific labels for no value selected to the default\n        [this.labelPropertyName]: this.setLangLabels('form.noTextType', this.availableLocales),\n        [this.identifierPropertyName]: '',\n      };\n    },\n    // compute the texts type drop down list specific for texts\n    textTypeOptions() {\n      return [this.textTypeDefault].concat(this.secondaryDropdown);\n    },\n    // for chips input fields - check if it is a contributors field\n    isContributorOrEquivalent() {\n      return this.field.name === 'contributors'\n        || this.formFieldXAttrs.equivalent === 'contributors';\n    },\n    // to determine text display for chips input\n    fieldInput() {\n      return this.textInput && this.textInput.length > 2;\n    },\n    // check if chips input is a single select field\n    isChipsSingleSelect() {\n      return (this.fieldType\n        && this.fieldType.includes('chips')\n        && this.field.type === 'object');\n    },\n    // check if label was specified - if not defer from title or check if there is a localized term\n    labelInt() {\n      if (this.label || this.fieldProps.label) {\n        return this.label || this.fieldProps.label;\n      }\n      return this.field.title || this.getI18nTerm(`form.${this.field.name}` || this.field.name);\n    },\n    // check if placeholder was specified - if not defer from\n    // title or check if there is a localized term\n    placeholderInt() {\n      if (this.placeholder || this.fieldProps.placeholder) {\n        return this.placeholder || this.fieldProps.placeholder;\n      }\n      const internalPlaceholder = this.formFieldXAttrs.placeholder || '';\n      return internalPlaceholder || `${this.hasI18n ? this.getI18nTerm('form.select') : 'Select'} ${this.labelInt}`;\n    },\n    // compute field type\n    fieldType() {\n      return this.formFieldXAttrs.field_type || 'text';\n    },\n    tabs() {\n      if (this.field.items && this.field.items.properties && this.field.items.properties.data\n        && this.field.items.properties.data.items\n        && this.field.items.properties.data.items.properties\n        && this.field.items.properties.data.items.properties.language) {\n        return Object.keys(this.field.items.properties\n          .data.items.properties\n          .language.properties\n          .label.properties).filter(lang => this.availableLocales.includes(lang));\n      }\n      return [];\n    },\n    /**\n     * check if field is either type integer of float\n     * @returns {boolean}\n     */\n    isNumberField() {\n      // get OpenAPI json field type and check if its a repeatable field (array)\n      const openAPIFieldType = this.field.items ? this.field.items.type : this.field.type;\n      // valid OpenAPI number field types are 'integer' and 'number'\n      return ['integer', 'number'].includes(openAPIFieldType)\n        // include 'text' here for backwards compatibility\n        && ['integer', 'float', 'text'].includes(this.fieldType);\n    },\n    /**\n     * check allowed number of decimals\n     * @returns {number|null}\n     */\n    allowedDecimals() {\n      // check if decimals were configured with priority for x-attrs\n      const decimals = this.formFieldXAttrs.decimals || this.fieldProps.decimals;\n      // get OpenAPI definition field type and also consider repeatable fields\n      const numberFieldType = this.field.type === 'array' ? this.field.items.type : this.field.type;\n      // get the OpenAPI definition field format\n      const numberFieldFormat = this.field.type === 'array' ? this.field.items.format : this.field.format;\n      // for OpenAPI data type 'number', that have format specified allow endless decimals\n      // only 'float' and 'double' are defined in OpenAPI but it is an \"open string-valued property\"\n      // so adding 'decimal' since backend model has data type Decimal\n      if ((numberFieldType === 'number' && ['float', 'double', 'decimal'].includes(numberFieldFormat))\n        && !(decimals || decimals === 0)) {\n        return -1;\n      }\n      // for type float and decimals set limit to decimals\n      if ((numberFieldType === 'number' || this.fieldProps.fieldType === 'number')\n        && ['float', 'double', 'decimal'].includes(numberFieldFormat) && (decimals || decimals === 0)) {\n        return decimals;\n      }\n      // for type integer prevent decimals\n      if (numberFieldType === 'integer' || this.fieldProps.fieldType === 'number' || decimals === 0) {\n        return 0;\n      }\n      return null;\n    },\n  },\n  watch: {\n    fieldValue: {\n      handler(val) {\n        if (JSON.stringify(this.fieldValueInt) !== JSON.stringify(val)) {\n          this.setFieldValue(val);\n          const tabs = this.fieldProps.tabs || this.tabs;\n          if (tabs && tabs.length) {\n            this.activeTab = this.setActiveTab();\n          }\n        }\n      },\n      immediate: true,\n    },\n    fieldValueInt: {\n      handler(val) {\n        // prevent event being fired when change comes from outside\n        if (val !== undefined && JSON.stringify(this.fieldValue) !== JSON.stringify(val)) {\n          /**\n           * Event emitted when field value changed internally\n           *\n           * @event field-value-changed\n           * @property {Object, Array, String, Number} - the changed field value\n           */\n          this.$emit('field-value-changed', val);\n        }\n      },\n      deep: true,\n    },\n    dropDownList: {\n      handler() {\n        this.fetchingData = false;\n      },\n      deep: true,\n    },\n  },\n  mounted() {\n    // the first time the field is mounted set the initial field value\n    // and tabs (if applicable)\n    this.setFieldValue(this.fieldValue);\n    if (this.tabs && this.tabs.length) {\n      this.activeTab = this.setActiveTab();\n    }\n  },\n  methods: {\n    // function for setting internal field value breaking all potential links to\n    // value passed from parent\n    setFieldValue(val) {\n      if (val && typeof val === 'object') {\n        // check if it is array\n        if (val.length >= 0) {\n          this.fieldValueInt = [].concat(JSON.parse(JSON.stringify(val)));\n          // else assume it is object\n        } else {\n          this.fieldValueInt = { ...JSON.parse(JSON.stringify(val)) };\n        }\n        // or simply assign directly if string\n      } else {\n        this.fieldValueInt = val;\n      }\n    },\n    // as above but specific for multiline text input field\n    setInputValue(val) {\n      if (!val || typeof val === 'string' || typeof val === 'number') {\n        this.fieldValueInt = val;\n      } else {\n        this.fieldValueInt = { ...this.fieldValueInt, ...JSON.parse(JSON.stringify(val)) };\n      }\n    },\n    /**\n     * called by chips input autocomplete\n     * @param {Object} event - the spread object emitted\n     * @property {string} event.value - the string in the input field\n     */\n    fetchAutocomplete({ value }) {\n      this.fetchingData = true;\n      this.textInput = value;\n      /**\n       * Event emitted for text input on autocomplete fields (field types `autocomplete`,\n       * `chips`, `chips-below`)\n       *\n       * @event fetch-autocomplete\n       * @property {string} value - the string to autocomplete\n       * @property {string} name - the name of the field\n       * @property {string} source - the url to request the data from\n       * @property {?string} equivalent - string specified for related fields e.g. for contributor roles equivalent is 'contributor'\n       * @property {?string[]} parentFields - in case the autocomplete event originates from a subform the subform id's (field property names) are specififed in this array (most nested property last)\n       */\n      this.$emit('fetch-autocomplete', {\n        value,\n        name: this.field.name,\n        source: this.formFieldXAttrs.source,\n        equivalent: this.formFieldXAttrs.equivalent,\n      });\n    },\n    /**\n     * called from subform - already contains all the information to pass\n     * to parent (see above for details)\n     * @param {Object} autocompleteInformation\n     */\n    subFormFetchAutocomplete(autocompleteInformation) {\n      const parentFieldsArary = autocompleteInformation.parentFields || [];\n      parentFieldsArary.unshift(this.field.name);\n      this.$emit('fetch-autocomplete', {\n        ...autocompleteInformation,\n        parentFields: parentFieldsArary,\n      });\n    },\n    /**\n     * function getting label from all possible label structures (lang object (--> get\n     // correct lang) or simple string)\n     * @param {string|Object} value - the language string or object - if object it contains\n     * all the languages e.g. { de: '', en: '' }\n     * @returns {string}\n     */\n    getLabel(value) {\n      return this.getLangLabel(value, this.language, true);\n    },\n    // functionality for multiline text input with language tabs\n    setActiveTab() {\n      // check which locales have content\n      const localesWithContent = this.availableLocales.filter(lang => !!this.fieldValueInt[lang]);\n      // if none of the locales has content or the current locale has content\n      // - return current locale - else first alternative\n      return !localesWithContent.length || this.fieldValueInt[this.language]\n        ? this.language : localesWithContent[0];\n    },\n    // function for mulitline text input to set drop down field correctly\n    setMultilineDropDown(val) {\n      // set texts type value if present - otherwise set empty\n      this.$set(this.fieldValueInt, 'type', val.source ? val : null);\n    },\n    // prevent default action for everything except multiline\n    onEnter(event) {\n      if (this.fieldType !== 'multiline') {\n        event.preventDefault();\n      } else {\n        /**\n         * event emitted by field type `multiline`\n         * @event keydown\n         * @param {KeyboardEvent} - the native keydown event\n         */\n        this.$emit('keydown', event);\n      }\n    },\n    fetchBoxData() {\n      /**\n       * event triggered when hover box data should be fetched\n       * @event fetch-info-data\n       */\n      this.$emit('fetch-info-data');\n    },\n  },\n};\n</script>\n\n<style lang=\"scss\" scoped>\n  @import \"../../styles/variables\";\n\n  .base-form-field-creator__field-array {\n    margin-top: $spacing-small;\n    display: flex;\n    flex-direction: column;\n\n    .base-form-field-creator__field-array-label {\n      color: $font-color-second;\n      margin-bottom: $spacing-small;\n      z-index: map-get($zindex, boxcontent);\n    }\n\n    .base-form-field-creator__subform-wrapper {\n      border-right: 3px solid rgb(240, 240, 240);\n      border-left: 3px solid rgb(240, 240, 240);\n\n      .base-form-field-creator__subform {\n        position: relative;\n        margin: -$spacing auto;\n        width: calc(100% - 6px);\n\n        @media screen and (max-width: $mobile) {\n          margin: -$spacing auto;\n        }\n      }\n    }\n  }\n\n  .base-form-field-creator__date-field-wrapper {\n    display: flex;\n\n    .base-form-field-creator__date-field + .base-form-field-creator__date-field {\n      margin-left: $spacing;\n    }\n  }\n\n  .base-form-field-creator__multiline-dropdown {\n    text-transform: capitalize;\n  }\n\n  .base-form-field-creator__chips-dropdown-second {\n    margin-left: $spacing;\n    color: $font-color-second;\n    font-size: $font-size-small;\n    margin-top: 1px;\n    flex-grow: 2;\n  }\n\n  .base-form-field-creator__chips-dropdown-third {\n    color: $font-color-third;\n    font-size: $font-size-small;\n    margin-top: auto;\n    white-space: nowrap;\n  }\n\n  .base-form-field-creator__date-fieldset {\n    display: contents;\n  }\n\n  .base-form-field-creator__toggle {\n    display: flex;\n    flex-direction: column;\n  }\n\n  @media screen and (max-width: 1260px) {\n    .base-form-field-creator__date-field-wrapper {\n      display: block;\n      .base-form-field-creator__date-field + .base-form-field-creator__date-field {\n        margin-top: $spacing;\n        margin-left: 0;\n      }\n    }\n  }\n</style>\n"],"names":["_sfc_main","m","i18n","val","prop","props","fieldName","dropDownLists","lang","openAPIFieldType","decimals","numberFieldType","numberFieldFormat","tabs","value","autocompleteInformation","parentFieldsArary","localesWithContent","event"],"mappings":"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"}