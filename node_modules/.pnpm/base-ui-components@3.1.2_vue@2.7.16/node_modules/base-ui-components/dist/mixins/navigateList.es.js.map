{"version":3,"file":"navigateList.es.js","sources":["../../src/mixins/navigateList.js"],"sourcesContent":["export default {\n  methods: {\n    /**\n     * function to navigate a drop-down list or similar via key up/down\n     * @param {Array} list - the list to navigate in\n     * @param {boolean} isArrowDown - was key navigation up or down\n     * @param {number} currentIndex - the index of the current active option in the array\n     * @param {boolean} [loop=false] - should index return to last/first\n     *  item if first/last item was reached\n     * @param {boolean} [allowNegativeIndex=false] - allow index to become -1 (no active option -->\n     *  function will return null)\n     * @returns {?Object|?string} - the new active element\n     */\n    navigate(\n      list,\n      isArrowDown,\n      currentIndex,\n      loop = false,\n      allowNegativeIndex = false,\n    ) {\n      // depending on if arrow was up or down set +/- one to add or subtract\n      // generically\n      const numberToAdd = isArrowDown ? 1 : -1;\n      if (this.isWithinArrayLimit(\n        list,\n        isArrowDown,\n        currentIndex + numberToAdd,\n      )) {\n        // set new active entry\n        return list[currentIndex + numberToAdd];\n      }\n      if (currentIndex >= 0 && allowNegativeIndex) {\n        return null;\n      }\n      if (loop) {\n        return list[isArrowDown ? 0 : list.length - 1];\n      }\n      return list[currentIndex];\n    },\n    isWithinArrayLimit(list, isArrowDown, newIndex) {\n      // set variable for limit to check against\n      // 0 for arrow up and array length for arrow down\n      const listLimit = isArrowDown ? list.length : 0;\n      // define operator functions to be able to use condition generically\n      const operators = {\n        '>=': (a, b) => a >= b,\n        '<': (a, b) => a < b,\n      };\n      // set the actual operator\n      const operator = isArrowDown ? '<' : '>=';\n      // return Boolean if it is within limits of array or not\n      return operators[operator](newIndex, listLimit);\n    },\n  },\n};\n"],"names":["navigateList","methods","navigate","list","isArrowDown","currentIndex","loop","arguments","length","undefined","allowNegativeIndex","numberToAdd","isWithinArrayLimit","newIndex","listLimit","operators","a","b","operator"],"mappings":"AAAA,MAAeA,IAAA;AAAA,EACbC,SAAS;AAAA,IAYPC,mBACEC,GACAC,GACAC,GAGA;AAAA,UAFAC,IAAIC,UAAAC,SAAA,KAAAD,UAAA,OAAAE,SAAAF,UAAA,KAAG,IACPG,IAAkBH,UAAAC,SAAA,KAAAD,UAAA,OAAAE,SAAAF,UAAA,KAAG,IAIfI,IAAcP,IAAc,IAAI;AACtC,aAAI,KAAKQ,mBACPT,GACAC,GACAC,IAAeM,CAAW,IAGnBR,EAAKE,IAAeM,KAEzBN,KAAgB,KAAKK,IAChB,OAELJ,IACKH,EAAKC,IAAc,IAAID,EAAKK,SAAS,KAEvCL,EAAKE;AAAAA,IACb;AAAA,IACDO,6BAAmBT,GAAMC,GAAaS,GAAU;AAG9C,UAAMC,IAAYV,IAAcD,EAAKK,SAAS,GAExCO,IAAY;AAAA,QAChB,MAAM,SAACC,GAAGC,GAAC;AAAA,iBAAKD,KAAKC;AAAAA,QAAC;AAAA,QACtB,KAAK,SAACD,GAAGC,GAAC;AAAA,iBAAKD,IAAIC;AAAAA,QAAC;AAAA,SAGhBC,IAAWd,IAAc,MAAM;AAErC,aAAOW,EAAUG,GAAUL,GAAUC,CAAS;AAAA,IAChD;AAAA,EACF;AACF;"}