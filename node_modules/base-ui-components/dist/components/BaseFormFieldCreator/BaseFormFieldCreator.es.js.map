{"version":3,"file":"BaseFormFieldCreator.es.js","sources":["../../../src/components/BaseFormFieldCreator/BaseFormFieldCreator.vue"],"sourcesContent":["<template>\n  <div>\n    <!-- TEXT FIELD -->\n    <!-- AUTOCOMPLETE -->\n    <!-- MULTILINE -->\n    <component\n      :is=\"fieldElement\"\n      v-if=\"fieldType !== 'date' && fieldType !== 'chips'\n        && fieldType !== 'chips-below' && fieldType !== 'group'\n        && fieldType !== 'boolean'\"\n      :id=\"fieldKey\"\n      :key=\"fieldKey\"\n      v-bind=\"fieldProps\"\n      :label=\"labelInt\"\n      :show-label=\"fieldProps.showLabel !== undefined ? fieldProps.showLabel : showLabel\"\n      :placeholder=\"placeholderInt\"\n      :tabs=\"fieldType === 'multiline' ? fieldProps.tabs || tabs : false\"\n      :tab-labels=\"fieldType === 'multiline'\n        ? fieldProps.tabLabels || tabs.map(tab => getI18nTerm(tab)) : false\"\n      :tabs-legend=\"fieldType === 'multiline'\n        ? fieldProps.tabsLegend || getI18nTerm('form.textTabsLegend') : false\"\n      :active-tab=\"fieldType === 'multiline' ? activeTab : false\"\n      :list=\"fieldType === 'autocomplete'\n        ? dropDownList.length ? dropDownList : fieldProps.list || [] : false\"\n      :is-loading=\"autocompleteLoading\"\n      :input=\"fieldValueInt\"\n      :field-type=\"isNumberField ? 'number' : fieldProps.fieldType || 'text'\"\n      :invalid=\"invalid || fieldProps.invalid\"\n      :required=\"required || fieldProps.required\"\n      :error-message=\"errorMessage || fieldProps.errorMessage\"\n      :validation-texts=\"fieldProps.validationTexts\n        ? (fieldProps.validationTexts[!isNumberField ? fieldType : 'text']\n          || fieldProps.validationTexts)\n        : validationTexts[!isNumberField ? fieldType : 'text']\"\n      :show-error-icon=\"showErrorIcon\"\n      :clearable=\"clearable\"\n      :min-length=\"field.minLength || fieldProps.minLength\"\n      :max-length=\"field.maxLength || fieldProps.maxLength\"\n      :min=\"typeof formFieldXAttrs.min !== 'undefined' ? formFieldXAttrs.min : fieldProps.min\"\n      :max=\"typeof formFieldXAttrs.max !== 'undefined' ? formFieldXAttrs.max : fieldProps.max\"\n      :decimals=\"allowedDecimals\"\n      :decimal-separator=\"fieldProps.decimalSeparator || language === 'de' ? ',' : '.'\"\n      @keydown.enter=\"onEnter\"\n      @input=\"setInputValue($event)\"\n      @fetch-dropdown-entries=\"$emit('fetch-autocomplete', {\n        value: $event,\n        name: field.name,\n        source: formFieldXAttrs.source,\n      })\">\n      <template\n        #label-addition>\n        <!-- @slot Slot to allow for additional elements on the right side of the label row <div> (e.g. language tabs))\n          @binding {string} fieldName -->\n        <slot\n          :field-name=\"field.name\"\n          name=\"label-addition\" />\n        <BaseDropDown\n          v-if=\"fieldType === 'multiline' && field.items\n            && field.items.properties && field.items.properties.type\"\n          :id=\"fieldKey\"\n          :selected-option=\"fieldValueInt && fieldValueInt.type && fieldValueInt.type.source\n            ? fieldValueInt.type : textTypeDefault\"\n          :options=\"textTypeOptions\"\n          :label=\"getI18nTerm('form.texttype')\"\n          :language=\"language\"\n          value-prop=\"source\"\n          class=\"base-form-field-creator__multiline-dropdown\"\n          @value-selected=\"setMultilineDropDown\" />\n      </template>\n      <template #pre-input-field>\n        <!-- @slot slot to add elements within the form field but in a row before the actual input field. for an example see [BaseInput](BaseInput)\n          @binding {string} fieldName - the name of the current field for identification purposes -->\n        <slot\n          :field-name=\"field.name\"\n          name=\"pre-input-field\" />\n      </template>\n      <template\n        #input-field-addition-before>\n        <!-- @slot Slot to allow for additional elements in the input field <div> (before <input>)\n          @binding {string} fieldName - the name of the current field for identification purposes -->\n        <slot\n          :field-name=\"field.name\"\n          name=\"input-field-addition-before\" />\n      </template>\n      <template #input-field-inline-before>\n        <!-- @slot to add elements directly inline before the input (contrary to input-field-addition-before this does not wrap). for an example see [BaseInput](BaseInput)\n          @binding {string} fieldName - the name of the current field for identification purposes-->\n        <slot\n          :field-name=\"field.name\"\n          name=\"input-field-inline-before\" />\n      </template>\n      <template #input-field-addition-after>\n        <!-- @slot for adding elements after input\n          @binding {string} fieldName - the name of the current field for identification purposes -->\n        <slot\n          :field-name=\"field.name\"\n          name=\"input-field-addition-after\" />\n      </template>\n      <template #post-input-field>\n        <!-- @slot for adding elements at the end covering the whole height\n          @binding {string} fieldName - the name of the current field for identification purposes -->\n        <slot\n          :field-name=\"field.name\"\n          name=\"post-input-field\" />\n      </template>\n      <template #error-icon>\n        <!-- @slot use a custom icon instead of standard error/warning icon -->\n        <slot\n          name=\"error-icon\" />\n      </template>\n      <template #remove-icon>\n        <!-- @slot use a custom icon instead of standard remove icon -->\n        <slot\n          name=\"remove-icon\" />\n      </template>\n      <template #below-input>\n        <!-- @slot below-input slot added to e.g. add drop down\n          @binding {string} fieldName - the name of the current field for identification purposes -->\n        <slot\n          :field-name=\"field.name\"\n          name=\"below-input\" />\n      </template>\n    </component>\n\n    <!-- DATE FIELD -->\n    <fieldset\n      v-else-if=\"fieldType === 'date'\"\n      class=\"base-form-field-creator__date-fieldset\">\n      <div class=\"base-form-field-creator__date-field-wrapper\">\n        <BaseDateInput\n          :id=\"fieldKey\"\n          :key=\"fieldKey + '_date'\"\n          v-model=\"fieldValueInt\"\n          v-bind=\"fieldProps\"\n          :label=\"labelInt\"\n          :show-label=\"fieldProps.showLabel !== undefined ? fieldProps.showLabel : showLabel\"\n          :placeholder=\"placeholderInt\"\n          :range-separator=\"fieldProps.rangeSeparator || getI18nTerm('form.until')\"\n          :format=\"formFieldXAttrs.date_format || fieldProps.format\"\n          :type=\"dateType.includes('timerange') ? dateType.includes('daterange')\n            ? 'daterange' : 'single' : dateType\"\n          :date-format-labels=\"fieldProps.dateFormatLabels\n            || {\n              date: getI18nTerm('form.date'),\n              month: getI18nTerm('form.month'),\n              year: getI18nTerm('form.year'),\n            }\"\n          :format-tabs-legend=\"fieldProps.formatTabsLegend || getI18nTerm('form.dateTabsLegend')\"\n          :language=\"language\"\n          :invalid=\"invalid || fieldProps.invalid\"\n          :required=\"required || fieldProps.required\"\n          :error-message=\"errorMessage || fieldProps.errorMessage\"\n          class=\"base-form-field-creator__date-field\">\n          <template\n            #label-addition>\n            <!-- @slot Slot to allow for additional elements on the right side of the label row <div> (e.g. language tabs))\n              @binding {string} fieldName -->\n            <slot\n              :field-name=\"field.name\"\n              name=\"label-addition\" />\n          </template>\n          <template #pre-input-field>\n            <!-- @slot slot to add elements within the form field but in a row before the actual input field. for an example see [BaseInput](BaseInput)\n              @binding {string} fieldName - the name of the current field for identification purposes -->\n            <slot\n              :field-name=\"field.name\"\n              name=\"pre-input-field\" />\n          </template>\n          <template\n            #input-field-addition-before>\n            <!-- @slot Slot to allow for additional elements in the input field <div> (before <input>)\n              @binding {string} fieldName - the name of the current field for identification purposes -->\n            <slot\n              :field-name=\"field.name\"\n              name=\"input-field-addition-before\" />\n          </template>\n          <template #input-field-inline-before>\n            <!-- @slot to add elements directly inline before the input (contrary to input-field-addition-before this does not wrap). for an example see [BaseInput](BaseInput)\n              @binding {string} fieldName - the name of the current field for identification purposes -->\n            <slot\n              :field-name=\"field.name\"\n              name=\"input-field-inline-before\" />\n          </template>\n          <template #input-field-addition-after>\n            <!-- @slot for adding elements after input\n              @binding {string} fieldName - the name of the current field for identification purposes -->\n            <slot\n              :field-name=\"field.name\"\n              name=\"input-field-addition-after\" />\n          </template>\n          <template #post-input-field>\n            <!-- @slot for adding elements at the end covering the whole height\n              @binding {string} fieldName - the name of the current field for identification purposes -->\n            <slot\n              :field-name=\"field.name\"\n              name=\"post-input-field\" />\n          </template>\n          <template #error-icon>\n            <!-- @slot use a custom icon instead of standard error/warning icon -->\n            <slot\n              name=\"error-icon\" />\n          </template>\n          <template #remove-icon>\n            <!-- @slot use a custom icon instead of standard remove icon -->\n            <slot\n              name=\"remove-icon\" />\n          </template>\n          <template #below-input>\n            <!-- @slot below-input slot added to e.g. add drop down\n              @binding {string} fieldName - the name of the current field for identification purposes -->\n            <slot\n              :field-name=\"field.name\"\n              name=\"below-input\" />\n          </template>\n        </BaseDateInput>\n        <BaseDateInput\n          v-if=\"dateType.includes('timerange')\"\n          :id=\"fieldKey\"\n          :key=\"fieldKey + '_time'\"\n          v-model=\"fieldValueInt\"\n          v-bind=\"fieldProps\"\n          :label=\"field.properties.time_from.title\"\n          :show-label=\"false\"\n          :placeholder=\"placeholderInt.time\"\n          :range-separator=\"fieldProps.rangeSeparator || getI18nTerm('form.until')\"\n          :invalid=\"invalid || fieldProps.invalid\"\n          :required=\"required || fieldProps.required\"\n          :error-message=\"errorMessage || fieldProps.errorMessage\"\n          type=\"timerange\"\n          class=\"base-form-field-creator__date-field\" />\n      </div>\n    </fieldset>\n\n    <!-- CHIPS INPUT -->\n    <component\n      :is=\"fieldElement\"\n      v-else-if=\"fieldType === 'chips' || fieldType === 'chips-below'\"\n      :id=\"fieldKey\"\n      :key=\"fieldKey\"\n      v-model=\"fieldValueInt\"\n      v-bind=\"fieldProps\"\n      :placeholder=\"placeholderInt\"\n      :label=\"labelInt\"\n      :show-label=\"fieldProps.showLabel !== undefined ? fieldProps.showLabel : showLabel\"\n      :list=\"dropDownList.length ? dropDownList : fieldProps.list || []\"\n      :allow-dynamic-drop-down-entries=\"formFieldXAttrs.dynamic_autosuggest\n        || !!fieldProps.allowDynamicDropDownEntries\"\n      :allow-multiple-entries=\"!isChipsSingleSelect\"\n      :allow-unknown-entries=\"formFieldXAttrs.allow_unknown_entries\n        || !!fieldProps.allowUnknownEntries\"\n      :draggable=\"!!fieldProps.draggable || !isChipsSingleSelect\"\n      :hoverbox-content=\"hoverBoxData || fieldProps.hoverBoxData\"\n      :sortable=\"field.name === 'keywords' || formFieldXAttrs.sortable\n        || !!fieldProps.sortable\"\n      :is-loading=\"autocompleteLoading\"\n      :sort-text=\"fieldProps.sortText || sortText\"\n      :sort-name=\"fieldProps.sortName || isContributorOrEquivalent\"\n      :language=\"formFieldXAttrs.set_label_language\n        || fieldType === 'chips-below' ? language : ''\"\n      :drop-down-no-options-info=\"fieldProps.dropDownNoOptionsInfo || getI18nTerm('form.noMatch')\"\n      :additional-prop-options=\"fieldType === 'chips-below' ? secondaryDropdown : false\"\n      :additional-prop-placeholder=\"fieldType === 'chips-below'\n        ? fieldProps.additionalPropPlaceholder || getI18nTerm('form.selectRoles') : false\"\n      :additional-property-name=\"fieldType === 'chips-below'\n        ? fieldProps.additionalPropertyName || 'roles' : false\"\n      :invalid=\"invalid || fieldProps.invalid\"\n      :required=\"required || fieldProps.required\"\n      :error-message=\"errorMessage || fieldProps.errorMessage\"\n      :show-error-icon=\"showErrorIcon\"\n      :identifier-property-name=\"fieldProps.identifierPropertyName || identifierPropertyName\"\n      :label-property-name=\"fieldProps.labelPropertyName || labelPropertyName\"\n      @fetch-dropdown-entries=\"fetchAutocomplete\"\n      @input=\"textInput = $event\"\n      @hoverbox-active=\"fetchBoxData\">\n      <template\n        #drop-down-entry=\"props\">\n        <span>\n          {{ getLabel(props.item.label) }}\n        </span>\n        <span class=\"base-form-field-creator__chips-dropdown-second\">\n          {{ props.item.additional }}\n        </span>\n        <span class=\"base-form-field-creator__chips-dropdown-third\">\n          {{ props.item.source_name }}\n        </span>\n      </template>\n      <template #no-options>\n        <span v-if=\"formFieldXAttrs.dynamic_autosuggest && !fieldInput\">\n          {{ getI18nTerm('form.startTyping') }}\n        </span>\n        <span v-else-if=\"!formFieldXAttrs.dynamic_autosuggest && textInput\">\n          {{ getI18nTerm('form.noMatch') }}\n        </span>\n        <span v-else-if=\"fieldInput && !fetchingData && !autocompleteLoading\">\n          {{ getI18nTerm('form.noResult') }}\n        </span>\n        <span v-else>\n          {{ getI18nTerm('form.fetchingResults') }}\n        </span>\n      </template>\n      <template\n        #label-addition>\n        <!-- @slot Slot to allow for additional elements on the right side of the label row <div> (e.g. language tabs))\n          @binding {string} fieldName - the name of the current field for identification purposes -->\n        <slot\n          :field-name=\"field.name\"\n          name=\"label-addition\" />\n      </template>\n      <template #pre-input-field>\n        <!-- @slot slot to add elements within the form field but in a row before the actual input field. for an example see [BaseInput](BaseInput)\n          @binding {string} fieldName - the name of the current field for identification purposes -->\n        <slot\n          :field-name=\"field.name\"\n          name=\"pre-input-field\" />\n      </template>\n      <template\n        #input-field-addition-before>\n        <!-- @slot Slot to allow for additional elements in the input field <div> (before <input>)\n          @binding {string} fieldName - the name of the current field for identification purposes -->\n        <slot\n          :field-name=\"field.name\"\n          name=\"input-field-addition-before\" />\n      </template>\n      <template #input-field-inline-before>\n        <!-- @slot to add elements directly inline before the input (contrary to input-field-addition-before this does not wrap). for an example see [BaseInput](BaseInput)\n          @binding {string} fieldName - the name of the current field for identification purposes -->\n        <slot\n          :field-name=\"field.name\"\n          name=\"input-field-inline-before\" />\n      </template>\n      <template #input-field-addition-after>\n        <!-- @slot for adding elements after input\n          @binding {string} fieldName - the name of the current field for identification purposes -->\n        <slot\n          :field-name=\"field.name\"\n          name=\"input-field-addition-after\" />\n      </template>\n      <template #post-input-field>\n        <!-- @slot for adding elements at the end covering the whole height\n          @binding {string} fieldName - the name of the current field for identification purposes -->\n        <slot\n          :field-name=\"field.name\"\n          name=\"post-input-field\" />\n      </template>\n      <template #error-icon>\n        <!-- @slot use a custom icon instead of standard error/warning icon -->\n        <slot\n          name=\"error-icon\" />\n      </template>\n      <template #remove-icon>\n        <!-- @slot use a custom icon instead of standard remove icon -->\n        <slot\n          :field-name=\"field.name\" />\n      </template>\n      <template #below-input>\n        <!-- @slot below-input slot added to e.g. add drop down\n          @binding {string} fieldName - the name of the current field for identification purposes -->\n        <slot\n          :field-name=\"field.name\"\n          name=\"below-input\" />\n      </template>\n    </component>\n\n    <!-- FIELD GROUPS -->\n    <div\n      v-else-if=\"fieldType === 'group'\"\n      :key=\"fieldKey\"\n      class=\"base-form-field-creator__field-array\">\n      <div\n        v-if=\"formFieldXAttrs.show_label\"\n        class=\"base-form-field-creator__field-array-label\">\n        {{ `${labelInt}:` }}\n      </div>\n      <div\n        :key=\"fieldKey\"\n        class=\"base-form-field-creator__subform-wrapper\">\n        <BaseForm\n          :form-field-json=\"groupFormFields\"\n          :value-list=\"fieldValueInt\"\n          :form-id=\"fieldKey + '_' + field.name\"\n          :field-props=\"fieldProps\"\n          :drop-down-lists=\"fieldGroupDropDownLists\"\n          v-bind=\"fieldGroupParams\"\n          class=\"base-form-field-creator__subform\"\n          @values-changed=\"$emit('field-value-changed', $event)\"\n          @fetch-autocomplete=\"subFormFetchAutocomplete\">\n          <template\n            #label-addition=\"{ fieldName, groupNames }\">\n            <!-- @slot Slot to allow for additional elements on the right side of the label row <div> (e.g. language tabs))\n              @binding {string} fieldName - the name of the current field for identification purposes\n              @binding {string[]} groupNames - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              :field-name=\"fieldName\"\n              :group-names=\"(groupNames ? groupNames : []).concat(field.name)\"\n              name=\"label-addition\" />\n          </template>\n          <template #pre-input-field=\"{ fieldName, groupNames }\">\n            <!-- @slot slot to add elements within the form field but in a row before the actual input field. for an example see [BaseInput](BaseInput)\n              @binding {string} fieldName - the name of the current field for identification purposes\n              @binding {string[]} groupNames - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              :field-name=\"fieldName\"\n              :group-names=\"(groupNames ? groupNames : []).concat(field.name)\"\n              name=\"pre-input-field\" />\n          </template>\n          <template\n            #input-field-addition-before=\"{ fieldName, groupNames }\">\n            <!-- @slot Slot to allow for additional elements in the input field <div> (before <input>)\n              @binding {string} fieldName - the name of the current field for identification purposes\n              @binding {string[]} groupNames - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              :field-name=\"fieldName\"\n              :group-names=\"(groupNames ? groupNames : []).concat(field.name)\"\n              name=\"input-field-addition-before\" />\n          </template>\n          <template #input-field-inline-before=\"{ fieldName, groupNames }\">\n            <!-- @slot to add elements directly inline before the input (contrary to input-field-addition-before this does not wrap). for an example see [BaseInput](BaseInput)\n              @binding {string} fieldName - the name of the current field for identification purposes\n              @binding {string[]} groupNames - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              :field-name=\"fieldName\"\n              :group-names=\"(groupNames ? groupNames : []).concat(field.name)\"\n              name=\"input-field-inline-before\" />\n          </template>\n          <template #input-field-addition-after=\"{ fieldName, groupNames }\">\n            <!-- @slot for adding elements after input\n              @binding {string} fieldName - the name of the current field for identification purposes\n              @binding {string[]} groupNames - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              :field-name=\"fieldName\"\n              :group-names=\"(groupNames ? groupNames : []).concat(field.name)\"\n              name=\"input-field-addition-after\" />\n          </template>\n          <template #post-input-field=\"{ fieldName, groupNames }\">\n            <!-- @slot for adding elements at the end covering the whole height\n              @binding {string} fieldName - the name of the current field for identification purposes\n              @binding {string[]} groupNames - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              :field-name=\"fieldName\"\n              :group-names=\"(groupNames ? groupNames : []).concat(field.name)\"\n              name=\"post-input-field\" />\n          </template>\n          <template #error-icon>\n            <!-- @slot use a custom icon instead of standard error/warning icon -->\n            <slot\n              name=\"error-icon\" />\n          </template>\n          <template #remove-icon>\n            <!-- @slot use a custom icon instead of standard remove icon -->\n            <slot\n              name=\"remove-icon\" />\n          </template>\n          <template #below-input=\"{ fieldName, groupNames }\">\n            <!-- @slot below-input slot added to e.g. add drop down\n              @binding {string} fieldName - the name of the current field for identification purposes\n              @binding {string[]} groupNames - in case the slot is for a subform (form group) field, `groupNames` contains the parent field groups names -->\n            <slot\n              :field-name=\"fieldName\"\n              :group-names=\"(groupNames ? groupNames : []).concat(field.name)\"\n              name=\"below-input\" />\n          </template>\n        </BaseForm>\n      </div>\n    </div>\n\n    <!-- FIELD BOOLEAN -->\n    <template\n      v-else-if=\"fieldType === 'boolean'\">\n      <BaseToggle\n        v-bind=\"fieldProps\"\n        :name=\"fieldKey\"\n        :label=\"labelInt\"\n        :checked=\"fieldValue\"\n        :bind-slot-to-state=\"fieldProps.bindSlotToState || true\"\n        class=\"base-form-field-creator__toggle\"\n        @clicked=\"$emit('field-value-changed', $event)\">\n        <BaseLink\n          v-if=\"formFieldXAttrs.subtext && formFieldXAttrs.subtext.value\"\n          :source=\"formFieldXAttrs.subtext.source || ''\"\n          :url=\"formFieldXAttrs.subtext.url || ''\"\n          :value=\"formFieldXAttrs.subtext.value\" />\n      </BaseToggle>\n    </template>\n  </div>\n</template>\n\n<script>\nimport i18n from '../../mixins/i18n';\n\n/**\n * A component for form field creation via [openAPI](https://spec.openapis.org/oas/v3.1.0/) standard\n */\n\nexport default {\n  name: 'BaseFormFieldCreator',\n  components: {\n    BaseDropDown: () => import('../BaseDropDown/BaseDropDown').then(m => m.default || m),\n    BaseDateInput: () => import('../BaseDateInput/BaseDateInput').then(m => m.default || m),\n    BaseForm: () => import('../BaseForm/BaseForm').then(m => m.default || m),\n    BaseToggle: () => import('../BaseToggle/BaseToggle').then(m => m.default || m),\n    BaseLink: () => import('../BaseLink/BaseLink').then(m => m.default || m),\n  },\n  mixins: [i18n],\n  props: {\n    /**\n     * a key to uniquely identify the field\n     */\n    fieldKey: {\n      type: [Number, String],\n      required: true,\n    },\n    /**\n     * field information as provided in [openAPI](https://spec.openapis.org/oas/v3.1.0#schema-object) standard\n     */\n    field: {\n      type: Object,\n      required: true,\n    },\n    /**\n     * the field value\n     */\n    fieldValue: {\n      type: [Object, String, Array, Date, Number, Boolean],\n      required: true,\n    },\n    /**\n     * add properties any input field can take and set values - find the possible variables at the\n     * respective input components:\n     * [BaseInput](BaseInput)\n     * [BaseAutocompleteInput](BaseAutocompleteInput)\n     * [BaseMultilineTextInput](BaseMultilineTextInput)\n     * [BaseChipsInput](BaseChipsInput)\n     * [BaseChipsBelow](BaseChipsBelow)\n     * [BaseDateInput](BaseDateInput)\n     * [BaseToggle](BaseToggle)\n     *\n     * **Caveat**: this means several input field properties are settable via separate props as well\n     * as via `fieldProps` (e.g. `language`, `required`, `sortText`) the logic here is the following:\n     *  separate props will have priority over `fieldProps` values **unless** the separate\n     *  prop has a default value other than ones evaluating to `false` (boolean false,\n     *  empty string).\n     *  Field props that are set via `x-attrs` (e.g. `allowUnknownEntries`) in the OpenAPI definition\n     *  have priority over `fieldProps` set values.\n     *  Fields for which a unified appearance makes sense (e.g. `clearable`, `showErrorIcon`) or that\n     *  are modified internally (e.g. `input`, `selectedList`) might not be settable\n     *  via `fieldProps`.\n     */\n    fieldProps: {\n      type: Object,\n      default: () => ({}),\n    },\n    /**\n     * a label for the field\n     */\n    label: {\n      type: String,\n      default: '',\n    },\n    /**\n     * define if field label should be shown\n     */\n    showLabel: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * a placeholder for the field\n     * per default the placeholder attribute in OpenAPI `x-attrs` field will be used\n     * (no need to specify that)\n     */\n    placeholder: {\n      type: [String, Object],\n      default: '',\n    },\n    /**\n     * provide an options list for `autocomplete`, `chips` or `chips-below` fields\n     * for field type `group` provide a nested object with field names\n     * as properties and an array for each field to ensure the correct options are assigned\n     * even if field names within different groups are identical\n     */\n    dropDownList: {\n      type: [Array, Object],\n      default: () => [],\n    },\n    /**\n     * provide a second options list (needed e.g. for texts field (text type) or\n     * contributors field (roles)\n     */\n    secondaryDropdown: {\n      type: Array,\n      default: () => [],\n    },\n    /**\n     * provide data for elements that have a hover box (chips)\n     */\n    hoverBoxData: {\n      type: Object,\n      default: () => ({}),\n    },\n    /**\n     * possibility to steer field loading (`chips`, `autocomplete`) from outside\n     */\n    autocompleteLoading: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * set the current language\n     */\n    language: {\n      type: String,\n      default: 'en',\n    },\n    /**\n     * provide available locales\n     */\n    availableLocales: {\n      type: Array,\n      default: () => [],\n    },\n    /**\n     * set a sorting text\n     */\n    sortText: {\n      type: String,\n      default: 'Sort A - Z',\n    },\n    /**\n     * pass down all necessary options for potential subform.\n     *   see [BaseForm props](BaseForm)\n     */\n    fieldGroupParams: {\n      type: Object,\n      default: () => ({}),\n    },\n    /**\n     * mark as required field (currently only used for `aria-required` attribute)\n     */\n    required: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * mark the form field as invalid and ideally also provide an error message\n     * to display below the form field.\n     * for an example see [BaseInput](BaseInput)\n     */\n    invalid: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * add an error message to be displayed below form field if field is invalid.\n     * for an example see [BaseInput](BaseInput)\n     */\n    errorMessage: {\n      type: String,\n      default: '',\n    },\n    /**\n     * define validation texts to be displayed below form field if input is invalid.\n     * for an example see [BaseInput](BaseInput)\n     */\n    validationTexts: {\n      type: Object,\n      default: () => ({\n        text: {\n          min: 'Value must be greater than or equal to {value}.',\n          max: 'Value must be less than or equal to {value}.',\n          minLength: 'Text must be at least {value} character(s) long.',\n          maxLength: 'Text cannot be longer than {value} characters.',\n        },\n      }),\n      // checking if all necessary properties are part of the provided object\n      validator: val => ['text'].every(prop => Object.keys(val).includes(prop))\n        && ['min', 'max', 'minLength', 'maxLength']\n          .every(prop => Object.keys(val.text).includes(prop)),\n    },\n    /**\n     * define if error icon should be shown.\n     * for an example see [BaseInput](BaseInput)\n     */\n    showErrorIcon: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * if `true` a remove icon will be shown allowing to remove\n     * all input at once.\n     * for an example see [BaseInput](BaseInput)\n     */\n    clearable: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * specify the object property that should be used as identifier\n     */\n    identifierPropertyName: {\n      type: String,\n      default: 'source',\n    },\n    /**\n     * specify the object property that should be used as value to be displayed\n     */\n    labelPropertyName: {\n      type: String,\n      default: 'label',\n    },\n  },\n  data() {\n    return {\n      /**\n       * internal representation of field value\n       * @type {any}\n       */\n      fieldValueInt: null,\n      /**\n       * variable for current text input in chips fields\n       * @type {string}\n       */\n      textInput: '',\n      /**\n       * internal loading indicator\n       * @type {boolean}\n       */\n      fetchingData: false,\n      /**\n       * internal active tab for multiline text field\n       * @type {string}\n       */\n      activeTab: '',\n    };\n  },\n  computed: {\n    /**\n     * import the relevant component\n     * @returns {(function(): *)|null}\n     */\n    fieldElement() {\n      if (this.fieldType === 'text' || this.fieldType === 'integer' || this.fieldType === 'float') {\n        return () => import('../BaseInput/BaseInput');\n      } if (this.fieldType === 'multiline') {\n        return () => import('../BaseMultilineTextInput/BaseMultilineTextInput');\n      } if (this.fieldType === 'autocomplete') {\n        return () => import('../BaseAutocompleteInput/BaseAutocompleteInput');\n      } if (this.fieldType === 'chips') {\n        return () => import('../BaseChipsInput/BaseChipsInput');\n      } if (this.fieldType === 'chips-below') {\n        return () => import('../BaseChipsBelow/BaseChipsBelow');\n      }\n      return null;\n    },\n    /**\n     * check which date field type was provided and set type accordingly\n     * @returns {string}\n     */\n    dateType() {\n      // check if date is an Object with properties or just string (= single date)\n      // also need to check items in case date field is repeatable\n      const props = this.field.properties || (this.field.items && this.field.items.properties)\n        ? Object.keys(this.field.properties || this.field.items.properties) : [];\n      if (!this.field.properties && (!this.field.items || !this.field.items.properties)) {\n        return 'single';\n      }\n      if (props.includes('date_to') && props.includes('time_to')) {\n        return 'daterangetimerange';\n      }\n      if (props.includes('date') && props.includes('time_to')) {\n        return 'datetimerange';\n      }\n      if (props.includes('time')) {\n        return 'datetime';\n      }\n      if (props.includes('date_to')) {\n        return 'daterange';\n      }\n      return 'single';\n    },\n    /**\n     * get field properties from swagger info - necessary for subforms\n     * @returns {Object}\n     */\n    groupFormFields() {\n      // check if field group is a list (=repeatable) or not\n      if (this.field.type === 'array') {\n        return this.field.items.properties;\n      }\n      return this.field.properties;\n    },\n    /**\n     * function to check if dropdowns for field groups are nested. Nesting was necessary\n     * to ensure every field group gets their own dropdown even if field names are identical.\n     * For backwards compatibility keep using direct base level fieldName array as fallback.\n     * @returns {{ [fieldName]: Object[] }}\n     */\n    fieldGroupDropDownLists() {\n      // get field name\n      const fieldName = this.field.name;\n      // get parent BaseForm $props.dropDownLists that were passed to BaseFormFieldCreator\n      // as fieldGroupParams\n      const { dropDownLists } = this.fieldGroupParams;\n      // check if the nested object with the fieldName exists, if not fall back to use\n      // field name directly\n      return dropDownLists && dropDownLists[fieldName]\n        ? dropDownLists[fieldName] : dropDownLists;\n    },\n    formFieldXAttrs() {\n      // x-attrs should exist however just in case if not return an empty object\n      // so that ['x-attrs'][xAttrProperty] does not throw errors\n      return this.field['x-attrs'] || {};\n    },\n    // the type default for texts field\n    textTypeDefault() {\n      return {\n        // map the language specific labels for no value selected to the default\n        [this.labelPropertyName]: this.setLangLabels('form.noTextType', this.availableLocales),\n        [this.identifierPropertyName]: '',\n      };\n    },\n    // compute the texts type drop down list specific for texts\n    textTypeOptions() {\n      return [this.textTypeDefault].concat(this.secondaryDropdown);\n    },\n    // for chips input fields - check if it is a contributors field\n    isContributorOrEquivalent() {\n      return this.field.name === 'contributors'\n        || this.formFieldXAttrs.equivalent === 'contributors';\n    },\n    // to determine text display for chips input\n    fieldInput() {\n      return this.textInput && this.textInput.length > 2;\n    },\n    // check if chips input is a single select field\n    isChipsSingleSelect() {\n      return (this.fieldType\n        && this.fieldType.includes('chips')\n        && this.field.type === 'object');\n    },\n    // check if label was specified - if not defer from title or check if there is a localized term\n    labelInt() {\n      if (this.label || this.fieldProps.label) {\n        return this.label || this.fieldProps.label;\n      }\n      return this.field.title || this.getI18nTerm(`form.${this.field.name}` || this.field.name);\n    },\n    // check if placeholder was specified - if not defer from\n    // title or check if there is a localized term\n    placeholderInt() {\n      if (this.placeholder || this.fieldProps.placeholder) {\n        return this.placeholder || this.fieldProps.placeholder;\n      }\n      const internalPlaceholder = this.formFieldXAttrs.placeholder || '';\n      return internalPlaceholder || `${this.hasI18n ? this.getI18nTerm('form.select') : 'Select'} ${this.labelInt}`;\n    },\n    // compute field type\n    fieldType() {\n      return this.formFieldXAttrs.field_type || 'text';\n    },\n    tabs() {\n      if (this.field.items && this.field.items.properties && this.field.items.properties.data\n        && this.field.items.properties.data.items\n        && this.field.items.properties.data.items.properties\n        && this.field.items.properties.data.items.properties.language) {\n        return Object.keys(this.field.items.properties\n          .data.items.properties\n          .language.properties\n          .label.properties).filter(lang => this.availableLocales.includes(lang));\n      }\n      return [];\n    },\n    /**\n     * check if field is either type integer of float\n     * @returns {boolean}\n     */\n    isNumberField() {\n      // get OpenAPI json field type and check if its a repeatable field (array)\n      const openAPIFieldType = this.field.items ? this.field.items.type : this.field.type;\n      // valid OpenAPI number field types are 'integer' and 'number'\n      return ['integer', 'number'].includes(openAPIFieldType)\n        // include 'text' here for backwards compatibility\n        && ['integer', 'float', 'text'].includes(this.fieldType);\n    },\n    /**\n     * check allowed number of decimals\n     * @returns {number|null}\n     */\n    allowedDecimals() {\n      // check if decimals were configured with priority for x-attrs\n      const decimals = this.formFieldXAttrs.decimals || this.fieldProps.decimals;\n      // get OpenAPI definition field type and also consider repeatable fields\n      const numberFieldType = this.field.type === 'array' ? this.field.items.type : this.field.type;\n      // get the OpenAPI definition field format\n      const numberFieldFormat = this.field.type === 'array' ? this.field.items.format : this.field.format;\n      // for OpenAPI data type 'number', that have format specified allow endless decimals\n      // only 'float' and 'double' are defined in OpenAPI but it is an \"open string-valued property\"\n      // so adding 'decimal' since backend model has data type Decimal\n      if ((numberFieldType === 'number' && ['float', 'double', 'decimal'].includes(numberFieldFormat))\n        && !(decimals || decimals === 0)) {\n        return -1;\n      }\n      // for type float and decimals set limit to decimals\n      if ((numberFieldType === 'number' || this.fieldProps.fieldType === 'number')\n        && ['float', 'double', 'decimal'].includes(numberFieldFormat) && (decimals || decimals === 0)) {\n        return decimals;\n      }\n      // for type integer prevent decimals\n      if (numberFieldType === 'integer' || this.fieldProps.fieldType === 'number' || decimals === 0) {\n        return 0;\n      }\n      return null;\n    },\n  },\n  watch: {\n    fieldValue: {\n      handler(val) {\n        if (JSON.stringify(this.fieldValueInt) !== JSON.stringify(val)) {\n          this.setFieldValue(val);\n          const tabs = this.fieldProps.tabs || this.tabs;\n          if (tabs && tabs.length) {\n            this.activeTab = this.setActiveTab();\n          }\n        }\n      },\n      immediate: true,\n    },\n    fieldValueInt: {\n      handler(val) {\n        // prevent event being fired when change comes from outside\n        if (val !== undefined && JSON.stringify(this.fieldValue) !== JSON.stringify(val)) {\n          /**\n           * Event emitted when field value changed internally\n           *\n           * @event field-value-changed\n           * @property {Object, Array, String, Number} - the changed field value\n           */\n          this.$emit('field-value-changed', val);\n        }\n      },\n      deep: true,\n    },\n    dropDownList: {\n      handler() {\n        this.fetchingData = false;\n      },\n      deep: true,\n    },\n  },\n  mounted() {\n    // the first time the field is mounted set the initial field value\n    // and tabs (if applicable)\n    this.setFieldValue(this.fieldValue);\n    if (this.tabs && this.tabs.length) {\n      this.activeTab = this.setActiveTab();\n    }\n  },\n  methods: {\n    // function for setting internal field value breaking all potential links to\n    // value passed from parent\n    setFieldValue(val) {\n      if (val && typeof val === 'object') {\n        // check if it is array\n        if (val.length >= 0) {\n          this.fieldValueInt = [].concat(JSON.parse(JSON.stringify(val)));\n          // else assume it is object\n        } else {\n          this.fieldValueInt = { ...JSON.parse(JSON.stringify(val)) };\n        }\n        // or simply assign directly if string\n      } else {\n        this.fieldValueInt = val;\n      }\n    },\n    // as above but specific for multiline text input field\n    setInputValue(val) {\n      if (!val || typeof val === 'string' || typeof val === 'number') {\n        this.fieldValueInt = val;\n      } else {\n        this.fieldValueInt = { ...this.fieldValueInt, ...JSON.parse(JSON.stringify(val)) };\n      }\n    },\n    /**\n     * called by chips input autocomplete\n     * @param {Object} event - the spread object emitted\n     * @property {string} event.value - the string in the input field\n     */\n    fetchAutocomplete({ value }) {\n      this.fetchingData = true;\n      this.textInput = value;\n      /**\n       * Event emitted for text input on autocomplete fields (field types `autocomplete`,\n       * `chips`, `chips-below`)\n       *\n       * @event fetch-autocomplete\n       * @property {string} value - the string to autocomplete\n       * @property {string} name - the name of the field\n       * @property {string} source - the url to request the data from\n       * @property {?string} equivalent - string specified for related fields e.g. for contributor roles equivalent is 'contributor'\n       * @property {?string[]} parentFields - in case the autocomplete event originates from a subform the subform id's (field property names) are specififed in this array (most nested property last)\n       */\n      this.$emit('fetch-autocomplete', {\n        value,\n        name: this.field.name,\n        source: this.formFieldXAttrs.source,\n        equivalent: this.formFieldXAttrs.equivalent,\n      });\n    },\n    /**\n     * called from subform - already contains all the information to pass\n     * to parent (see above for details)\n     * @param {Object} autocompleteInformation\n     */\n    subFormFetchAutocomplete(autocompleteInformation) {\n      const parentFieldsArary = autocompleteInformation.parentFields || [];\n      parentFieldsArary.unshift(this.field.name);\n      this.$emit('fetch-autocomplete', {\n        ...autocompleteInformation,\n        parentFields: parentFieldsArary,\n      });\n    },\n    /**\n     * function getting label from all possible label structures (lang object (--> get\n     // correct lang) or simple string)\n     * @param {string|Object} value - the language string or object - if object it contains\n     * all the languages e.g. { de: '', en: '' }\n     * @returns {string}\n     */\n    getLabel(value) {\n      return this.getLangLabel(value, this.language, true);\n    },\n    // functionality for multiline text input with language tabs\n    setActiveTab() {\n      // check which locales have content\n      const localesWithContent = this.availableLocales.filter(lang => !!this.fieldValueInt[lang]);\n      // if none of the locales has content or the current locale has content\n      // - return current locale - else first alternative\n      return !localesWithContent.length || this.fieldValueInt[this.language]\n        ? this.language : localesWithContent[0];\n    },\n    // function for mulitline text input to set drop down field correctly\n    setMultilineDropDown(val) {\n      // set texts type value if present - otherwise set empty\n      this.$set(this.fieldValueInt, 'type', val.source ? val : null);\n    },\n    // prevent default action for everything except multiline\n    onEnter(event) {\n      if (this.fieldType !== 'multiline') {\n        event.preventDefault();\n      } else {\n        /**\n         * event emitted by field type `multiline`\n         * @event keydown\n         * @param {KeyboardEvent} - the native keydown event\n         */\n        this.$emit('keydown', event);\n      }\n    },\n    fetchBoxData() {\n      /**\n       * event triggered when hover box data should be fetched\n       * @event fetch-info-data\n       */\n      this.$emit('fetch-info-data');\n    },\n  },\n};\n</script>\n\n<style lang=\"scss\" scoped>\n  @import \"../../styles/variables\";\n\n  .base-form-field-creator__field-array {\n    margin-top: $spacing-small;\n    display: flex;\n    flex-direction: column;\n\n    .base-form-field-creator__field-array-label {\n      color: $font-color-second;\n      margin-bottom: $spacing-small;\n      z-index: map-get($zindex, boxcontent);\n    }\n\n    .base-form-field-creator__subform-wrapper {\n      border-right: 3px solid rgb(240, 240, 240);\n      border-left: 3px solid rgb(240, 240, 240);\n\n      .base-form-field-creator__subform {\n        position: relative;\n        margin: -$spacing auto;\n        width: calc(100% - 6px);\n\n        @media screen and (max-width: $mobile) {\n          margin: -$spacing auto;\n        }\n      }\n    }\n  }\n\n  .base-form-field-creator__date-field-wrapper {\n    display: flex;\n\n    .base-form-field-creator__date-field + .base-form-field-creator__date-field {\n      margin-left: $spacing;\n    }\n  }\n\n  .base-form-field-creator__multiline-dropdown {\n    text-transform: capitalize;\n  }\n\n  .base-form-field-creator__chips-dropdown-second {\n    margin-left: $spacing;\n    color: $font-color-second;\n    font-size: $font-size-small;\n    margin-top: 1px;\n    flex-grow: 2;\n  }\n\n  .base-form-field-creator__chips-dropdown-third {\n    color: $font-color-third;\n    font-size: $font-size-small;\n    margin-top: auto;\n    white-space: nowrap;\n  }\n\n  .base-form-field-creator__date-fieldset {\n    display: contents;\n  }\n\n  .base-form-field-creator__toggle {\n    display: flex;\n    flex-direction: column;\n  }\n\n  @media screen and (max-width: 1260px) {\n    .base-form-field-creator__date-field-wrapper {\n      display: block;\n      .base-form-field-creator__date-field + .base-form-field-creator__date-field {\n        margin-top: $spacing;\n        margin-left: 0;\n      }\n    }\n  }\n</style>\n"],"names":["_sfc_main","m","i18n","val","prop","props","fieldName","dropDownLists","lang","openAPIFieldType","decimals","numberFieldType","numberFieldFormat","tabs","value","autocompleteInformation","parentFieldsArary","localesWithContent","event"],"mappings":"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"}